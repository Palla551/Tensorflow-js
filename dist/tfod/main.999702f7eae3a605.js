(self.webpackChunkTFOD=self.webpackChunkTFOD||[]).push([[179],{7430:(mt,Le,O)=>{"use strict";var ue={};function xe(n){return"function"==typeof n}function G(n){const e=n(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}O.r(ue),O.d(ue,{addImpl:()=>tN,bincountImpl:()=>$x,bincountReduceImpl:()=>aN,castImpl:()=>eN,ceilImpl:()=>lN,concatImpl:()=>cN,equalImpl:()=>hN,expImpl:()=>fN,expm1Impl:()=>gN,floorImpl:()=>_N,gatherNdImpl:()=>vN,gatherV2Impl:()=>xN,greaterEqualImpl:()=>wN,greaterImpl:()=>CN,lessEqualImpl:()=>EN,lessImpl:()=>SN,linSpaceImpl:()=>DN,logImpl:()=>TN,maxImpl:()=>IN,maximumImpl:()=>NN,minimumImpl:()=>kN,multiplyImpl:()=>Lx,negImpl:()=>RN,notEqualImpl:()=>ON,prodImpl:()=>LN,raggedGatherImpl:()=>VN,raggedRangeImpl:()=>zN,raggedTensorToTensorImpl:()=>jN,rangeImpl:()=>GN,rsqrtImpl:()=>KN,scatterImpl:()=>Bu,sigmoidImpl:()=>Uj,simpleAbsImpl:()=>rN,sliceImpl:()=>iN,sparseFillEmptyRowsImpl:()=>qN,sparseReshapeImpl:()=>ZN,sparseSegmentReductionImpl:()=>Wx,sqrtImpl:()=>yX,staticRegexReplaceImpl:()=>YN,stridedSliceImpl:()=>QN,stringNGramsImpl:()=>JN,stringSplitImpl:()=>ek,stringToHashBucketFastImpl:()=>tk,subImpl:()=>yN,tileImpl:()=>nk,topKImpl:()=>sk,transposeImpl:()=>Fx,uniqueImpl:()=>ik});const q=G(n=>function(e){n(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,s)=>`${s+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function P(n,t){if(n){const e=n.indexOf(t);0<=e&&n.splice(e,1)}}class U{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const o of e)o.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(xe(r))try{r()}catch(o){t=o instanceof q?o.errors:[o]}const{_finalizers:s}=this;if(s){this._finalizers=null;for(const o of s)try{X(o)}catch(i){t=t??[],i instanceof q?t=[...t,...i.errors]:t.push(i)}}if(t)throw new q(t)}}add(t){var e;if(t&&t!==this)if(this.closed)X(t);else{if(t instanceof U){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(t)}}_hasParent(t){const{_parentage:e}=this;return e===t||Array.isArray(e)&&e.includes(t)}_addParent(t){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(t),e):e?[e,t]:t}_removeParent(t){const{_parentage:e}=this;e===t?this._parentage=null:Array.isArray(e)&&P(e,t)}remove(t){const{_finalizers:e}=this;e&&P(e,t),t instanceof U&&t._removeParent(this)}}U.EMPTY=(()=>{const n=new U;return n.closed=!0,n})();const pe=U.EMPTY;function ce(n){return n instanceof U||n&&"closed"in n&&xe(n.remove)&&xe(n.add)&&xe(n.unsubscribe)}function X(n){xe(n)?n():n.unsubscribe()}const ie={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},re={setTimeout(n,t,...e){const{delegate:r}=re;return r?.setTimeout?r.setTimeout(n,t,...e):setTimeout(n,t,...e)},clearTimeout(n){const{delegate:t}=re;return(t?.clearTimeout||clearTimeout)(n)},delegate:void 0};function I(n){re.setTimeout(()=>{const{onUnhandledError:t}=ie;if(!t)throw n;t(n)})}function se(){}const Ae=ut("C",void 0,void 0);function ut(n,t,e){return{kind:n,value:t,error:e}}let ot=null;function Mt(n){if(ie.useDeprecatedSynchronousErrorHandling){const t=!ot;if(t&&(ot={errorThrown:!1,error:null}),n(),t){const{errorThrown:e,error:r}=ot;if(ot=null,e)throw r}}else n()}class de extends U{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,ce(t)&&t.add(this)):this.destination=Re}static create(t,e,r){return new ae(t,e,r)}next(t){this.isStopped?he(function Fe(n){return ut("N",n,void 0)}(t),this):this._next(t)}error(t){this.isStopped?he(function ge(n){return ut("E",void 0,n)}(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?he(Ae,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const nt=Function.prototype.bind;function Be(n,t){return nt.call(n,t)}class Q{constructor(t){this.partialObserver=t}next(t){const{partialObserver:e}=this;if(e.next)try{e.next(t)}catch(r){F(r)}}error(t){const{partialObserver:e}=this;if(e.error)try{e.error(t)}catch(r){F(r)}else F(t)}complete(){const{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(e){F(e)}}}class ae extends de{constructor(t,e,r){let s;if(super(),xe(t)||!t)s={next:t??void 0,error:e??void 0,complete:r??void 0};else{let o;this&&ie.useDeprecatedNextContext?(o=Object.create(t),o.unsubscribe=()=>this.unsubscribe(),s={next:t.next&&Be(t.next,o),error:t.error&&Be(t.error,o),complete:t.complete&&Be(t.complete,o)}):s=t}this.destination=new Q(s)}}function F(n){ie.useDeprecatedSynchronousErrorHandling?function ct(n){ie.useDeprecatedSynchronousErrorHandling&&ot&&(ot.errorThrown=!0,ot.error=n)}(n):I(n)}function he(n,t){const{onStoppedNotification:e}=ie;e&&re.setTimeout(()=>e(n,t))}const Re={closed:!0,next:se,error:function ee(n){throw n},complete:se},S="function"==typeof Symbol&&Symbol.observable||"@@observable";function ze(n){return n}function ve(n){return 0===n.length?ze:1===n.length?n[0]:function(e){return n.reduce((r,s)=>s(r),e)}}let Me=(()=>{class n{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new n;return r.source=this,r.operator=e,r}subscribe(e,r,s){const o=function _t(n){return n&&n instanceof de||function we(n){return n&&xe(n.next)&&xe(n.error)&&xe(n.complete)}(n)&&ce(n)}(e)?e:new ae(e,r,s);return Mt(()=>{const{operator:i,source:a}=this;o.add(i?i.call(o,a):a?this._subscribe(o):this._trySubscribe(o))}),o}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=ke(r))((s,o)=>{const i=new ae({next:a=>{try{e(a)}catch(l){o(l),i.unsubscribe()}},error:o,complete:s});this.subscribe(i)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[S](){return this}pipe(...e){return ve(e)(this)}toPromise(e){return new(e=ke(e))((r,s)=>{let o;this.subscribe(i=>o=i,i=>s(i),()=>r(o))})}}return n.create=t=>new n(t),n})();function ke(n){var t;return null!==(t=n??ie.Promise)&&void 0!==t?t:Promise}const At=G(n=>function(){n(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let et=(()=>{class n extends Me{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new Kt(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new At}next(e){Mt(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){Mt(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){Mt(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:s,observers:o}=this;return r||s?pe:(this.currentObservers=null,o.push(e),new U(()=>{this.currentObservers=null,P(o,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:s,isStopped:o}=this;r?e.error(s):o&&e.complete()}asObservable(){const e=new Me;return e.source=this,e}}return n.create=(t,e)=>new Kt(t,e),n})();class Kt extends et{constructor(t,e){super(),this.destination=t,this.source=e}next(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,t)}error(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,t)}complete(){var t,e;null===(e=null===(t=this.destination)||void 0===t?void 0:t.complete)||void 0===e||e.call(t)}_subscribe(t){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(t))&&void 0!==r?r:pe}}function dn(n){return xe(n?.lift)}function nn(n){return t=>{if(dn(t))return t.lift(function(e){try{return n(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function Vt(n,t,e,r,s){return new rn(n,t,e,r,s)}class rn extends de{constructor(t,e,r,s,o,i){super(t),this.onFinalize=o,this.shouldUnsubscribe=i,this._next=e?function(a){try{e(a)}catch(l){t.error(l)}}:super._next,this._error=s?function(a){try{s(a)}catch(l){t.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(t=this.onFinalize)||void 0===t||t.call(this))}}}function gt(n,t){return nn((e,r)=>{let s=0;e.subscribe(Vt(r,o=>{r.next(n.call(t,o,s++))}))})}function Ds(n){return this instanceof Ds?(this.v=n,this):new Ds(n)}function Xi(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,t=n[Symbol.asyncIterator];return t?t.call(n):(n=function Si(n){var t="function"==typeof Symbol&&Symbol.iterator,e=t&&n[t],r=0;if(e)return e.call(n);if(n&&"number"==typeof n.length)return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(n),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(o){e[o]=n[o]&&function(i){return new Promise(function(a,l){!function s(o,i,a,l){Promise.resolve(l).then(function(c){o({value:c,done:a})},i)}(a,l,(i=n[o](i)).done,i.value)})}}}const Zi=n=>n&&"number"==typeof n.length&&"function"!=typeof n;function vo(n){return xe(n?.then)}function dl(n){return xe(n[S])}function _r(n){return Symbol.asyncIterator&&xe(n?.[Symbol.asyncIterator])}function vr(n){return new TypeError(`You provided ${null!==n&&"object"==typeof n?"an invalid object":`'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const Jo=function Js(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function Ei(n){return xe(n?.[Jo])}function eo(n){return function Ki(n,t,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,r=e.apply(n,t||[]),o=[];return s={},i("next"),i("throw"),i("return"),s[Symbol.asyncIterator]=function(){return this},s;function i(p){r[p]&&(s[p]=function(m){return new Promise(function(y,_){o.push([p,m,y,_])>1||a(p,m)})})}function a(p,m){try{!function l(p){p.value instanceof Ds?Promise.resolve(p.value.v).then(c,u):d(o[0][2],p)}(r[p](m))}catch(y){d(o[0][3],y)}}function c(p){a("next",p)}function u(p){a("throw",p)}function d(p,m){p(m),o.shift(),o.length&&a(o[0][0],o[0][1])}}(this,arguments,function*(){const e=n.getReader();try{for(;;){const{value:r,done:s}=yield Ds(e.read());if(s)return yield Ds(void 0);yield yield Ds(r)}}finally{e.releaseLock()}})}function Di(n){return xe(n?.getReader)}function Dr(n){if(n instanceof Me)return n;if(null!=n){if(dl(n))return function Po(n){return new Me(t=>{const e=n[S]();if(xe(e.subscribe))return e.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(n);if(Zi(n))return function hl(n){return new Me(t=>{for(let e=0;e<n.length&&!t.closed;e++)t.next(n[e]);t.complete()})}(n);if(vo(n))return function Yi(n){return new Me(t=>{n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,I)})}(n);if(_r(n))return $o(n);if(Ei(n))return function ql(n){return new Me(t=>{for(const e of n)if(t.next(e),t.closed)return;t.complete()})}(n);if(Di(n))return function pl(n){return $o(eo(n))}(n)}throw vr(n)}function $o(n){return new Me(t=>{(function Zl(n,t){var e,r,s,o;return function Mr(n,t,e,r){return new(e||(e=Promise))(function(o,i){function a(u){try{c(r.next(u))}catch(d){i(d)}}function l(u){try{c(r.throw(u))}catch(d){i(d)}}function c(u){u.done?o(u.value):function s(o){return o instanceof e?o:new e(function(i){i(o)})}(u.value).then(a,l)}c((r=r.apply(n,t||[])).next())})}(this,void 0,void 0,function*(){try{for(e=Xi(n);!(r=yield e.next()).done;)if(t.next(r.value),t.closed)return}catch(i){s={error:i}}finally{try{r&&!r.done&&(o=e.return)&&(yield o.call(e))}finally{if(s)throw s.error}}t.complete()})})(n,t).catch(e=>t.error(e))})}function Ps(n,t,e,r=0,s=!1){const o=t.schedule(function(){e(),s?n.add(this.schedule(null,r)):this.unsubscribe()},r);if(n.add(o),!s)return o}function hr(n,t,e=1/0){return xe(t)?hr((r,s)=>gt((o,i)=>t(r,o,s,i))(Dr(n(r,s))),e):("number"==typeof t&&(e=t),nn((r,s)=>function ei(n,t,e,r,s,o,i,a){const l=[];let c=0,u=0,d=!1;const p=()=>{d&&!l.length&&!c&&t.complete()},m=_=>c<r?y(_):l.push(_),y=_=>{o&&t.next(_),c++;let C=!1;Dr(e(_,u++)).subscribe(Vt(t,D=>{s?.(D),o?m(D):t.next(D)},()=>{C=!0},void 0,()=>{if(C)try{for(c--;l.length&&c<r;){const D=l.shift();i?Ps(t,i,()=>y(D)):y(D)}p()}catch(D){t.error(D)}}))};return n.subscribe(Vt(t,m,()=>{d=!0,p()})),()=>{a?.()}}(r,s,n,e)))}function ti(n=1/0){return hr(ze,n)}const to=new Me(n=>n.complete());function Lo(n){return n&&xe(n.schedule)}function Ia(n){return n[n.length-1]}function Aa(n){return xe(Ia(n))?n.pop():void 0}function $s(n){return Lo(Ia(n))?n.pop():void 0}function Yt(n,t=0){return nn((e,r)=>{e.subscribe(Vt(r,s=>Ps(r,n,()=>r.next(s),t),()=>Ps(r,n,()=>r.complete(),t),s=>Ps(r,n,()=>r.error(s),t)))})}function Ln(n,t=0){return nn((e,r)=>{r.add(n.schedule(()=>e.subscribe(r),t))})}function Ts(n,t){if(!n)throw new Error("Iterable cannot be null");return new Me(e=>{Ps(e,t,()=>{const r=n[Symbol.asyncIterator]();Ps(e,t,()=>{r.next().then(s=>{s.done?e.complete():e.next(s.value)})},0,!0)})})}function pr(n,t){return t?function Bo(n,t){if(null!=n){if(dl(n))return function Ls(n,t){return Dr(n).pipe(Ln(t),Yt(t))}(n,t);if(Zi(n))return function ni(n,t){return new Me(e=>{let r=0;return t.schedule(function(){r===n.length?e.complete():(e.next(n[r++]),e.closed||this.schedule())})})}(n,t);if(vo(n))return function Tn(n,t){return Dr(n).pipe(Ln(t),Yt(t))}(n,t);if(_r(n))return Ts(n,t);if(Ei(n))return function xo(n,t){return new Me(e=>{let r;return Ps(e,t,()=>{r=n[Jo](),Ps(e,t,()=>{let s,o;try{({value:s,done:o}=r.next())}catch(i){return void e.error(i)}o?e.complete():e.next(s)},0,!0)}),()=>xe(r?.return)&&r.return()})}(n,t);if(Di(n))return function Bs(n,t){return Ts(eo(n),t)}(n,t)}throw vr(n)}(n,t):Dr(n)}function fs(...n){const t=$s(n),e=function fl(n,t){return"number"==typeof Ia(n)?n.pop():t}(n,1/0),r=n;return r.length?1===r.length?Dr(r[0]):ti(e)(pr(r,t)):to}function Qi(n={}){const{connector:t=(()=>new et),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:s=!0}=n;return o=>{let i,a,l,c=0,u=!1,d=!1;const p=()=>{a?.unsubscribe(),a=void 0},m=()=>{p(),i=l=void 0,u=d=!1},y=()=>{const _=i;m(),_?.unsubscribe()};return nn((_,C)=>{c++,!d&&!u&&p();const D=l=l??t();C.add(()=>{c--,0===c&&!d&&!u&&(a=qn(y,s))}),D.subscribe(C),!i&&c>0&&(i=new ae({next:N=>D.next(N),error:N=>{d=!0,p(),a=qn(m,e,N),D.error(N)},complete:()=>{u=!0,p(),a=qn(m,r),D.complete()}}),Dr(_).subscribe(i))})(o)}}function qn(n,t,...e){if(!0===t)return void n();if(!1===t)return;const r=new ae({next:()=>{r.unsubscribe(),n()}});return Dr(t(...e)).subscribe(r)}function on(n){for(let t in n)if(n[t]===on)return t;throw Error("Could not find renamed property on target object.")}function Na(n,t){for(const e in t)t.hasOwnProperty(e)&&!n.hasOwnProperty(e)&&(n[e]=t[e])}function Jn(n){if("string"==typeof n)return n;if(Array.isArray(n))return"["+n.map(Jn).join(", ")+"]";if(null==n)return""+n;if(n.overriddenName)return`${n.overriddenName}`;if(n.name)return`${n.name}`;const t=n.toString();if(null==t)return""+t;const e=t.indexOf("\n");return-1===e?t:t.substring(0,e)}function Ji(n,t){return null==n||""===n?null===t?"":t:null==t||""===t?n:n+" "+t}const jr=on({__forward_ref__:on});function Fn(n){return n.__forward_ref__=Fn,n.toString=function(){return Jn(this())},n}function an(n){return ka(n)?n():n}function ka(n){return"function"==typeof n&&n.hasOwnProperty(jr)&&n.__forward_ref__===Fn}function ri(n){return n&&!!n.\u0275providers}const si="https://g.co/ng/security#xss";class qe extends Error{constructor(t,e){super(function oi(n,t){return`NG0${Math.abs(n)}${t?": "+t:""}`}(t,e)),this.code=t}}function un(n){return"string"==typeof n?n:null==n?"":String(n)}function Vo(n,t){throw new qe(-201,!1)}function ts(n,t){null==n&&function En(n,t,e,r){throw new Error(`ASSERTION ERROR: ${n}`+(null==r?"":` [Expected=> ${e} ${r} ${t} <=Actual]`))}(t,n,null,"!=")}function b(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function B(n){return{providers:n.providers||[],imports:n.imports||[]}}function ne(n){return Ie(n,xt)||Ie(n,Gt)}function Ie(n,t){return n.hasOwnProperty(t)?n[t]:null}function dt(n){return n&&(n.hasOwnProperty(Tt)||n.hasOwnProperty(ln))?n[Tt]:null}const xt=on({\u0275prov:on}),Tt=on({\u0275inj:on}),Gt=on({ngInjectableDef:on}),ln=on({ngInjectorDef:on});var Dt=(()=>((Dt=Dt||{})[Dt.Default=0]="Default",Dt[Dt.Host=1]="Host",Dt[Dt.Self=2]="Self",Dt[Dt.SkipSelf=4]="SkipSelf",Dt[Dt.Optional=8]="Optional",Dt))();let $t;function Vn(n){const t=$t;return $t=n,t}function Us(n,t,e){const r=ne(n);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&Dt.Optional?null:void 0!==t?t:void Vo(Jn(n))}const be=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),Ii={},yl="__NG_DI_FLAG__",tc="ngTempTokenPath",$h=/\n/gm,nc="__source";let Fa;function Ai(n){const t=Fa;return Fa=n,t}function nu(n,t=Dt.Default){if(void 0===Fa)throw new qe(-203,!1);return null===Fa?Us(n,void 0,t):Fa.get(n,t&Dt.Optional?null:void 0,t)}function Ke(n,t=Dt.Default){return(function pn(){return $t}()||nu)(an(n),t)}function Ft(n,t=Dt.Default){return Ke(n,bl(t))}function bl(n){return typeof n>"u"||"number"==typeof n?n:0|(n.optional&&8)|(n.host&&1)|(n.self&&2)|(n.skipSelf&&4)}function ru(n){const t=[];for(let e=0;e<n.length;e++){const r=an(n[e]);if(Array.isArray(r)){if(0===r.length)throw new qe(900,!1);let s,o=Dt.Default;for(let i=0;i<r.length;i++){const a=r[i],l=Un(a);"number"==typeof l?-1===l?s=a.token:o|=l:s=a}t.push(Ke(s,o))}else t.push(Ke(r))}return t}function _l(n,t){return n[yl]=t,n.prototype[yl]=t,n}function Un(n){return n[yl]}function ci(n){return{toString:n}.toString()}var ro=(()=>((ro=ro||{})[ro.OnPush=0]="OnPush",ro[ro.Default=1]="Default",ro))(),gs=(()=>{return(n=gs||(gs={}))[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",gs;var n})();const zs={},zn=[],Pa=on({\u0275cmp:on}),su=on({\u0275dir:on}),rc=on({\u0275pipe:on}),sd=on({\u0275mod:on}),ui=on({\u0275fac:on}),Ni=on({__NG_ELEMENT_ID__:on}),ou=on({__NG_ENV_ID__:on});function sc(n,t,e){let r=n.length;for(;;){const s=n.indexOf(t,e);if(-1===s)return s;if(0===s||n.charCodeAt(s-1)<=32){const o=t.length;if(s+o===r||n.charCodeAt(s+o)<=32)return s}e=s+1}}function iu(n,t,e){let r=0;for(;r<e.length;){const s=e[r];if("number"==typeof s){if(0!==s)break;r++;const o=e[r++],i=e[r++],a=e[r++];n.setAttribute(t,i,a,o)}else{const o=s,i=e[++r];lu(o)?n.setProperty(t,o,i):n.setAttribute(t,o,i),r++}}return r}function au(n){return 3===n||4===n||6===n}function lu(n){return 64===n.charCodeAt(0)}function ra(n,t){if(null!==t&&0!==t.length)if(null===n||0===n.length)n=t.slice();else{let e=-1;for(let r=0;r<t.length;r++){const s=t[r];"number"==typeof s?e=s:0===e||oc(n,e,s,null,-1===e||2===e?t[++r]:null)}}return n}function oc(n,t,e,r,s){let o=0,i=n.length;if(-1===t)i=-1;else for(;o<n.length;){const a=n[o++];if("number"==typeof a){if(a===t){i=-1;break}if(a>t){i=o-1;break}}}for(;o<n.length;){const a=n[o];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==s&&(n[o+1]=s));if(r===n[o+1])return void(n[o+2]=s)}o++,null!==r&&o++,null!==s&&o++}-1!==i&&(n.splice(i,0,t),o=i+1),n.splice(o++,0,e),null!==r&&n.splice(o++,0,r),null!==s&&n.splice(o++,0,s)}const od="ng-template";function Bh(n,t,e){let r=0,s=!0;for(;r<n.length;){let o=n[r++];if("string"==typeof o&&s){const i=n[r++];if(e&&"class"===o&&-1!==sc(i.toLowerCase(),t,0))return!0}else{if(1===o){for(;r<n.length&&"string"==typeof(o=n[r++]);)if(o.toLowerCase()===t)return!0;return!1}"number"==typeof o&&(s=!1)}}return!1}function id(n){return 4===n.type&&n.value!==od}function cu(n,t,e){return t===(4!==n.type||e?n.value:od)}function ic(n,t,e){let r=4;const s=n.attrs||[],o=function uu(n){for(let t=0;t<n.length;t++)if(au(n[t]))return t;return n.length}(s);let i=!1;for(let a=0;a<t.length;a++){const l=t[a];if("number"!=typeof l){if(!i)if(4&r){if(r=2|1&r,""!==l&&!cu(n,l,e)||""===l&&1===t.length){if(ns(r))return!1;i=!0}}else{const c=8&r?l:t[++a];if(8&r&&null!==n.attrs){if(!Bh(n.attrs,c,e)){if(ns(r))return!1;i=!0}continue}const d=ki(8&r?"class":l,s,id(n),e);if(-1===d){if(ns(r))return!1;i=!0;continue}if(""!==c){let p;p=d>o?"":s[d+1].toLowerCase();const m=8&r?p:null;if(m&&-1!==sc(m,c,0)||2&r&&c!==p){if(ns(r))return!1;i=!0}}}}else{if(!i&&!ns(r)&&!ns(l))return!1;if(i&&ns(l))continue;i=!1,r=l|1&r}}return ns(r)||i}function ns(n){return 0==(1&n)}function ki(n,t,e,r){if(null===t)return-1;let s=0;if(r||!e){let o=!1;for(;s<t.length;){const i=t[s];if(i===n)return s;if(3===i||6===i)o=!0;else{if(1===i||2===i){let a=t[++s];for(;"string"==typeof a;)a=t[++s];continue}if(4===i)break;if(0===i){s+=4;continue}}s+=o?1:2}return-1}return function ac(n,t){let e=n.indexOf(4);if(e>-1)for(e++;e<n.length;){const r=n[e];if("number"==typeof r)return-1;if(r===t)return e;e++}return-1}(t,n)}function $a(n,t,e=!1){for(let r=0;r<t.length;r++)if(ic(n,t[r],e))return!0;return!1}function ad(n,t){e:for(let e=0;e<t.length;e++){const r=t[e];if(n.length===r.length){for(let s=0;s<n.length;s++)if(n[s]!==r[s])continue e;return!0}}return!1}function vl(n,t){return n?":not("+t.trim()+")":t}function De(n){let t=n[0],e=1,r=2,s="",o=!1;for(;e<n.length;){let i=n[e];if("string"==typeof i)if(2&r){const a=n[++e];s+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?s+="."+i:4&r&&(s+=" "+i);else""!==s&&!ns(i)&&(t+=vl(o,s),s=""),r=i,o=o||!ns(r);e++}return""!==s&&(t+=vl(o,s)),t}function ys(n){return ci(()=>{const t=ld(n),e={...t,decls:n.decls,vars:n.vars,template:n.template,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,onPush:n.changeDetection===ro.OnPush,directiveDefs:null,pipeDefs:null,dependencies:t.standalone&&n.dependencies||null,getStandaloneInjector:null,data:n.data||{},encapsulation:n.encapsulation||gs.Emulated,styles:n.styles||zn,_:null,schemas:n.schemas||null,tView:null,id:""};cd(e);const r=n.dependencies;return e.directiveDefs=lc(r,!1),e.pipeDefs=lc(r,!0),e.id=function Gh(n){let t=0;const e=[n.selectors,n.ngContentSelectors,n.hostVars,n.hostAttrs,n.consts,n.vars,n.decls,n.encapsulation,n.standalone,n.exportAs,JSON.stringify(n.inputs),JSON.stringify(n.outputs),Object.getOwnPropertyNames(n.type.prototype),!!n.contentQueries,!!n.viewQuery].join("|");for(const s of e)t=Math.imul(31,t)+s.charCodeAt(0)<<0;return t+=2147483648,"c"+t}(e),e})}function Mi(n){return jn(n)||rs(n)}function Wh(n){return null!==n}function Zn(n){return ci(()=>({type:n.type,bootstrap:n.bootstrap||zn,declarations:n.declarations||zn,imports:n.imports||zn,exports:n.exports||zn,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null}))}function La(n,t){if(null==n)return zs;const e={};for(const r in n)if(n.hasOwnProperty(r)){let s=n[r],o=s;Array.isArray(s)&&(o=s[1],s=s[0]),e[s]=r,t&&(t[s]=o)}return e}function It(n){return ci(()=>{const t=ld(n);return cd(t),t})}function jn(n){return n[Pa]||null}function rs(n){return n[su]||null}function Ns(n){return n[rc]||null}function Gr(n,t){const e=n[sd]||null;if(!e&&!0===t)throw new Error(`Type ${Jn(n)} does not have '\u0275mod' property.`);return e}function ld(n){const t={};return{type:n.type,providersResolver:null,factory:null,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:t,exportAs:n.exportAs||null,standalone:!0===n.standalone,selectors:n.selectors||zn,viewQuery:n.viewQuery||null,features:n.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:La(n.inputs,t),outputs:La(n.outputs)}}function cd(n){n.features?.forEach(t=>t(n))}function lc(n,t){if(!n)return null;const e=t?Ns:Mi;return()=>("function"==typeof n?n():n).map(r=>e(r)).filter(Wh)}const Pr=0,Bt=1,vn=2,fr=3,so=4,sa=5,ss=6,Ba=7,Cr=8,oa=9,ia=10,yn=11,xl=12,ud=13,Va=14,Rr=15,Cl=16,Ua=17,oo=18,wl=19,du=20,So=21,Eo=22,cc=23,uc=24,Pn=25,Sl=1,dd=2,zo=7,dc=8,za=9,Kr=11;function Hs(n){return Array.isArray(n)&&"object"==typeof n[Sl]}function ks(n){return Array.isArray(n)&&!0===n[Sl]}function hu(n){return 0!=(4&n.flags)}function di(n){return n.componentOffset>-1}function hc(n){return 1==(1&n.flags)}function Do(n){return!!n.template}function aa(n){return 0!=(512&n[vn])}function zt(n,t){return n.hasOwnProperty(ui)?n[ui]:null}let is=be.WeakRef??class Zt{constructor(t){this.ref=t}deref(){return this.ref}},pd=0,io=null,To=!1;function Tr(n){const t=io;return io=n,t}class ca{constructor(){this.id=pd++,this.ref=function as(n){return new is(n)}(this),this.producers=new Map,this.consumers=new Map,this.trackingVersion=0,this.valueVersion=0}consumerPollProducersForChange(){for(const[t,e]of this.producers){const r=e.producerNode.deref();if(void 0!==r&&e.atTrackingVersion===this.trackingVersion){if(r.producerPollStatus(e.seenValueVersion))return!0}else this.producers.delete(t),r?.consumers.delete(this.id)}return!1}producerMayHaveChanged(){const t=To;To=!0;try{for(const[e,r]of this.consumers){const s=r.consumerNode.deref();void 0!==s&&s.trackingVersion===r.atTrackingVersion?s.onConsumerDependencyMayHaveChanged():(this.consumers.delete(e),s?.producers.delete(this.id))}}finally{To=t}}producerAccessed(){if(To)throw new Error("");if(null===io)return;let t=io.producers.get(this.id);void 0===t?(t={consumerNode:io.ref,producerNode:this.ref,seenValueVersion:this.valueVersion,atTrackingVersion:io.trackingVersion},io.producers.set(this.id,t),this.consumers.set(io.id,t)):(t.seenValueVersion=this.valueVersion,t.atTrackingVersion=io.trackingVersion)}get hasProducers(){return this.producers.size>0}get producerUpdatesAllowed(){return!1!==io?.consumerAllowSignalWrites}producerPollStatus(t){return this.valueVersion!==t||(this.onProducerUpdateValueVersion(),this.valueVersion!==t)}}let nm=null;const rm=()=>{};class mu extends ca{constructor(t,e,r){super(),this.watch=t,this.schedule=e,this.dirty=!1,this.cleanupFn=rm,this.registerOnCleanup=s=>{this.cleanupFn=s},this.consumerAllowSignalWrites=r}notify(){this.dirty||this.schedule(this),this.dirty=!0}onConsumerDependencyMayHaveChanged(){this.notify()}onProducerUpdateValueVersion(){}run(){if(this.dirty=!1,0!==this.trackingVersion&&!this.consumerPollProducersForChange())return;const t=Tr(this);this.trackingVersion++;try{this.cleanupFn(),this.cleanupFn=rm,this.watch(this.registerOnCleanup)}finally{Tr(t)}}cleanup(){this.cleanupFn()}}class zb{constructor(t,e,r){this.previousValue=t,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function ao(){return sm}function sm(n){return n.type.prototype.ngOnChanges&&(n.setInput=Hb),om}function om(){const n=im(this),t=n?.current;if(t){const e=n.previous;if(e===zs)n.previous=t;else for(let r in t)e[r]=t[r];n.current=null,this.ngOnChanges(t)}}function Hb(n,t,e,r){const s=this.declaredInputs[e],o=im(n)||function gu(n,t){return n[gd]=t}(n,{previous:zs,current:null}),i=o.current||(o.current={}),a=o.previous,l=a[s];i[s]=new zb(l&&l.currentValue,t,a===zs),n[r]=t}ao.ngInherit=!0;const gd="__ngSimpleChanges__";function im(n){return n[gd]||null}const Oi=function(n,t,e){};function or(n){for(;Array.isArray(n);)n=n[Pr];return n}function lo(n,t){return or(t[n])}function ls(n,t){return or(t[n.index])}function cm(n,t){return n.data[t]}function co(n,t){const e=t[n];return Hs(e)?e:e[Pr]}function yd(n){return 128==(128&n[vn])}function Ha(n,t){return null==t?null:n[t]}function dm(n){n[Ua]=0}function Kb(n){1024&n[vn]||(n[vn]|=1024,pm(n,1))}function hm(n){1024&n[vn]&&(n[vn]&=-1025,pm(n,-1))}function pm(n,t){let e=n[fr];if(null===e)return;e[sa]+=t;let r=e;for(e=e[fr];null!==e&&(1===t&&1===r[sa]||-1===t&&0===r[sa]);)e[sa]+=t,r=e,e=e[fr]}const fn={lFrame:Em(null),bindingsEnabled:!0,skipHydrationRootTNode:null};function ym(){return fn.bindingsEnabled}function Wa(){return null!==fn.skipHydrationRootTNode}function ft(){return fn.lFrame.lView}function Wn(){return fn.lFrame.tView}function bs(){let n=xm();for(;null!==n&&64===n.type;)n=n.parent;return n}function xm(){return fn.lFrame.currentTNode}function Fi(n,t){const e=fn.lFrame;e.currentTNode=n,e.isParent=t}function np(){return fn.lFrame.isParent}function rp(){fn.lFrame.isParent=!1}function gc(){return fn.lFrame.bindingIndex++}function n_(n,t){const e=fn.lFrame;e.bindingIndex=e.bindingRootIndex=n,op(t)}function op(n){fn.lFrame.currentDirectiveIndex=n}function ip(n){const t=fn.lFrame.currentDirectiveIndex;return-1===t?null:n[t]}function Cm(){return fn.lFrame.currentQueryIndex}function ap(n){fn.lFrame.currentQueryIndex=n}function s_(n){const t=n[Bt];return 2===t.type?t.declTNode:1===t.type?n[ss]:null}function wm(n,t,e){if(e&Dt.SkipSelf){let s=t,o=n;for(;!(s=s.parent,null!==s||e&Dt.Host||(s=s_(o),null===s||(o=o[Va],10&s.type))););if(null===s)return!1;t=s,n=o}const r=fn.lFrame=Sm();return r.currentTNode=t,r.lView=n,!0}function lp(n){const t=Sm(),e=n[Bt];fn.lFrame=t,t.currentTNode=e.firstChild,t.lView=n,t.tView=e,t.contextLView=n,t.bindingIndex=e.bindingStartIndex,t.inI18n=!1}function Sm(){const n=fn.lFrame,t=null===n?null:n.child;return null===t?Em(n):t}function Em(n){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return null!==n&&(n.child=t),t}function Dm(){const n=fn.lFrame;return fn.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}const Tm=Dm;function _d(){const n=Dm();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function Ws(){return fn.lFrame.selectedIndex}function Dl(n){fn.lFrame.selectedIndex=n}function Ir(){const n=fn.lFrame;return cm(n.tView,n.selectedIndex)}let Nm=!0;function vd(){return Nm}function Ao(n){Nm=n}function xd(n,t){for(let e=t.directiveStart,r=t.directiveEnd;e<r;e++){const o=n.data[e].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:c,ngOnDestroy:u}=o;i&&(n.contentHooks??=[]).push(-e,i),a&&((n.contentHooks??=[]).push(e,a),(n.contentCheckHooks??=[]).push(e,a)),l&&(n.viewHooks??=[]).push(-e,l),c&&((n.viewHooks??=[]).push(e,c),(n.viewCheckHooks??=[]).push(e,c)),null!=u&&(n.destroyHooks??=[]).push(e,u)}}function yc(n,t,e){km(n,t,3,e)}function Cd(n,t,e,r){(3&n[vn])===e&&km(n,t,e,r)}function _u(n,t){let e=n[vn];(3&e)===t&&(e&=4095,e+=1,n[vn]=e)}function km(n,t,e,r){const o=r??-1,i=t.length-1;let a=0;for(let l=void 0!==r?65535&n[Ua]:0;l<i;l++)if("number"==typeof t[l+1]){if(a=t[l],null!=r&&a>=r)break}else t[l]<0&&(n[Ua]+=65536),(a<o||-1==o)&&(d_(n,e,t,l),n[Ua]=(4294901760&n[Ua])+l+2),l++}function Mm(n,t){Oi(4,n,t);const e=Tr(null);try{t.call(n)}finally{Tr(e),Oi(5,n,t)}}function d_(n,t,e,r){const s=e[r]<0,o=e[r+1],a=n[s?-e[r]:e[r]];s?n[vn]>>12<n[Ua]>>16&&(3&n[vn])===t&&(n[vn]+=4096,Mm(a,o)):Mm(a,o)}const bc=-1;class Tl{constructor(t,e,r){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function Rm(n){return n!==bc}function wd(n){return 32767&n}function Sd(n,t){let e=function f_(n){return n>>16}(n),r=t;for(;e>0;)r=r[Va],e--;return r}let dp=!0;function Ed(n){const t=dp;return dp=n,t}const Om=255,Fm=5;let m_=0;const Pi={};function Dd(n,t){const e=Pm(n,t);if(-1!==e)return e;const r=t[Bt];r.firstCreatePass&&(n.injectorIndex=t.length,Td(r.data,n),Td(t,null),Td(r.blueprint,null));const s=js(n,t),o=n.injectorIndex;if(Rm(s)){const i=wd(s),a=Sd(s,t),l=a[Bt].data;for(let c=0;c<8;c++)t[o+c]=a[i+c]|l[i+c]}return t[o+8]=s,o}function Td(n,t){n.push(0,0,0,0,0,0,0,0,t)}function Pm(n,t){return-1===n.injectorIndex||n.parent&&n.parent.injectorIndex===n.injectorIndex||null===t[n.injectorIndex+8]?-1:n.injectorIndex}function js(n,t){if(n.parent&&-1!==n.parent.injectorIndex)return n.parent.injectorIndex;let e=0,r=null,s=t;for(;null!==s;){if(r=Hm(s),null===r)return bc;if(e++,s=s[Va],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return bc}function hp(n,t,e){!function g_(n,t,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(Ni)&&(r=e[Ni]),null==r&&(r=e[Ni]=m_++);const s=r&Om;t.data[n+(s>>Fm)]|=1<<s}(n,t,e)}function $m(n,t,e){if(e&Dt.Optional||void 0!==n)return n;Vo()}function Lm(n,t,e,r){if(e&Dt.Optional&&void 0===r&&(r=null),!(e&(Dt.Self|Dt.Host))){const s=n[oa],o=Vn(void 0);try{return s?s.get(t,r,e&Dt.Optional):Us(t,r,e&Dt.Optional)}finally{Vn(o)}}return $m(r,0,e)}function Bm(n,t,e,r=Dt.Default,s){if(null!==n){if(2048&t[vn]){const i=function v_(n,t,e,r,s){let o=n,i=t;for(;null!==o&&null!==i&&2048&i[vn]&&!(512&i[vn]);){const a=Vm(o,i,e,r|Dt.Self,Pi);if(a!==Pi)return a;let l=o.parent;if(!l){const c=i[du];if(c){const u=c.get(e,Pi,r);if(u!==Pi)return u}l=Hm(i),i=i[Va]}o=l}return s}(n,t,e,r,Pi);if(i!==Pi)return i}const o=Vm(n,t,e,r,Pi);if(o!==Pi)return o}return Lm(t,e,r,s)}function Vm(n,t,e,r,s){const o=function b_(n){if("string"==typeof n)return n.charCodeAt(0)||0;const t=n.hasOwnProperty(Ni)?n[Ni]:void 0;return"number"==typeof t?t>=0?t&Om:__:t}(e);if("function"==typeof o){if(!wm(t,n,r))return r&Dt.Host?$m(s,0,r):Lm(t,e,r,s);try{const i=o(r);if(null!=i||r&Dt.Optional)return i;Vo()}finally{Tm()}}else if("number"==typeof o){let i=null,a=Pm(n,t),l=bc,c=r&Dt.Host?t[Rr][ss]:null;for((-1===a||r&Dt.SkipSelf)&&(l=-1===a?js(n,t):t[a+8],l!==bc&&zm(r,!1)?(i=t[Bt],a=wd(l),t=Sd(l,t)):a=-1);-1!==a;){const u=t[Bt];if(Um(o,a,u.data)){const d=y_(a,t,e,i,r,c);if(d!==Pi)return d}l=t[a+8],l!==bc&&zm(r,t[Bt].data[a+8]===c)&&Um(o,a,t)?(i=u,a=wd(l),t=Sd(l,t)):a=-1}}return s}function y_(n,t,e,r,s,o){const i=t[Bt],a=i.data[n+8],u=Id(a,i,e,null==r?di(a)&&dp:r!=i&&0!=(3&a.type),s&Dt.Host&&o===a);return null!==u?Il(t,i,u,a):Pi}function Id(n,t,e,r,s){const o=n.providerIndexes,i=t.data,a=1048575&o,l=n.directiveStart,u=o>>20,p=s?a+u:n.directiveEnd;for(let m=r?a:a+u;m<p;m++){const y=i[m];if(m<l&&e===y||m>=l&&y.type===e)return m}if(s){const m=i[l];if(m&&Do(m)&&m.type===e)return l}return null}function Il(n,t,e,r){let s=n[e];const o=t.data;if(function h_(n){return n instanceof Tl}(s)){const i=s;i.resolving&&function Ti(n,t){const e=t?`. Dependency path: ${t.join(" > ")} > ${n}`:"";throw new qe(-200,`Circular dependency in DI detected for ${n}${e}`)}(function Bn(n){return"function"==typeof n?n.name||n.toString():"object"==typeof n&&null!=n&&"function"==typeof n.type?n.type.name||n.type.toString():un(n)}(o[e]));const a=Ed(i.canSeeViewProviders);i.resolving=!0;const l=i.injectImpl?Vn(i.injectImpl):null;wm(n,r,Dt.Default);try{s=n[e]=i.factory(void 0,o,n,r),t.firstCreatePass&&e>=r.directiveStart&&function u_(n,t,e){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:o}=t.type.prototype;if(r){const i=sm(t);(e.preOrderHooks??=[]).push(n,i),(e.preOrderCheckHooks??=[]).push(n,i)}s&&(e.preOrderHooks??=[]).push(0-n,s),o&&((e.preOrderHooks??=[]).push(n,o),(e.preOrderCheckHooks??=[]).push(n,o))}(e,o[e],t)}finally{null!==l&&Vn(l),Ed(a),i.resolving=!1,Tm()}}return s}function Um(n,t,e){return!!(e[t+(n>>Fm)]&1<<n)}function zm(n,t){return!(n&Dt.Self||n&Dt.Host&&t)}class _c{constructor(t,e){this._tNode=t,this._lView=e}get(t,e,r){return Bm(this._tNode,this._lView,t,bl(r),e)}}function __(){return new _c(bs(),ft())}function pp(n){return ka(n)?()=>{const t=pp(an(n));return t&&t()}:zt(n)}function Hm(n){const t=n[Bt],e=t.type;return 2===e?t.declTNode:1===e?n[ss]:null}const Cc="__parameters__";function Sc(n,t,e){return ci(()=>{const r=function fp(n){return function(...e){if(n){const r=n(...e);for(const s in r)this[s]=r[s]}}}(t);function s(...o){if(this instanceof s)return r.apply(this,o),this;const i=new s(...o);return a.annotation=i,a;function a(l,c,u){const d=l.hasOwnProperty(Cc)?l[Cc]:Object.defineProperty(l,Cc,{value:[]})[Cc];for(;d.length<=u;)d.push(null);return(d[u]=d[u]||[]).push(i),l}}return e&&(s.prototype=Object.create(e.prototype)),s.prototype.ngMetadataName=n,s.annotationCls=s,s})}function Cu(n,t){n.forEach(e=>Array.isArray(e)?Cu(e,t):t(e))}function jm(n,t,e){t>=n.length?n.push(e):n.splice(t,0,e)}function T(n,t){return t>=n.length-1?n.pop():n.splice(t,1)[0]}function w(n,t){const e=[];for(let r=0;r<n;r++)e.push(t);return e}function K(n,t,e){let r=le(n,t);return r>=0?n[1|r]=e:(r=~r,function $(n,t,e,r){let s=n.length;if(s==t)n.push(e,r);else if(1===s)n.push(r,n[0]),n[0]=e;else{for(s--,n.push(n[s-1],n[s]);s>t;)n[s]=n[s-2],s--;n[t]=e,n[t+1]=r}}(n,r,t,e)),r}function Y(n,t){const e=le(n,t);if(e>=0)return n[1|e]}function le(n,t){return function Oe(n,t,e){let r=0,s=n.length>>e;for(;s!==r;){const o=r+(s-r>>1),i=n[o<<e];if(t===i)return o<<e;i>t?s=o:r=o+1}return~(s<<e)}(n,t,1)}const er=_l(Sc("Optional"),8),In=_l(Sc("SkipSelf"),4);function Xm(n){return 128==(128&n.flags)}var jo=(()=>((jo=jo||{})[jo.Important=1]="Important",jo[jo.DashCase=2]="DashCase",jo))();const T_=new Map;let aP=0;const A_="__ngContext__";function ho(n,t){Hs(t)?(n[A_]=t[wl],function cP(n){T_.set(n[wl],n)}(t)):n[A_]=t}let N_;function k_(n,t){return N_(n,t)}function gp(n){const t=n[fr];return ks(t)?t[fr]:t}function M_(n){return dS(n[xl])}function R_(n){return dS(n[so])}function dS(n){for(;null!==n&&!ks(n);)n=n[so];return n}function Nd(n,t,e,r,s){if(null!=r){let o,i=!1;ks(r)?o=r:Hs(r)&&(i=!0,r=r[Pr]);const a=or(r);0===n&&null!==e?null==s?gS(t,e,a):wu(t,e,a,s||null,!0):1===n&&null!==e?wu(t,e,a,s||null,!0):2===n?function eg(n,t,e){const r=Qm(n,t);r&&function IP(n,t,e,r){n.removeChild(t,e,r)}(n,r,t,e)}(t,a,i):3===n&&t.destroyNode(a),null!=o&&function kP(n,t,e,r,s){const o=e[zo];o!==or(e)&&Nd(t,n,r,o,s);for(let a=Kr;a<e.length;a++){const l=e[a];bp(l[Bt],l,n,t,r,o)}}(t,n,o,e,s)}}function Ym(n,t,e){return n.createElement(t,e)}function pS(n,t){const e=n[za],r=e.indexOf(t);hm(t),e.splice(r,1)}function F_(n,t){if(n.length<=Kr)return;const e=Kr+t,r=n[e];if(r){const s=r[Cl];null!==s&&s!==n&&pS(s,r),t>0&&(n[e-1][so]=r[so]);const o=T(n,Kr+t);!function vP(n,t){bp(n,t,t[yn],2,null,null),t[Pr]=null,t[ss]=null}(r[Bt],r);const i=o[oo];null!==i&&i.detachView(o[Bt]),r[fr]=null,r[so]=null,r[vn]&=-129}return r}function fS(n,t){if(!(256&t[vn])){const e=t[yn];t[cc]?.destroy(),t[uc]?.destroy(),e.destroyNode&&bp(n,t,e,3,null,null),function wP(n){let t=n[xl];if(!t)return P_(n[Bt],n);for(;t;){let e=null;if(Hs(t))e=t[xl];else{const r=t[Kr];r&&(e=r)}if(!e){for(;t&&!t[so]&&t!==n;)Hs(t)&&P_(t[Bt],t),t=t[fr];null===t&&(t=n),Hs(t)&&P_(t[Bt],t),e=t&&t[so]}t=e}}(t)}}function P_(n,t){if(!(256&t[vn])){t[vn]&=-129,t[vn]|=256,function TP(n,t){let e;if(null!=n&&null!=(e=n.destroyHooks))for(let r=0;r<e.length;r+=2){const s=t[e[r]];if(!(s instanceof Tl)){const o=e[r+1];if(Array.isArray(o))for(let i=0;i<o.length;i+=2){const a=s[o[i]],l=o[i+1];Oi(4,a,l);try{l.call(a)}finally{Oi(5,a,l)}}else{Oi(4,s,o);try{o.call(s)}finally{Oi(5,s,o)}}}}}(n,t),function DP(n,t){const e=n.cleanup,r=t[Ba];if(null!==e)for(let o=0;o<e.length-1;o+=2)if("string"==typeof e[o]){const i=e[o+3];i>=0?r[i]():r[-i].unsubscribe(),o+=2}else e[o].call(r[e[o+1]]);null!==r&&(t[Ba]=null);const s=t[So];if(null!==s){t[So]=null;for(let o=0;o<s.length;o++)(0,s[o])()}}(n,t),1===t[Bt].type&&t[yn].destroy();const e=t[Cl];if(null!==e&&ks(t[fr])){e!==t[fr]&&pS(e,t);const r=t[oo];null!==r&&r.detachView(n)}!function uP(n){T_.delete(n[wl])}(t)}}function $_(n,t,e){return function mS(n,t,e){let r=t;for(;null!==r&&40&r.type;)r=(t=r).parent;if(null===r)return e[Pr];{const{componentOffset:s}=r;if(s>-1){const{encapsulation:o}=n.data[r.directiveStart+s];if(o===gs.None||o===gs.Emulated)return null}return ls(r,e)}}(n,t.parent,e)}function wu(n,t,e,r,s){n.insertBefore(t,e,r,s)}function gS(n,t,e){n.appendChild(t,e)}function yS(n,t,e,r,s){null!==r?wu(n,t,e,r,s):gS(n,t,e)}function Qm(n,t){return n.parentNode(t)}function bS(n,t,e){return vS(n,t,e)}let L_,tg,z_,vS=function _S(n,t,e){return 40&n.type?ls(n,e):null};function Jm(n,t,e,r){const s=$_(n,r,t),o=t[yn],a=bS(r.parent||t[ss],r,t);if(null!=s)if(Array.isArray(e))for(let l=0;l<e.length;l++)yS(o,s,e[l],a,!1);else yS(o,s,e,a,!1);void 0!==L_&&L_(o,r,t,e,s)}function yp(n,t){if(null!==t){const e=t.type;if(3&e)return ls(t,n);if(4&e)return B_(-1,n[t.index]);if(8&e){const r=t.child;if(null!==r)return yp(n,r);{const s=n[t.index];return ks(s)?B_(-1,s):or(s)}}if(32&e)return k_(t,n)()||or(n[t.index]);{const r=CS(n,t);return null!==r?Array.isArray(r)?r[0]:yp(gp(n[Rr]),r):yp(n,t.next)}}return null}function CS(n,t){return null!==t?n[Rr][ss].projection[t.projection]:null}function B_(n,t){const e=Kr+n+1;if(e<t.length){const r=t[e],s=r[Bt].firstChild;if(null!==s)return yp(r,s)}return t[zo]}function V_(n,t,e,r,s,o,i){for(;null!=e;){const a=r[e.index],l=e.type;if(i&&0===t&&(a&&ho(or(a),r),e.flags|=2),32!=(32&e.flags))if(8&l)V_(n,t,e.child,r,s,o,!1),Nd(t,n,s,a,o);else if(32&l){const c=k_(e,r);let u;for(;u=c();)Nd(t,n,s,u,o);Nd(t,n,s,a,o)}else 16&l?SS(n,t,r,e,s,o):Nd(t,n,s,a,o);e=i?e.projectionNext:e.next}}function bp(n,t,e,r,s,o){V_(e,r,n.firstChild,t,s,o,!1)}function SS(n,t,e,r,s,o){const i=e[Rr],l=i[ss].projection[r.projection];if(Array.isArray(l))for(let c=0;c<l.length;c++)Nd(t,n,s,l[c],o);else{let c=l;const u=i[fr];Xm(r)&&(c.flags|=128),V_(n,t,c,u,s,o,!0)}}function ES(n,t,e){""===e?n.removeAttribute(t,"class"):n.setAttribute(t,"class",e)}function DS(n,t,e){const{mergedAttrs:r,classes:s,styles:o}=e;null!==r&&iu(n,t,r),null!==s&&ES(n,t,s),null!==o&&function RP(n,t,e){n.setAttribute(t,"style",e)}(n,t,o)}function kd(n){return function U_(){if(void 0===tg&&(tg=null,be.trustedTypes))try{tg=be.trustedTypes.createPolicy("angular",{createHTML:n=>n,createScript:n=>n,createScriptURL:n=>n})}catch{}return tg}()?.createHTML(n)||n}class Su{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${si})`}}class LP extends Su{getTypeName(){return"HTML"}}class BP extends Su{getTypeName(){return"Style"}}class VP extends Su{getTypeName(){return"Script"}}class UP extends Su{getTypeName(){return"URL"}}class zP extends Su{getTypeName(){return"ResourceURL"}}function hi(n){return n instanceof Su?n.changingThisBreaksApplicationSecurity:n}function Ga(n,t){const e=function HP(n){return n instanceof Su&&n.getTypeName()||null}(n);if(null!=e&&e!==t){if("ResourceURL"===e&&"URL"===t)return!0;throw new Error(`Required a safe ${t}, got a ${e} (see ${si})`)}return e===t}class qP{constructor(t){this.inertDocumentHelper=t}getInertBodyElement(t){t="<body><remove></remove>"+t;try{const e=(new window.DOMParser).parseFromString(kd(t),"text/html").body;return null===e?this.inertDocumentHelper.getInertBodyElement(t):(e.removeChild(e.firstChild),e)}catch{return null}}}class ZP{constructor(t){this.defaultDoc=t,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert")}getInertBodyElement(t){const e=this.inertDocument.createElement("template");return e.innerHTML=kd(t),e}}const QP=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;function rg(n){return(n=String(n)).match(QP)?n:"unsafe:"+n}function Nl(n){const t={};for(const e of n.split(","))t[e]=!0;return t}function vp(...n){const t={};for(const e of n)for(const r in e)e.hasOwnProperty(r)&&(t[r]=!0);return t}const kS=Nl("area,br,col,hr,img,wbr"),MS=Nl("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),RS=Nl("rp,rt"),W_=vp(kS,vp(MS,Nl("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),vp(RS,Nl("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),vp(RS,MS)),j_=Nl("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),OS=vp(j_,Nl("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),Nl("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),JP=Nl("script,style,template");class e2{constructor(){this.sanitizedSomething=!1,this.buf=[]}sanitizeChildren(t){let e=t.firstChild,r=!0;for(;e;)if(e.nodeType===Node.ELEMENT_NODE?r=this.startElement(e):e.nodeType===Node.TEXT_NODE?this.chars(e.nodeValue):this.sanitizedSomething=!0,r&&e.firstChild)e=e.firstChild;else for(;e;){e.nodeType===Node.ELEMENT_NODE&&this.endElement(e);let s=this.checkClobberedElement(e,e.nextSibling);if(s){e=s;break}e=this.checkClobberedElement(e,e.parentNode)}return this.buf.join("")}startElement(t){const e=t.nodeName.toLowerCase();if(!W_.hasOwnProperty(e))return this.sanitizedSomething=!0,!JP.hasOwnProperty(e);this.buf.push("<"),this.buf.push(e);const r=t.attributes;for(let s=0;s<r.length;s++){const o=r.item(s),i=o.name,a=i.toLowerCase();if(!OS.hasOwnProperty(a)){this.sanitizedSomething=!0;continue}let l=o.value;j_[a]&&(l=rg(l)),this.buf.push(" ",i,'="',FS(l),'"')}return this.buf.push(">"),!0}endElement(t){const e=t.nodeName.toLowerCase();W_.hasOwnProperty(e)&&!kS.hasOwnProperty(e)&&(this.buf.push("</"),this.buf.push(e),this.buf.push(">"))}chars(t){this.buf.push(FS(t))}checkClobberedElement(t,e){if(e&&(t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_CONTAINED_BY)===Node.DOCUMENT_POSITION_CONTAINED_BY)throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`);return e}}const t2=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,n2=/([^\#-~ |!])/g;function FS(n){return n.replace(/&/g,"&amp;").replace(t2,function(t){return"&#"+(1024*(t.charCodeAt(0)-55296)+(t.charCodeAt(1)-56320)+65536)+";"}).replace(n2,function(t){return"&#"+t.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let sg;function PS(n,t){let e=null;try{sg=sg||function NS(n){const t=new ZP(n);return function YP(){try{return!!(new window.DOMParser).parseFromString(kd(""),"text/html")}catch{return!1}}()?new qP(t):t}(n);let r=t?String(t):"";e=sg.getInertBodyElement(r);let s=5,o=r;do{if(0===s)throw new Error("Failed to sanitize html because the input is unstable");s--,r=o,o=e.innerHTML,e=sg.getInertBodyElement(r)}while(r!==o);return kd((new e2).sanitizeChildren(G_(e)||e))}finally{if(e){const r=G_(e)||e;for(;r.firstChild;)r.removeChild(r.firstChild)}}}function G_(n){return"content"in n&&function r2(n){return n.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===n.nodeName}(n)?n.content:null}var Qn=(()=>((Qn=Qn||{})[Qn.NONE=0]="NONE",Qn[Qn.HTML=1]="HTML",Qn[Qn.STYLE=2]="STYLE",Qn[Qn.SCRIPT=3]="SCRIPT",Qn[Qn.URL=4]="URL",Qn[Qn.RESOURCE_URL=5]="RESOURCE_URL",Qn))();class Ct{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=b({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}const Cp=new Ct("ENVIRONMENT_INITIALIZER"),VS=new Ct("INJECTOR",-1),US=new Ct("INJECTOR_DEF_TYPES");class zS{get(t,e=Ii){if(e===Ii){const r=new Error(`NullInjectorError: No provider for ${Jn(t)}!`);throw r.name="NullInjectorError",r}return e}}function d2(...n){return{\u0275providers:HS(0,n),\u0275fromNgModule:!0}}function HS(n,...t){const e=[],r=new Set;let s;return Cu(t,o=>{const i=o;X_(i,e,[],r)&&(s||=[],s.push(i))}),void 0!==s&&WS(s,e),e}function WS(n,t){for(let e=0;e<n.length;e++){const{providers:s}=n[e];q_(s,o=>{t.push(o)})}}function X_(n,t,e,r){if(!(n=an(n)))return!1;let s=null,o=dt(n);const i=!o&&jn(n);if(o||i){if(i&&!i.standalone)return!1;s=n}else{const l=n.ngModule;if(o=dt(l),!o)return!1;s=l}const a=r.has(s);if(i){if(a)return!1;if(r.add(s),i.dependencies){const l="function"==typeof i.dependencies?i.dependencies():i.dependencies;for(const c of l)X_(c,t,e,r)}}else{if(!o)return!1;{if(null!=o.imports&&!a){let c;r.add(s);try{Cu(o.imports,u=>{X_(u,t,e,r)&&(c||=[],c.push(u))})}finally{}void 0!==c&&WS(c,t)}if(!a){const c=zt(s)||(()=>new s);t.push({provide:s,useFactory:c,deps:zn},{provide:US,useValue:s,multi:!0},{provide:Cp,useValue:()=>Ke(s),multi:!0})}const l=o.providers;null==l||a||q_(l,u=>{t.push(u)})}}return s!==n&&void 0!==n.providers}function q_(n,t){for(let e of n)ri(e)&&(e=e.\u0275providers),Array.isArray(e)?q_(e,t):t(e)}const h2=on({provide:String,useValue:on});function Z_(n){return null!==n&&"object"==typeof n&&h2 in n}function Eu(n){return"function"==typeof n}const Y_=new Ct("Set Injector scope."),og={},f2={};let Q_;function ig(){return void 0===Q_&&(Q_=new zS),Q_}class kl{}class J_ extends kl{get destroyed(){return this._destroyed}constructor(t,e,r,s){super(),this.parent=e,this.source=r,this.scopes=s,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,tv(t,i=>this.processProvider(i)),this.records.set(VS,Md(void 0,this)),s.has("environment")&&this.records.set(kl,Md(void 0,this));const o=this.records.get(Y_);null!=o&&"string"==typeof o.value&&this.scopes.add(o.value),this.injectorDefTypes=new Set(this.get(US.multi,zn,Dt.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const e of this._ngOnDestroyHooks)e.ngOnDestroy();const t=this._onDestroyHooks;this._onDestroyHooks=[];for(const e of t)e()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear()}}onDestroy(t){return this.assertNotDestroyed(),this._onDestroyHooks.push(t),()=>this.removeOnDestroy(t)}runInContext(t){this.assertNotDestroyed();const e=Ai(this),r=Vn(void 0);try{return t()}finally{Ai(e),Vn(r)}}get(t,e=Ii,r=Dt.Default){if(this.assertNotDestroyed(),t.hasOwnProperty(ou))return t[ou](this);r=bl(r);const s=Ai(this),o=Vn(void 0);try{if(!(r&Dt.SkipSelf)){let a=this.records.get(t);if(void 0===a){const l=function _2(n){return"function"==typeof n||"object"==typeof n&&n instanceof Ct}(t)&&ne(t);a=l&&this.injectableDefInScope(l)?Md(ev(t),og):null,this.records.set(t,a)}if(null!=a)return this.hydrate(t,a)}return(r&Dt.Self?ig():this.parent).get(t,e=r&Dt.Optional&&e===Ii?null:e)}catch(i){if("NullInjectorError"===i.name){if((i[tc]=i[tc]||[]).unshift(Jn(t)),s)throw i;return function nd(n,t,e,r){const s=n[tc];throw t[nc]&&s.unshift(t[nc]),n.message=function rd(n,t,e,r=null){n=n&&"\n"===n.charAt(0)&&"\u0275"==n.charAt(1)?n.slice(2):n;let s=Jn(t);if(Array.isArray(t))s=t.map(Jn).join(" -> ");else if("object"==typeof t){let o=[];for(let i in t)if(t.hasOwnProperty(i)){let a=t[i];o.push(i+":"+("string"==typeof a?JSON.stringify(a):Jn(a)))}s=`{${o.join(", ")}}`}return`${e}${r?"("+r+")":""}[${s}]: ${n.replace($h,"\n  ")}`}("\n"+n.message,s,e,r),n.ngTokenPath=s,n[tc]=null,n}(i,t,"R3InjectorError",this.source)}throw i}finally{Vn(o),Ai(s)}}resolveInjectorInitializers(){const t=Ai(this),e=Vn(void 0);try{const r=this.get(Cp.multi,zn,Dt.Self);for(const s of r)s()}finally{Ai(t),Vn(e)}}toString(){const t=[],e=this.records;for(const r of e.keys())t.push(Jn(r));return`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new qe(205,!1)}processProvider(t){let e=Eu(t=an(t))?t:an(t&&t.provide);const r=function g2(n){return Z_(n)?Md(void 0,n.useValue):Md(KS(n),og)}(t);if(Eu(t)||!0!==t.multi)this.records.get(e);else{let s=this.records.get(e);s||(s=Md(void 0,og,!0),s.factory=()=>ru(s.multi),this.records.set(e,s)),e=t,s.multi.push(t)}this.records.set(e,r)}hydrate(t,e){return e.value===og&&(e.value=f2,e.value=e.factory()),"object"==typeof e.value&&e.value&&function b2(n){return null!==n&&"object"==typeof n&&"function"==typeof n.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(t){if(!t.providedIn)return!1;const e=an(t.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}removeOnDestroy(t){const e=this._onDestroyHooks.indexOf(t);-1!==e&&this._onDestroyHooks.splice(e,1)}}function ev(n){const t=ne(n),e=null!==t?t.factory:zt(n);if(null!==e)return e;if(n instanceof Ct)throw new qe(204,!1);if(n instanceof Function)return function m2(n){const t=n.length;if(t>0)throw w(t,"?"),new qe(204,!1);const e=function ht(n){return n&&(n[xt]||n[Gt])||null}(n);return null!==e?()=>e.factory(n):()=>new n}(n);throw new qe(204,!1)}function KS(n,t,e){let r;if(Eu(n)){const s=an(n);return zt(s)||ev(s)}if(Z_(n))r=()=>an(n.useValue);else if(function GS(n){return!(!n||!n.useFactory)}(n))r=()=>n.useFactory(...ru(n.deps||[]));else if(function jS(n){return!(!n||!n.useExisting)}(n))r=()=>Ke(an(n.useExisting));else{const s=an(n&&(n.useClass||n.provide));if(!function y2(n){return!!n.deps}(n))return zt(s)||ev(s);r=()=>new s(...ru(n.deps))}return r}function Md(n,t,e=!1){return{factory:n,value:t,multi:e?[]:void 0}}function tv(n,t){for(const e of n)Array.isArray(e)?tv(e,t):e&&ri(e)?tv(e.\u0275providers,t):t(e)}const wp=new Ct("AppId",{providedIn:"root",factory:()=>v2}),v2="ng",XS=new Ct("Platform Initializer"),Ml=new Ct("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),Rl=new Ct("AnimationModuleType"),nv=new Ct("CSP nonce",{providedIn:"root",factory:()=>function _p(){if(void 0!==z_)return z_;if(typeof document<"u")return document;throw new qe(210,!1)}().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});let ZS=(n,t)=>null;function YS(n,t){return ZS(n,t)}class A2{}class eE{}class k2{resolveComponentFactory(t){throw function N2(n){const t=Error(`No component factory found for ${Jn(n)}.`);return t.ngComponent=n,t}(t)}}let Rd=(()=>{class n{}return n.NULL=new k2,n})();function M2(){return Od(bs(),ft())}function Od(n,t){return new tr(ls(n,t))}let tr=(()=>{class n{constructor(e){this.nativeElement=e}}return n.__NG_ELEMENT_ID__=M2,n})();function R2(n){return n instanceof tr?n.nativeElement:n}class Tp{}let Ol=(()=>{class n{}return n.__NG_ELEMENT_ID__=()=>function O2(){const n=ft(),e=co(bs().index,n);return(Hs(e)?e:n)[yn]}(),n})(),F2=(()=>{class n{}return n.\u0275prov=b({token:n,providedIn:"root",factory:()=>null}),n})();class Du{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const P2=new Du("16.0.2"),pv={};function Ip(n){for(;n;){n[vn]|=64;const t=gp(n);if(aa(n)&&!t)return n;n=t}return null}function fv(n){return n.ngOriginalError}class Ka{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t);this._console.error("ERROR",t),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(t){let e=t&&fv(t);for(;e&&fv(e);)e=fv(e);return e||null}}const sE=new Ct("",{providedIn:"root",factory:()=>!1});function Fl(n){return n instanceof Function?n():n}class aE extends ca{constructor(){super(...arguments),this.consumerAllowSignalWrites=!1,this._lView=null}set lView(t){this._lView=t}onConsumerDependencyMayHaveChanged(){Ip(this._lView)}onProducerUpdateValueVersion(){}get hasReadASignal(){return this.hasProducers}runInContext(t,e,r){const s=Tr(this);this.trackingVersion++;try{t(e,r)}finally{Tr(s)}}destroy(){this.trackingVersion++}}let hg=null;function lE(){return hg??=new aE,hg}function cE(n,t){return n[t]??lE()}function uE(n,t){const e=lE();e.hasReadASignal&&(n[t]=hg,e.lView=n,hg=new aE)}const Dn={};function Tc(n){dE(Wn(),ft(),Ws()+n,!1)}function dE(n,t,e,r){if(!r)if(3==(3&t[vn])){const o=n.preOrderCheckHooks;null!==o&&yc(t,o,e)}else{const o=n.preOrderHooks;null!==o&&Cd(t,o,0,e)}Dl(e)}function mE(n,t=null,e=null,r){const s=gE(n,t,e,r);return s.resolveInjectorInitializers(),s}function gE(n,t=null,e=null,r,s=new Set){const o=[e||zn,d2(n)];return r=r||("object"==typeof n?void 0:Jn(n)),new J_(o,t||ig(),r||null,s)}let Gs=(()=>{class n{static create(e,r){if(Array.isArray(e))return mE({name:""},r,e,"");{const s=e.name??"";return mE({name:s},e.parent,e.providers,s)}}}return n.THROW_IF_NOT_FOUND=Ii,n.NULL=new zS,n.\u0275prov=b({token:n,providedIn:"any",factory:()=>Ke(VS)}),n.__NG_ELEMENT_ID__=-1,n})();function Ve(n,t=Dt.Default){const e=ft();return null===e?Ke(n,t):Bm(bs(),e,an(n),t)}function pg(){throw new Error("invalid")}function fg(n,t,e,r,s,o,i,a,l,c,u){const d=t.blueprint.slice();return d[Pr]=s,d[vn]=140|r,(null!==c||n&&2048&n[vn])&&(d[vn]|=2048),dm(d),d[fr]=d[Va]=n,d[Cr]=e,d[ia]=i||n&&n[ia],d[yn]=a||n&&n[yn],d[oa]=l||n&&n[oa]||null,d[ss]=o,d[wl]=function lP(){return aP++}(),d[Eo]=u,d[du]=c,d[Rr]=2==t.type?n[Rr]:d,d}function Pd(n,t,e,r,s){let o=n.data[t];if(null===o)o=function mv(n,t,e,r,s){const o=xm(),i=np(),l=n.data[t]=function r$(n,t,e,r,s,o){let i=t?t.injectorIndex:-1,a=0;return Wa()&&(a|=128),{type:e,index:r,insertBeforeIndex:null,injectorIndex:i,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:a,providerIndexes:0,value:s,attrs:o,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,i?o:o&&o.parent,e,t,r,s);return null===n.firstChild&&(n.firstChild=l),null!==o&&(i?null==o.child&&null!==l.parent&&(o.child=l):null===o.next&&(o.next=l,l.prev=o)),l}(n,t,e,r,s),function t_(){return fn.lFrame.inI18n}()&&(o.flags|=32);else if(64&o.type){o.type=e,o.value=r,o.attrs=s;const i=function bu(){const n=fn.lFrame,t=n.currentTNode;return n.isParent?t:t.parent}();o.injectorIndex=null===i?-1:i.injectorIndex}return Fi(o,!0),o}function Ap(n,t,e,r){if(0===e)return-1;const s=t.length;for(let o=0;o<e;o++)t.push(r),n.blueprint.push(r),n.data.push(null);return s}function yE(n,t,e,r,s){const o=cE(t,cc),i=Ws(),a=2&r;try{if(Dl(-1),a&&t.length>Pn&&dE(n,t,Pn,!1),Oi(a?2:0,s),a)o.runInContext(e,r,s);else{const c=Tr(null);try{e(r,s)}finally{Tr(c)}}}finally{a&&null===t[cc]&&uE(t,cc),Dl(i),Oi(a?3:1,s)}}function gv(n,t,e){if(hu(t)){const r=Tr(null);try{const o=t.directiveEnd;for(let i=t.directiveStart;i<o;i++){const a=n.data[i];a.contentQueries&&a.contentQueries(1,e[i],i)}}finally{Tr(r)}}}function yv(n,t,e){ym()&&(function u$(n,t,e,r){const s=e.directiveStart,o=e.directiveEnd;di(e)&&function y$(n,t,e){const r=ls(t,n),i=mg(n,fg(n,bE(e),null,e.onPush?64:16,r,t,null,n[ia].rendererFactory.createRenderer(r,e),null,null,null));n[t.index]=i}(t,e,n.data[s+e.componentOffset]),n.firstCreatePass||Dd(e,t),ho(r,t);const i=e.initialInputs;for(let a=s;a<o;a++){const l=n.data[a],c=Il(t,n,a,e);ho(c,t),null!==i&&b$(0,a-s,c,l,0,i),Do(l)&&(co(e.index,t)[Cr]=Il(t,n,a,e))}}(n,t,e,ls(e,t)),64==(64&e.flags)&&wE(n,t,e))}function bv(n,t,e=ls){const r=t.localNames;if(null!==r){let s=t.index+1;for(let o=0;o<r.length;o+=2){const i=r[o+1],a=-1===i?e(t,n):n[i];n[s++]=a}}}function bE(n){const t=n.tView;return null===t||t.incompleteFirstPass?n.tView=_v(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts,n.id):t}function _v(n,t,e,r,s,o,i,a,l,c,u){const d=Pn+r,p=d+s,m=function Y2(n,t){const e=[];for(let r=0;r<t;r++)e.push(r<n?null:Dn);return e}(d,p),y="function"==typeof c?c():c;return m[Bt]={type:n,blueprint:m,template:e,queries:null,viewQuery:a,declTNode:t,data:m.slice().fill(null,d),bindingStartIndex:d,expandoStartIndex:p,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof o?o():o,pipeRegistry:"function"==typeof i?i():i,firstChild:null,schemas:l,consts:y,incompleteFirstPass:!1,ssrId:u}}let _E=n=>null;function vE(n,t,e,r){for(let s in n)if(n.hasOwnProperty(s)){e=null===e?{}:e;const o=n[s];null===r?xE(e,t,s,o):r.hasOwnProperty(s)&&xE(e,t,r[s],o)}return e}function xE(n,t,e,r){n.hasOwnProperty(e)?n[e].push(t,r):n[e]=[t,r]}function pi(n,t,e,r,s,o,i,a){const l=ls(t,e);let u,c=t.inputs;!a&&null!=c&&(u=c[r])?(Sv(n,e,u,r,s),di(t)&&function i$(n,t){const e=co(t,n);16&e[vn]||(e[vn]|=64)}(e,t.index)):3&t.type&&(r=function o$(n){return"class"===n?"className":"for"===n?"htmlFor":"formaction"===n?"formAction":"innerHtml"===n?"innerHTML":"readonly"===n?"readOnly":"tabindex"===n?"tabIndex":n}(r),s=null!=i?i(s,t.value||"",r):s,o.setProperty(l,r,s))}function vv(n,t,e,r){if(ym()){const s=null===r?null:{"":-1},o=function h$(n,t){const e=n.directiveRegistry;let r=null,s=null;if(e)for(let o=0;o<e.length;o++){const i=e[o];if($a(t,i.selectors,!1))if(r||(r=[]),Do(i))if(null!==i.findHostDirectiveDefs){const a=[];s=s||new Map,i.findHostDirectiveDefs(i,a,s),r.unshift(...a,i),xv(n,t,a.length)}else r.unshift(i),xv(n,t,0);else s=s||new Map,i.findHostDirectiveDefs?.(i,r,s),r.push(i)}return null===r?null:[r,s]}(n,e);let i,a;null===o?i=a=null:[i,a]=o,null!==i&&CE(n,t,e,i,s,a),s&&function p$(n,t,e){if(t){const r=n.localNames=[];for(let s=0;s<t.length;s+=2){const o=e[t[s+1]];if(null==o)throw new qe(-301,!1);r.push(t[s],o)}}}(e,r,s)}e.mergedAttrs=ra(e.mergedAttrs,e.attrs)}function CE(n,t,e,r,s,o){for(let c=0;c<r.length;c++)hp(Dd(e,t),n,r[c].type);!function m$(n,t,e){n.flags|=1,n.directiveStart=t,n.directiveEnd=t+e,n.providerIndexes=t}(e,n.data.length,r.length);for(let c=0;c<r.length;c++){const u=r[c];u.providersResolver&&u.providersResolver(u)}let i=!1,a=!1,l=Ap(n,t,r.length,null);for(let c=0;c<r.length;c++){const u=r[c];e.mergedAttrs=ra(e.mergedAttrs,u.hostAttrs),g$(n,e,t,l,u),f$(l,u,s),null!==u.contentQueries&&(e.flags|=4),(null!==u.hostBindings||null!==u.hostAttrs||0!==u.hostVars)&&(e.flags|=64);const d=u.type.prototype;!i&&(d.ngOnChanges||d.ngOnInit||d.ngDoCheck)&&((n.preOrderHooks??=[]).push(e.index),i=!0),!a&&(d.ngOnChanges||d.ngDoCheck)&&((n.preOrderCheckHooks??=[]).push(e.index),a=!0),l++}!function s$(n,t,e){const s=t.directiveEnd,o=n.data,i=t.attrs,a=[];let l=null,c=null;for(let u=t.directiveStart;u<s;u++){const d=o[u],p=e?e.get(d):null,y=p?p.outputs:null;l=vE(d.inputs,u,l,p?p.inputs:null),c=vE(d.outputs,u,c,y);const _=null===l||null===i||id(t)?null:_$(l,u,i);a.push(_)}null!==l&&(l.hasOwnProperty("class")&&(t.flags|=8),l.hasOwnProperty("style")&&(t.flags|=16)),t.initialInputs=a,t.inputs=l,t.outputs=c}(n,e,o)}function wE(n,t,e){const r=e.directiveStart,s=e.directiveEnd,o=e.index,i=function r_(){return fn.lFrame.currentDirectiveIndex}();try{Dl(o);for(let a=r;a<s;a++){const l=n.data[a],c=t[a];op(a),(null!==l.hostBindings||0!==l.hostVars||null!==l.hostAttrs)&&d$(l,c)}}finally{Dl(-1),op(i)}}function d$(n,t){null!==n.hostBindings&&n.hostBindings(1,t)}function xv(n,t,e){t.componentOffset=e,(n.components??=[]).push(t.index)}function f$(n,t,e){if(e){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)e[t.exportAs[r]]=n;Do(t)&&(e[""]=n)}}function g$(n,t,e,r,s){n.data[r]=s;const o=s.factory||(s.factory=zt(s.type)),i=new Tl(o,Do(s),Ve);n.blueprint[r]=i,e[r]=i,function l$(n,t,e,r,s){const o=s.hostBindings;if(o){let i=n.hostBindingOpCodes;null===i&&(i=n.hostBindingOpCodes=[]);const a=~t.index;(function c$(n){let t=n.length;for(;t>0;){const e=n[--t];if("number"==typeof e&&e<0)return e}return 0})(i)!=a&&i.push(a),i.push(e,r,o)}}(n,t,r,Ap(n,e,s.hostVars,Dn),s)}function Xa(n,t,e,r,s,o){const i=ls(n,t);!function Cv(n,t,e,r,s,o,i){if(null==o)n.removeAttribute(t,s,e);else{const a=null==i?un(o):i(o,r||"",s);n.setAttribute(t,s,a,e)}}(t[yn],i,o,n.value,e,r,s)}function b$(n,t,e,r,s,o){const i=o[t];if(null!==i)for(let a=0;a<i.length;)SE(r,e,i[a++],i[a++],i[a++])}function SE(n,t,e,r,s){const o=Tr(null);try{null!==n.setInput?n.setInput(t,s,e,r):t[r]=s}finally{Tr(o)}}function _$(n,t,e){let r=null,s=0;for(;s<e.length;){const o=e[s];if(0!==o)if(5!==o){if("number"==typeof o)break;if(n.hasOwnProperty(o)){null===r&&(r=[]);const i=n[o];for(let a=0;a<i.length;a+=2)if(i[a]===t){r.push(o,i[a+1],e[s+1]);break}}s+=2}else s+=2;else s+=4}return r}function EE(n,t,e,r){return[n,!0,!1,t,null,0,r,e,null,null,null]}function DE(n,t){const e=n.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const o=e[r+1];if(-1!==o){const i=n.data[o];ap(e[r]),i.contentQueries(2,t[o],o)}}}function mg(n,t){return n[xl]?n[ud][so]=t:n[xl]=t,n[ud]=t,t}function wv(n,t,e){ap(0);const r=Tr(null);try{t(n,e)}finally{Tr(r)}}function TE(n){return n[Ba]||(n[Ba]=[])}function IE(n){return n.cleanup||(n.cleanup=[])}function AE(n,t,e){return(null===n||Do(n))&&(e=function yu(n){for(;Array.isArray(n);){if("object"==typeof n[Sl])return n;n=n[Pr]}return null}(e[t.index])),e[yn]}function NE(n,t){const e=n[oa],r=e?e.get(Ka,null):null;r&&r.handleError(t)}function Sv(n,t,e,r,s){for(let o=0;o<e.length;){const i=e[o++],a=e[o++];SE(n.data[i],t[i],r,a,s)}}function v$(n,t){const e=co(t,n),r=e[Bt];!function x$(n,t){for(let e=t.length;e<n.blueprint.length;e++)t.push(n.blueprint[e])}(r,e);const s=e[Pr];null!==s&&null===e[Eo]&&(e[Eo]=YS(s,e[oa])),Ev(r,e,e[Cr])}function Ev(n,t,e){lp(t);try{const r=n.viewQuery;null!==r&&wv(1,r,e);const s=n.template;null!==s&&yE(n,t,s,1,e),n.firstCreatePass&&(n.firstCreatePass=!1),n.staticContentQueries&&DE(n,t),n.staticViewQueries&&wv(2,n.viewQuery,e);const o=n.components;null!==o&&function C$(n,t){for(let e=0;e<t.length;e++)v$(n,t[e])}(t,o)}catch(r){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),r}finally{t[vn]&=-5,_d()}}let kE=(()=>{class n{constructor(){this.all=new Set,this.queue=new Map}create(e,r,s){const o=typeof Zone>"u"?null:Zone.current,i=new mu(e,c=>{this.all.has(c)&&this.queue.set(c,o)},s);let a;this.all.add(i),i.notify();const l=()=>{i.cleanup(),a?.(),this.all.delete(i),this.queue.delete(i)};return a=r?.onDestroy(l),{destroy:l}}flush(){if(0!==this.queue.size)for(const[e,r]of this.queue)this.queue.delete(e),r?r.run(()=>e.run()):e.run()}get isQueueEmpty(){return 0===this.queue.size}}return n.\u0275prov=b({token:n,providedIn:"root",factory:()=>new n}),n})();function gg(n,t,e){let r=e?n.styles:null,s=e?n.classes:null,o=0;if(null!==t)for(let i=0;i<t.length;i++){const a=t[i];"number"==typeof a?o=a:1==o?s=Ji(s,a):2==o&&(r=Ji(r,a+": "+t[++i]+";"))}e?n.styles=r:n.stylesWithoutHost=r,e?n.classes=s:n.classesWithoutHost=s}function Np(n,t,e,r,s=!1){for(;null!==e;){const o=t[e.index];if(null!==o&&r.push(or(o)),ks(o)){for(let a=Kr;a<o.length;a++){const l=o[a],c=l[Bt].firstChild;null!==c&&Np(l[Bt],l,c,r)}o[zo]!==o[Pr]&&r.push(o[zo])}const i=e.type;if(8&i)Np(n,t,e.child,r);else if(32&i){const a=k_(e,t);let l;for(;l=a();)r.push(l)}else if(16&i){const a=CS(t,e);if(Array.isArray(a))r.push(...a);else{const l=gp(t[Rr]);Np(l[Bt],l,a,r,!0)}}e=s?e.projectionNext:e.next}return r}function yg(n,t,e,r=!0){const s=t[ia].rendererFactory;s.begin&&s.begin();try{bg(n,t,n.template,e)}catch(i){throw r&&NE(t,i),i}finally{s.end&&s.end(),t[ia].effectManager?.flush()}}function bg(n,t,e,r){const s=t[vn];if(256!=(256&s)){t[ia].effectManager?.flush(),lp(t);try{dm(t),function bd(n){return fn.lFrame.bindingIndex=n}(n.bindingStartIndex),null!==e&&yE(n,t,e,2,r);const i=3==(3&s);if(i){const c=n.preOrderCheckHooks;null!==c&&yc(t,c,null)}else{const c=n.preOrderHooks;null!==c&&Cd(t,c,0,null),_u(t,0)}if(function I$(n){for(let t=M_(n);null!==t;t=R_(t)){if(!t[dd])continue;const e=t[za];for(let r=0;r<e.length;r++){Kb(e[r])}}}(t),function T$(n){for(let t=M_(n);null!==t;t=R_(t))for(let e=Kr;e<t.length;e++){const r=t[e],s=r[Bt];yd(r)&&bg(s,r,s.template,r[Cr])}}(t),null!==n.contentQueries&&DE(n,t),i){const c=n.contentCheckHooks;null!==c&&yc(t,c)}else{const c=n.contentHooks;null!==c&&Cd(t,c,1),_u(t,1)}!function Z2(n,t){const e=n.hostBindingOpCodes;if(null===e)return;const r=cE(t,uc);try{for(let s=0;s<e.length;s++){const o=e[s];if(o<0)Dl(~o);else{const i=o,a=e[++s],l=e[++s];n_(a,i),r.runInContext(l,2,t[i])}}}finally{null===t[uc]&&uE(t,uc),Dl(-1)}}(n,t);const a=n.components;null!==a&&function N$(n,t){for(let e=0;e<t.length;e++)A$(n,t[e])}(t,a);const l=n.viewQuery;if(null!==l&&wv(2,l,r),i){const c=n.viewCheckHooks;null!==c&&yc(t,c)}else{const c=n.viewHooks;null!==c&&Cd(t,c,2),_u(t,2)}!0===n.firstUpdatePass&&(n.firstUpdatePass=!1),t[vn]&=-73,hm(t)}finally{_d()}}}function A$(n,t){const e=co(t,n);if(yd(e)){const r=e[Bt];80&e[vn]?bg(r,e,r.template,e[Cr]):e[sa]>0&&Dv(e)}}function Dv(n){for(let r=M_(n);null!==r;r=R_(r))for(let s=Kr;s<r.length;s++){const o=r[s];if(yd(o))if(1024&o[vn]){const i=o[Bt];bg(i,o,i.template,o[Cr])}else o[sa]>0&&Dv(o)}const e=n[Bt].components;if(null!==e)for(let r=0;r<e.length;r++){const s=co(e[r],n);yd(s)&&s[sa]>0&&Dv(s)}}class kp{get rootNodes(){const t=this._lView,e=t[Bt];return Np(e,t,e.firstChild,[])}constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[Cr]}set context(t){this._lView[Cr]=t}get destroyed(){return 256==(256&this._lView[vn])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[fr];if(ks(t)){const e=t[dc],r=e?e.indexOf(this):-1;r>-1&&(F_(t,r),T(e,r))}this._attachedToViewContainer=!1}fS(this._lView[Bt],this._lView)}onDestroy(t){!function fm(n,t){if(256==(256&n[vn]))throw new qe(911,!1);null===n[So]&&(n[So]=[]),n[So].push(t)}(this._lView,t)}markForCheck(){Ip(this._cdRefInjectingView||this._lView)}detach(){this._lView[vn]&=-129}reattach(){this._lView[vn]|=128}detectChanges(){yg(this._lView[Bt],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new qe(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function CP(n,t){bp(n,t,t[yn],2,null,null)}(this._lView[Bt],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new qe(902,!1);this._appRef=t}}class k$ extends kp{constructor(t){super(t),this._view=t}detectChanges(){const t=this._view;yg(t[Bt],t,t[Cr],!1)}checkNoChanges(){}get context(){return null}}class ME extends Rd{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=jn(t);return new Mp(e,this.ngModule)}}function RE(n){const t=[];for(let e in n)n.hasOwnProperty(e)&&t.push({propName:n[e],templateName:e});return t}class R${constructor(t,e){this.injector=t,this.parentInjector=e}get(t,e,r){r=bl(r);const s=this.injector.get(t,pv,r);return s!==pv||e===pv?s:this.parentInjector.get(t,e,r)}}class Mp extends eE{get inputs(){return RE(this.componentDef.inputs)}get outputs(){return RE(this.componentDef.outputs)}constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=function Uh(n){return n.map(De).join(",")}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}create(t,e,r,s){let o=(s=s||this.ngModule)instanceof kl?s:s?.injector;o&&null!==this.componentDef.getStandaloneInjector&&(o=this.componentDef.getStandaloneInjector(o)||o);const i=o?new R$(t,o):t,a=i.get(Tp,null);if(null===a)throw new qe(407,!1);const u={rendererFactory:a,sanitizer:i.get(F2,null),effectManager:i.get(kE,null)},d=a.createRenderer(null,this.componentDef),p=this.componentDef.selectors[0][0]||"div",m=r?function Q2(n,t,e,r){const o=r.get(sE,!1)||e===gs.ShadowDom,i=n.selectRootElement(t,o);return function J2(n){_E(n)}(i),i}(d,r,this.componentDef.encapsulation,i):Ym(d,p,function M$(n){const t=n.toLowerCase();return"svg"===t?"svg":"math"===t?"math":null}(p)),y=this.componentDef.onPush?576:528,_=_v(0,null,null,1,0,null,null,null,null,null,null),C=fg(null,_,null,y,null,null,u,d,i,null,null);let D,N;lp(C);try{const W=this.componentDef;let j,te=null;W.findHostDirectiveDefs?(j=[],te=new Map,W.findHostDirectiveDefs(W,j,te),j.push(W)):j=[W];const _e=function F$(n,t){const e=n[Bt],r=Pn;return n[r]=t,Pd(e,r,2,"#host",null)}(C,m),Ee=function P$(n,t,e,r,s,o,i){const a=s[Bt];!function $$(n,t,e,r){for(const s of n)t.mergedAttrs=ra(t.mergedAttrs,s.hostAttrs);null!==t.mergedAttrs&&(gg(t,t.mergedAttrs,!0),null!==e&&DS(r,e,t))}(r,n,t,i);let l=null;null!==t&&(l=YS(t,s[oa]));const c=o.rendererFactory.createRenderer(t,e),u=fg(s,bE(e),null,e.onPush?64:16,s[n.index],n,o,c,null,null,l);return a.firstCreatePass&&xv(a,n,r.length-1),mg(s,u),s[n.index]=u}(_e,m,W,j,C,u,d);N=cm(_,Pn),m&&function B$(n,t,e,r){if(r)iu(n,e,["ng-version",P2.full]);else{const{attrs:s,classes:o}=function zh(n){const t=[],e=[];let r=1,s=2;for(;r<n.length;){let o=n[r];if("string"==typeof o)2===s?""!==o&&t.push(o,n[++r]):8===s&&e.push(o);else{if(!ns(s))break;s=o}r++}return{attrs:t,classes:e}}(t.selectors[0]);s&&iu(n,e,s),o&&o.length>0&&ES(n,e,o.join(" "))}}(d,W,m,r),void 0!==e&&function V$(n,t,e){const r=n.projection=[];for(let s=0;s<t.length;s++){const o=e[s];r.push(null!=o?Array.from(o):null)}}(N,this.ngContentSelectors,e),D=function L$(n,t,e,r,s,o){const i=bs(),a=s[Bt],l=ls(i,s);CE(a,s,i,e,null,r);for(let u=0;u<e.length;u++)ho(Il(s,a,i.directiveStart+u,i),s);wE(a,s,i),l&&ho(l,s);const c=Il(s,a,i.directiveStart+i.componentOffset,i);if(n[Cr]=s[Cr]=c,null!==o)for(const u of o)u(c,t);return gv(a,i,n),c}(Ee,W,j,te,C,[U$]),Ev(_,C,null)}finally{_d()}return new O$(this.componentType,D,Od(N,C),C,N)}}class O$ extends A2{constructor(t,e,r,s,o){super(),this.location=r,this._rootLView=s,this._tNode=o,this.previousInputValues=null,this.instance=e,this.hostView=this.changeDetectorRef=new k$(s),this.componentType=t}setInput(t,e){const r=this._tNode.inputs;let s;if(null!==r&&(s=r[t])){if(this.previousInputValues??=new Map,this.previousInputValues.has(t)&&Object.is(this.previousInputValues.get(t),e))return;const o=this._rootLView;Sv(o[Bt],o,s,t,e),this.previousInputValues.set(t,e),Ip(co(this._tNode.index,o))}}get injector(){return new _c(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}function U$(){const n=bs();xd(ft()[Bt],n)}function $n(n){let t=function OE(n){return Object.getPrototypeOf(n.prototype).constructor}(n.type),e=!0;const r=[n];for(;t;){let s;if(Do(n))s=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new qe(903,!1);s=t.\u0275dir}if(s){if(e){r.push(s);const i=n;i.inputs=Tv(n.inputs),i.declaredInputs=Tv(n.declaredInputs),i.outputs=Tv(n.outputs);const a=s.hostBindings;a&&j$(n,a);const l=s.viewQuery,c=s.contentQueries;if(l&&H$(n,l),c&&W$(n,c),Na(n.inputs,s.inputs),Na(n.declaredInputs,s.declaredInputs),Na(n.outputs,s.outputs),Do(s)&&s.data.animation){const u=n.data;u.animation=(u.animation||[]).concat(s.data.animation)}}const o=s.features;if(o)for(let i=0;i<o.length;i++){const a=o[i];a&&a.ngInherit&&a(n),a===$n&&(e=!1)}}t=Object.getPrototypeOf(t)}!function z$(n){let t=0,e=null;for(let r=n.length-1;r>=0;r--){const s=n[r];s.hostVars=t+=s.hostVars,s.hostAttrs=ra(s.hostAttrs,e=ra(e,s.hostAttrs))}}(r)}function Tv(n){return n===zs?{}:n===zn?[]:n}function H$(n,t){const e=n.viewQuery;n.viewQuery=e?(r,s)=>{t(r,s),e(r,s)}:t}function W$(n,t){const e=n.contentQueries;n.contentQueries=e?(r,s,o)=>{t(r,s,o),e(r,s,o)}:t}function j$(n,t){const e=n.hostBindings;n.hostBindings=e?(r,s)=>{t(r,s),e(r,s)}:t}function _g(n){return!!Iv(n)&&(Array.isArray(n)||!(n instanceof Map)&&Symbol.iterator in n)}function Iv(n){return null!==n&&("function"==typeof n||"object"==typeof n)}function po(n,t,e){return!Object.is(n[t],e)&&(n[t]=e,!0)}function Ks(n,t,e,r){const s=ft();return po(s,gc(),t)&&(Wn(),Xa(Ir(),s,n,t,e,r)),Ks}function Sg(n,t,e,r,s,o,i,a){const l=ft(),c=Wn(),u=n+Pn,d=c.firstCreatePass?function gL(n,t,e,r,s,o,i,a,l){const c=t.consts,u=Pd(t,n,4,i||null,Ha(c,a));vv(t,e,u,Ha(c,l)),xd(t,u);const d=u.tView=_v(2,u,r,s,o,t.directiveRegistry,t.pipeRegistry,null,t.schemas,c,null);return null!==t.queries&&(t.queries.template(t,u),d.queries=t.queries.embeddedTView(u)),u}(u,c,l,t,e,r,s,o,i):c.data[u];Fi(d,!1);const p=ZE(c,l,d,n);vd()&&Jm(c,l,p,d),ho(p,l),mg(l,l[u]=EE(p,l,p,d)),hc(d)&&yv(c,l,d),null!=i&&bv(l,d,a)}let ZE=function YE(n,t,e,r){return Ao(!0),t[yn].createComment("")};function pa(n,t,e){const r=ft();return po(r,gc(),t)&&pi(Wn(),Ir(),r,n,t,r[yn],e,!1),pa}function Ov(n,t,e,r,s){const i=s?"class":"style";Sv(n,e,t.inputs[i],i,r)}function Nr(n,t,e,r){const s=ft(),o=Wn(),i=Pn+n,a=s[yn],l=o.firstCreatePass?function vL(n,t,e,r,s,o){const i=t.consts,l=Pd(t,n,2,r,Ha(i,s));return vv(t,e,l,Ha(i,o)),null!==l.attrs&&gg(l,l.attrs,!1),null!==l.mergedAttrs&&gg(l,l.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,l),l}(i,o,s,t,e,r):o.data[i],c=JE(o,s,l,a,t,n);s[i]=c;const u=hc(l);return Fi(l,!0),DS(a,c,l),32!=(32&l.flags)&&vd()&&Jm(o,s,c,l),0===function qb(){return fn.lFrame.elementDepthCount}()&&ho(c,s),function Zb(){fn.lFrame.elementDepthCount++}(),u&&(yv(o,s,l),gv(o,l,s)),null!==r&&bv(s,l),Nr}function Cs(){let n=bs();np()?rp():(n=n.parent,Fi(n,!1));const t=n;(function bm(n){return fn.skipHydrationRootTNode===n})(t)&&function tp(){fn.skipHydrationRootTNode=null}(),function Yb(){fn.lFrame.elementDepthCount--}();const e=Wn();return e.firstCreatePass&&(xd(e,n),hu(n)&&e.queries.elementEnd(n)),null!=t.classesWithoutHost&&function up(n){return 0!=(8&n.flags)}(t)&&Ov(e,t,ft(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function p_(n){return 0!=(16&n.flags)}(t)&&Ov(e,t,ft(),t.stylesWithoutHost,!1),Cs}function Za(n,t,e,r){return Nr(n,t,e,r),Cs(),Za}let JE=(n,t,e,r,s,o)=>(Ao(!0),Ym(r,s,function Am(){return fn.lFrame.currentNamespace}()));function $p(n){return!!n&&"function"==typeof n.then}function rD(n){return!!n&&"function"==typeof n.subscribe}function Zr(n,t,e,r){const s=ft(),o=Wn(),i=bs();return sD(o,s,s[yn],i,n,t,r),Zr}function $v(n,t){const e=bs(),r=ft(),s=Wn();return sD(s,r,AE(ip(s.data),e,r),e,n,t),$v}function sD(n,t,e,r,s,o,i){const a=hc(r),c=n.firstCreatePass&&IE(n),u=t[Cr],d=TE(t);let p=!0;if(3&r.type||i){const _=ls(r,t),C=i?i(_):_,D=d.length,N=i?j=>i(or(j[r.index])):r.index;let W=null;if(!i&&a&&(W=function DL(n,t,e,r){const s=n.cleanup;if(null!=s)for(let o=0;o<s.length-1;o+=2){const i=s[o];if(i===e&&s[o+1]===r){const a=t[Ba],l=s[o+2];return a.length>l?a[l]:null}"string"==typeof i&&(o+=2)}return null}(n,t,s,r.index)),null!==W)(W.__ngLastListenerFn__||W).__ngNextListenerFn__=o,W.__ngLastListenerFn__=o,p=!1;else{o=iD(r,t,u,o,!1);const j=e.listen(C,s,o);d.push(o,j),c&&c.push(s,N,D,D+1)}}else o=iD(r,t,u,o,!1);const m=r.outputs;let y;if(p&&null!==m&&(y=m[s])){const _=y.length;if(_)for(let C=0;C<_;C+=2){const te=t[y[C]][y[C+1]].subscribe(o),_e=d.length;d.push(o,te),c&&c.push(s,r.index,_e,-(_e+1))}}}function oD(n,t,e,r){try{return Oi(6,t,e),!1!==e(r)}catch(s){return NE(n,s),!1}finally{Oi(7,t,e)}}function iD(n,t,e,r,s){return function o(i){if(i===Function)return r;Ip(n.componentOffset>-1?co(n.index,t):t);let l=oD(t,e,r,i),c=o.__ngNextListenerFn__;for(;c;)l=oD(t,e,c,i)&&l,c=c.__ngNextListenerFn__;return s&&!1===l&&i.preventDefault(),l}}function Lv(n=1){return function o_(n){return(fn.lFrame.contextLView=function Im(n,t){for(;n>0;)t=t[Va],n--;return t}(n,fn.lFrame.contextLView))[Cr]}(n)}function TL(n,t){let e=null;const r=function Vh(n){const t=n.attrs;if(null!=t){const e=t.indexOf(5);if(!(1&e))return t[e+1]}return null}(n);for(let s=0;s<t.length;s++){const o=t[s];if("*"!==o){if(null===r?$a(n,o,!0):ad(r,o))return s}else e=s}return e}function fa(n){const t=ft()[Rr][ss];if(!t.projection){const r=t.projection=w(n?n.length:1,null),s=r.slice();let o=t.child;for(;null!==o;){const i=n?TL(o,n):0;null!==i&&(s[i]?s[i].projectionNext=o:r[i]=o,s[i]=o),o=o.next}}}function Ms(n,t=0,e){const r=ft(),s=Wn(),o=Pd(s,Pn+n,16,null,e||null);null===o.projection&&(o.projection=t),rp(),(!r[Eo]||Wa())&&32!=(32&o.flags)&&function NP(n,t,e){SS(t[yn],0,t,e,$_(n,e,t),bS(e.parent||t[ss],e,t))}(s,r,o)}function Eg(n,t){return n<<17|t<<2}function Ic(n){return n>>17&32767}function Vv(n){return 2|n}function Iu(n){return(131068&n)>>2}function Uv(n,t){return-131069&n|t<<2}function zv(n){return 1|n}function gD(n,t,e,r,s){const o=n[e+1],i=null===t;let a=r?Ic(o):Iu(o),l=!1;for(;0!==a&&(!1===l||i);){const u=n[a+1];RL(n[a],t)&&(l=!0,n[a+1]=r?zv(u):Vv(u)),a=r?Ic(u):Iu(u)}l&&(n[e+1]=r?Vv(o):zv(o))}function RL(n,t){return null===n||null==t||(Array.isArray(n)?n[1]:n)===t||!(!Array.isArray(n)||"string"!=typeof t)&&le(n,t)>=0}function Dg(n,t,e){return ma(n,t,e,!1),Dg}function fo(n,t){return ma(n,t,null,!0),fo}function ma(n,t,e,r){const s=ft(),o=Wn(),i=function da(n){const t=fn.lFrame,e=t.bindingIndex;return t.bindingIndex=t.bindingIndex+n,e}(2);o.firstUpdatePass&&function SD(n,t,e,r){const s=n.data;if(null===s[e+1]){const o=s[Ws()],i=function wD(n,t){return t>=n.expandoStartIndex}(n,e);(function ID(n,t){return 0!=(n.flags&(t?8:16))})(o,r)&&null===t&&!i&&(t=!1),t=function zL(n,t,e,r){const s=ip(n);let o=r?t.residualClasses:t.residualStyles;if(null===s)0===(r?t.classBindings:t.styleBindings)&&(e=Lp(e=Hv(null,n,t,e,r),t.attrs,r),o=null);else{const i=t.directiveStylingLast;if(-1===i||n[i]!==s)if(e=Hv(s,n,t,e,r),null===o){let l=function HL(n,t,e){const r=e?t.classBindings:t.styleBindings;if(0!==Iu(r))return n[Ic(r)]}(n,t,r);void 0!==l&&Array.isArray(l)&&(l=Hv(null,n,t,l[1],r),l=Lp(l,t.attrs,r),function WL(n,t,e,r){n[Ic(e?t.classBindings:t.styleBindings)]=r}(n,t,r,l))}else o=function jL(n,t,e){let r;const s=t.directiveEnd;for(let o=1+t.directiveStylingLast;o<s;o++)r=Lp(r,n[o].hostAttrs,e);return Lp(r,t.attrs,e)}(n,t,r)}return void 0!==o&&(r?t.residualClasses=o:t.residualStyles=o),e}(s,o,t,r),function kL(n,t,e,r,s,o){let i=o?t.classBindings:t.styleBindings,a=Ic(i),l=Iu(i);n[r]=e;let u,c=!1;if(Array.isArray(e)?(u=e[1],(null===u||le(e,u)>0)&&(c=!0)):u=e,s)if(0!==l){const p=Ic(n[a+1]);n[r+1]=Eg(p,a),0!==p&&(n[p+1]=Uv(n[p+1],r)),n[a+1]=function AL(n,t){return 131071&n|t<<17}(n[a+1],r)}else n[r+1]=Eg(a,0),0!==a&&(n[a+1]=Uv(n[a+1],r)),a=r;else n[r+1]=Eg(l,0),0===a?a=r:n[l+1]=Uv(n[l+1],r),l=r;c&&(n[r+1]=Vv(n[r+1])),gD(n,u,r,!0),gD(n,u,r,!1),function ML(n,t,e,r,s){const o=s?n.residualClasses:n.residualStyles;null!=o&&"string"==typeof t&&le(o,t)>=0&&(e[r+1]=zv(e[r+1]))}(t,u,n,r,o),i=Eg(a,l),o?t.classBindings=i:t.styleBindings=i}(s,o,t,e,i,r)}}(o,n,i,r),t!==Dn&&po(s,i,t)&&function DD(n,t,e,r,s,o,i,a){if(!(3&t.type))return;const l=n.data,c=l[a+1],u=function NL(n){return 1==(1&n)}(c)?TD(l,t,e,s,Iu(c),i):void 0;Tg(u)||(Tg(o)||function IL(n){return 2==(2&n)}(c)&&(o=TD(l,null,e,s,a,i)),function MP(n,t,e,r,s){if(t)s?n.addClass(e,r):n.removeClass(e,r);else{let o=-1===r.indexOf("-")?void 0:jo.DashCase;null==s?n.removeStyle(e,r,o):("string"==typeof s&&s.endsWith("!important")&&(s=s.slice(0,-10),o|=jo.Important),n.setStyle(e,r,s,o))}}(r,i,lo(Ws(),e),s,o))}(o,o.data[Ws()],s,s[yn],n,s[i+1]=function qL(n,t){return null==n||""===n||("string"==typeof t?n+=t:"object"==typeof n&&(n=Jn(hi(n)))),n}(t,e),r,i)}function Hv(n,t,e,r,s){let o=null;const i=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<i&&(o=t[a],r=Lp(r,o.hostAttrs,s),o!==n);)a++;return null!==n&&(e.directiveStylingLast=a),r}function Lp(n,t,e){const r=e?1:2;let s=-1;if(null!==t)for(let o=0;o<t.length;o++){const i=t[o];"number"==typeof i?s=i:s===r&&(Array.isArray(n)||(n=void 0===n?[]:["",n]),K(n,i,!!e||t[++o]))}return void 0===n?null:n}function TD(n,t,e,r,s,o){const i=null===t;let a;for(;s>0;){const l=n[s],c=Array.isArray(l),u=c?l[1]:l,d=null===u;let p=e[s+1];p===Dn&&(p=d?zn:void 0);let m=d?Y(p,r):u===r?p:void 0;if(c&&!Tg(m)&&(m=Y(l,r)),Tg(m)&&(a=m,i))return a;const y=n[s+1];s=i?Ic(y):Iu(y)}if(null!==t){let l=o?t.residualClasses:t.residualStyles;null!=l&&(a=Y(l,r))}return a}function Tg(n){return void 0!==n}function $l(n,t=""){const e=ft(),r=Wn(),s=n+Pn,o=r.firstCreatePass?Pd(r,s,1,t,null):r.data[s],i=AD(r,e,o,t,n);e[s]=i,vd()&&Jm(r,e,i,o),Fi(o,!1)}let AD=(n,t,e,r,s)=>(Ao(!0),function Zm(n,t){return n.createText(t)}(t[yn],r));function Wv(n){return jv("",n,""),Wv}function jv(n,t,e){const r=ft(),s=function Ld(n,t,e,r){return po(n,gc(),e)?t+un(e)+r:Dn}(r,n,t,e);return s!==Dn&&function Pl(n,t,e){const r=lo(t,n);!function hS(n,t,e){n.setValue(t,e)}(n[yn],r,e)}(r,Ws(),s),jv}function Gv(n,t,e){const r=ft();if(po(r,gc(),t)){const o=Wn(),i=Ir();pi(o,i,r,n,t,AE(ip(o.data),i,r),e,!0)}return Gv}const Xd="en-US";let ZD=Xd;function qv(n,t,e,r,s){if(n=an(n),Array.isArray(n))for(let o=0;o<n.length;o++)qv(n[o],t,e,r,s);else{const o=Wn(),i=ft();let a=Eu(n)?n:an(n.provide),l=KS(n);const c=bs(),u=1048575&c.providerIndexes,d=c.directiveStart,p=c.providerIndexes>>20;if(Eu(n)||!n.multi){const m=new Tl(l,s,Ve),y=Yv(a,t,s?u:u+p,d);-1===y?(hp(Dd(c,i),o,a),Zv(o,n,t.length),t.push(a),c.directiveStart++,c.directiveEnd++,s&&(c.providerIndexes+=1048576),e.push(m),i.push(m)):(e[y]=m,i[y]=m)}else{const m=Yv(a,t,u+p,d),y=Yv(a,t,u,u+p),C=y>=0&&e[y];if(s&&!C||!s&&!(m>=0&&e[m])){hp(Dd(c,i),o,a);const D=function mV(n,t,e,r,s){const o=new Tl(n,e,Ve);return o.multi=[],o.index=t,o.componentProviders=0,xT(o,s,r&&!e),o}(s?fV:pV,e.length,s,r,l);!s&&C&&(e[y].providerFactory=D),Zv(o,n,t.length,0),t.push(a),c.directiveStart++,c.directiveEnd++,s&&(c.providerIndexes+=1048576),e.push(D),i.push(D)}else Zv(o,n,m>-1?m:y,xT(e[s?y:m],l,!s&&r));!s&&r&&C&&e[y].componentProviders++}}}function Zv(n,t,e,r){const s=Eu(t),o=function p2(n){return!!n.useClass}(t);if(s||o){const l=(o?an(t.useClass):t).prototype.ngOnDestroy;if(l){const c=n.destroyHooks||(n.destroyHooks=[]);if(!s&&t.multi){const u=c.indexOf(e);-1===u?c.push(e,[r,l]):c[u+1].push(r,l)}else c.push(e,l)}}}function xT(n,t,e){return e&&n.componentProviders++,n.multi.push(t)-1}function Yv(n,t,e,r){for(let s=e;s<r;s++)if(t[s]===n)return s;return-1}function pV(n,t,e,r){return Qv(this.multi,[])}function fV(n,t,e,r){const s=this.multi;let o;if(this.providerFactory){const i=this.providerFactory.componentProviders,a=Il(e,e[Bt],this.providerFactory.index,r);o=a.slice(0,i),Qv(s,o);for(let l=i;l<a.length;l++)o.push(a[l])}else o=[],Qv(s,o);return o}function Qv(n,t){for(let e=0;e<n.length;e++)t.push((0,n[e])());return t}function mr(n,t=[]){return e=>{e.providersResolver=(r,s)=>function hV(n,t,e){const r=Wn();if(r.firstCreatePass){const s=Do(n);qv(e,r.data,r.blueprint,s,!0),qv(t,r.data,r.blueprint,s,!1)}}(r,s?s(n):n,t)}}class qd{}class CT{}class Jv extends qd{constructor(t,e,r){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new ME(this);const s=Gr(t);this._bootstrapComponents=Fl(s.bootstrap),this._r3Injector=gE(t,e,[{provide:qd,useValue:this},{provide:Rd,useValue:this.componentFactoryResolver},...r],Jn(t),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(t)}get injector(){return this._r3Injector}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class e0 extends CT{constructor(t){super(),this.moduleType=t}create(t){return new Jv(this.moduleType,t,[])}}class wT extends qd{constructor(t){super(),this.componentFactoryResolver=new ME(this),this.instance=null;const e=new J_([...t.providers,{provide:qd,useValue:this},{provide:Rd,useValue:this.componentFactoryResolver}],t.parent||ig(),t.debugName,new Set(["environment"]));this.injector=e,t.runEnvironmentInitializers&&e.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(t){this.injector.onDestroy(t)}}function t0(n,t,e=null){return new wT({providers:n,parent:t,debugName:e,runEnvironmentInitializers:!0}).injector}let bV=(()=>{class n{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e.id)){const r=HS(0,e.type),s=r.length>0?t0([r],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e.id,s)}return this.cachedInjectors.get(e.id)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}}return n.\u0275prov=b({token:n,providedIn:"environment",factory:()=>new n(Ke(kl))}),n})();function ST(n){n.getStandaloneInjector=t=>t.get(bV).getOrCreateStandaloneInjector(n)}function r0(n){return t=>{setTimeout(n,void 0,t)}}const nr=class WV extends et{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,r){let s=t,o=e||(()=>null),i=r;if(t&&"object"==typeof t){const l=t;s=l.next?.bind(l),o=l.error?.bind(l),i=l.complete?.bind(l)}this.__isAsync&&(o=r0(o),s&&(s=r0(s)),i&&(i=r0(i)));const a=super.subscribe({next:s,error:o,complete:i});return t instanceof U&&t.add(a),a}};function jV(){return this._results[Symbol.iterator]()}class Mg{get changes(){return this._changes||(this._changes=new nr)}constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=Mg.prototype;e[Symbol.iterator]||(e[Symbol.iterator]=jV)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const r=this;r.dirty=!1;const s=function Ho(n){return n.flat(Number.POSITIVE_INFINITY)}(t);(this._changesDetected=!function w_(n,t,e){if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++){let s=n[r],o=t[r];if(e&&(s=e(s),o=e(o)),o!==s)return!1}return!0}(r._results,s,e))&&(r._results=s,r.length=s.length,r.last=s[this.length-1],r.first=s[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let Ja=(()=>{class n{}return n.__NG_ELEMENT_ID__=XV,n})();const GV=Ja,KV=class extends GV{constructor(t,e,r){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=r}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(t,e){return this.createEmbeddedViewImpl(t,e,null)}createEmbeddedViewImpl(t,e,r){const s=this._declarationTContainer.tView,o=fg(this._declarationLView,s,t,16,null,s.declTNode,null,null,null,e||null,r||null);o[Cl]=this._declarationLView[this._declarationTContainer.index];const a=this._declarationLView[oo];return null!==a&&(o[oo]=a.createEmbeddedView(s)),Ev(s,o,t),new kp(o)}};function XV(){return Rg(bs(),ft())}function Rg(n,t){return 4&n.type?new KV(t,n,Od(n,t)):null}let fi=(()=>{class n{}return n.__NG_ELEMENT_ID__=t3,n})();function t3(){return UT(bs(),ft())}const n3=fi,BT=class extends n3{constructor(t,e,r){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=r}get element(){return Od(this._hostTNode,this._hostLView)}get injector(){return new _c(this._hostTNode,this._hostLView)}get parentInjector(){const t=js(this._hostTNode,this._hostLView);if(Rm(t)){const e=Sd(t,this._hostLView),r=wd(t);return new _c(e[Bt].data[r+8],e)}return new _c(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=VT(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-Kr}createEmbeddedView(t,e,r){let s,o;"number"==typeof r?s=r:null!=r&&(s=r.index,o=r.injector);const a=t.createEmbeddedViewImpl(e||{},o,null);return this.insertImpl(a,s,false),a}createComponent(t,e,r,s,o){const i=t&&!function xu(n){return"function"==typeof n}(t);let a;if(i)a=e;else{const _=e||{};a=_.index,r=_.injector,s=_.projectableNodes,o=_.environmentInjector||_.ngModuleRef}const l=i?t:new Mp(jn(t)),c=r||this.parentInjector;if(!o&&null==l.ngModule){const C=(i?c:this.parentInjector).get(kl,null);C&&(o=C)}jn(l.componentType??{});const m=l.create(c,s,null,o);return this.insertImpl(m.hostView,a,false),m}insert(t,e){return this.insertImpl(t,e,!1)}insertImpl(t,e,r){const s=t._lView,o=s[Bt];if(function Gb(n){return ks(n[fr])}(s)){const l=this.indexOf(t);if(-1!==l)this.detach(l);else{const c=s[fr],u=new BT(c,c[ss],c[fr]);u.detach(u.indexOf(t))}}const i=this._adjustIndex(e),a=this._lContainer;if(function SP(n,t,e,r){const s=Kr+r,o=e.length;r>0&&(e[s-1][so]=t),r<o-Kr?(t[so]=e[s],jm(e,Kr+r,t)):(e.push(t),t[so]=null),t[fr]=e;const i=t[Cl];null!==i&&e!==i&&function EP(n,t){const e=n[za];t[Rr]!==t[fr][fr][Rr]&&(n[dd]=!0),null===e?n[za]=[t]:e.push(t)}(i,t);const a=t[oo];null!==a&&a.insertView(n),t[vn]|=128}(o,s,a,i),!r){const l=B_(i,a),c=s[yn],u=Qm(c,a[zo]);null!==u&&function xP(n,t,e,r,s,o){r[Pr]=s,r[ss]=t,bp(n,r,e,1,s,o)}(o,a[ss],c,s,u,l)}return t.attachToViewContainerRef(),jm(o0(a),i,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=VT(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),r=F_(this._lContainer,e);r&&(T(o0(this._lContainer),e),fS(r[Bt],r))}detach(t){const e=this._adjustIndex(t,-1),r=F_(this._lContainer,e);return r&&null!=T(o0(this._lContainer),e)?new kp(r):null}_adjustIndex(t,e=0){return t??this.length+e}};function VT(n){return n[dc]}function o0(n){return n[dc]||(n[dc]=[])}function UT(n,t){let e;const r=t[n.index];return ks(r)?e=r:(e=EE(r,t,null,n),t[n.index]=e,mg(t,e)),zT(e,t,n,r),new BT(e,n,t)}let zT=function HT(n,t,e,r){if(n[zo])return;let s;s=8&e.type?or(r):function r3(n,t){const e=n[yn],r=e.createComment(""),s=ls(t,n);return wu(e,Qm(e,s),r,function AP(n,t){return n.nextSibling(t)}(e,s),!1),r}(t,e),n[zo]=s};class a0{constructor(t){this.queryList=t,this.matches=null}clone(){return new a0(this.queryList)}setDirty(){this.queryList.setDirty()}}class l0{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const r=null!==t.contentQueries?t.contentQueries[0]:e.length,s=[];for(let o=0;o<r;o++){const i=e.getByIndex(o);s.push(this.queries[i.indexInDeclarationView].clone())}return new l0(s)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==XT(t,e).matches&&this.queries[e].setDirty()}}class WT{constructor(t,e,r=null){this.predicate=t,this.flags=e,this.read=r}}class c0{constructor(t=[]){this.queries=t}elementStart(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let r=0;r<this.length;r++){const s=null!==e?e.length:0,o=this.getByIndex(r).embeddedTView(t,s);o&&(o.indexInDeclarationView=r,null!==e?e.push(o):e=[o])}return null!==e?new c0(e):null}template(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class u0{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new u0(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=t.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let s=0;s<r.length;s++){const o=r[s];this.matchTNodeWithReadOption(t,e,a3(e,o)),this.matchTNodeWithReadOption(t,e,Id(e,t,o,!1,!1))}else r===Ja?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,Id(e,t,r,!1,!1))}matchTNodeWithReadOption(t,e,r){if(null!==r){const s=this.metadata.read;if(null!==s)if(s===tr||s===fi||s===Ja&&4&e.type)this.addMatch(e.index,-2);else{const o=Id(e,t,s,!1,!1);null!==o&&this.addMatch(e.index,o)}else this.addMatch(e.index,r)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function a3(n,t){const e=n.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===t)return e[r+1];return null}function c3(n,t,e,r){return-1===e?function l3(n,t){return 11&n.type?Od(n,t):4&n.type?Rg(n,t):null}(t,n):-2===e?function u3(n,t,e){return e===tr?Od(t,n):e===Ja?Rg(t,n):e===fi?UT(t,n):void 0}(n,t,r):Il(n,n[Bt],e,t)}function jT(n,t,e,r){const s=t[oo].queries[r];if(null===s.matches){const o=n.data,i=e.matches,a=[];for(let l=0;l<i.length;l+=2){const c=i[l];a.push(c<0?null:c3(t,o[c],i[l+1],e.metadata.read))}s.matches=a}return s.matches}function d0(n,t,e,r){const s=n.queries.getByIndex(e),o=s.matches;if(null!==o){const i=jT(n,t,s,e);for(let a=0;a<o.length;a+=2){const l=o[a];if(l>0)r.push(i[a/2]);else{const c=o[a+1],u=t[-l];for(let d=Kr;d<u.length;d++){const p=u[d];p[Cl]===p[fr]&&d0(p[Bt],p,c,r)}if(null!==u[za]){const d=u[za];for(let p=0;p<d.length;p++){const m=d[p];d0(m[Bt],m,c,r)}}}}}return r}function mi(n){const t=ft(),e=Wn(),r=Cm();ap(r+1);const s=XT(e,r);if(n.dirty&&function um(n){return 4==(4&n[vn])}(t)===(2==(2&s.metadata.flags))){if(null===s.matches)n.reset([]);else{const o=s.crossesNgTemplate?d0(e,t,r,[]):jT(e,t,s,r);n.reset(o,R2),n.notifyOnChanges()}return!0}return!1}function Ac(n,t,e){const r=Wn();r.firstCreatePass&&(KT(r,new WT(n,t,e),-1),2==(2&t)&&(r.staticViewQueries=!0)),GT(r,ft(),t)}function Zd(n,t,e,r){const s=Wn();if(s.firstCreatePass){const o=bs();KT(s,new WT(t,e,r),o.index),function h3(n,t){const e=n.contentQueries||(n.contentQueries=[]);t!==(e.length?e[e.length-1]:-1)&&e.push(n.queries.length-1,t)}(s,n),2==(2&e)&&(s.staticContentQueries=!0)}GT(s,ft(),e)}function gi(){return function d3(n,t){return n[oo].queries[t].queryList}(ft(),Cm())}function GT(n,t,e){const r=new Mg(4==(4&e));(function n$(n,t,e,r){const s=TE(t);s.push(e),n.firstCreatePass&&IE(n).push(r,s.length-1)})(n,t,r,r.destroy),null===t[oo]&&(t[oo]=new l0),t[oo].queries.push(new a0(r))}function KT(n,t,e){null===n.queries&&(n.queries=new c0),n.queries.track(new u0(t,e))}function XT(n,t){return n.queries.getByIndex(t)}const Fg=new Ct("Application Initializer");let y0=(()=>{class n{constructor(){this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,r)=>{this.resolve=e,this.reject=r}),this.appInits=Ft(Fg,{optional:!0})??[]}runInitializers(){if(this.initialized)return;const e=[];for(const s of this.appInits){const o=s();if($p(o))e.push(o);else if(rD(o)){const i=new Promise((a,l)=>{o.subscribe({complete:a,error:l})});e.push(i)}}const r=()=>{this.done=!0,this.resolve()};Promise.all(e).then(()=>{r()}).catch(s=>{this.reject(s)}),0===e.length&&r(),this.initialized=!0}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),dI=(()=>{class n{log(e){console.log(e)}warn(e){console.warn(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();const el=new Ct("LocaleId",{providedIn:"root",factory:()=>Ft(el,Dt.Optional|Dt.SkipSelf)||function O3(){return typeof $localize<"u"&&$localize.locale||Xd}()});class P3{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}let hI=(()=>{class n{compileModuleSync(e){return new e0(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),o=Fl(Gr(e).declarations).reduce((i,a)=>{const l=jn(a);return l&&i.push(new Mp(l)),i},[]);return new P3(r,o)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const B3=(()=>Promise.resolve(0))();function b0(n){typeof Zone>"u"?B3.then(()=>{n&&n.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",n)}function mI(...n){}class wn{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new nr(!1),this.onMicrotaskEmpty=new nr(!1),this.onStable=new nr(!1),this.onError=new nr(!1),typeof Zone>"u")throw new qe(908,!1);Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!r&&e,s.shouldCoalesceRunChangeDetection=r,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function V3(){let n=be.requestAnimationFrame,t=be.cancelAnimationFrame;if(typeof Zone<"u"&&n&&t){const e=n[Zone.__symbol__("OriginalDelegate")];e&&(n=e);const r=t[Zone.__symbol__("OriginalDelegate")];r&&(t=r)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function H3(n){const t=()=>{!function z3(n){n.isCheckStableRunning||-1!==n.lastRequestAnimationFrameId||(n.lastRequestAnimationFrameId=n.nativeRequestAnimationFrame.call(be,()=>{n.fakeTopEventTask||(n.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{n.lastRequestAnimationFrameId=-1,v0(n),n.isCheckStableRunning=!0,_0(n),n.isCheckStableRunning=!1},void 0,()=>{},()=>{})),n.fakeTopEventTask.invoke()}),v0(n))}(n)};n._inner=n._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,s,o,i,a)=>{try{return gI(n),e.invokeTask(s,o,i,a)}finally{(n.shouldCoalesceEventChangeDetection&&"eventTask"===o.type||n.shouldCoalesceRunChangeDetection)&&t(),yI(n)}},onInvoke:(e,r,s,o,i,a,l)=>{try{return gI(n),e.invoke(s,o,i,a,l)}finally{n.shouldCoalesceRunChangeDetection&&t(),yI(n)}},onHasTask:(e,r,s,o)=>{e.hasTask(s,o),r===s&&("microTask"==o.change?(n._hasPendingMicrotasks=o.microTask,v0(n),_0(n)):"macroTask"==o.change&&(n.hasPendingMacrotasks=o.macroTask))},onHandleError:(e,r,s,o)=>(e.handleError(s,o),n.runOutsideAngular(()=>n.onError.emit(o)),!1)})}(s)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!wn.isInAngularZone())throw new qe(909,!1)}static assertNotInAngularZone(){if(wn.isInAngularZone())throw new qe(909,!1)}run(t,e,r){return this._inner.run(t,e,r)}runTask(t,e,r,s){const o=this._inner,i=o.scheduleEventTask("NgZoneEvent: "+s,t,U3,mI,mI);try{return o.runTask(i,e,r)}finally{o.cancelTask(i)}}runGuarded(t,e,r){return this._inner.runGuarded(t,e,r)}runOutsideAngular(t){return this._outer.run(t)}}const U3={};function _0(n){if(0==n._nesting&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function v0(n){n.hasPendingMicrotasks=!!(n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&-1!==n.lastRequestAnimationFrameId)}function gI(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function yI(n){n._nesting--,_0(n)}class W3{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new nr,this.onMicrotaskEmpty=new nr,this.onStable=new nr,this.onError=new nr}run(t,e,r){return t.apply(e,r)}runGuarded(t,e,r){return t.apply(e,r)}runOutsideAngular(t){return t()}runTask(t,e,r,s){return t.apply(e,r)}}const bI=new Ct("",{providedIn:"root",factory:_I});function _I(){const n=Ft(wn);let t=!0;return fs(new Me(s=>{t=n.isStable&&!n.hasPendingMacrotasks&&!n.hasPendingMicrotasks,n.runOutsideAngular(()=>{s.next(t),s.complete()})}),new Me(s=>{let o;n.runOutsideAngular(()=>{o=n.onStable.subscribe(()=>{wn.assertNotInAngularZone(),b0(()=>{!t&&!n.hasPendingMacrotasks&&!n.hasPendingMicrotasks&&(t=!0,s.next(!0))})})});const i=n.onUnstable.subscribe(()=>{wn.assertInAngularZone(),t&&(t=!1,n.runOutsideAngular(()=>{s.next(!1)}))});return()=>{o.unsubscribe(),i.unsubscribe()}}).pipe(Qi()))}const vI=new Ct(""),Pg=new Ct("");let w0,x0=(()=>{class n{constructor(e,r,s){this._ngZone=e,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,w0||(function j3(n){w0=n}(s),s.addToWindow(r)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{wn.assertNotInAngularZone(),b0(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())b0(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,s){let o=-1;r&&r>0&&(o=setTimeout(()=>{this._callbacks=this._callbacks.filter(i=>i.timeoutId!==o),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:o,updateCb:s})}whenStable(e,r,s){if(s&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,s),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,r,s){return[]}}return n.\u0275fac=function(e){return new(e||n)(Ke(wn),Ke(C0),Ke(Pg))},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})(),C0=(()=>{class n{constructor(){this._applications=new Map}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return w0?.findTestabilityInTree(this,e,r)??null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})(),Nc=null;const xI=new Ct("AllowMultipleToken"),S0=new Ct("PlatformDestroyListeners"),E0=new Ct("appBootstrapListener");class wI{constructor(t,e){this.name=t,this.token=e}}function EI(n,t,e=[]){const r=`Platform: ${t}`,s=new Ct(r);return(o=[])=>{let i=D0();if(!i||i.injector.get(xI,!1)){const a=[...e,...o,{provide:s,useValue:!0}];n?n(a):function X3(n){if(Nc&&!Nc.get(xI,!1))throw new qe(400,!1);(function CI(){!function Bb(n){nm=n}(()=>{throw new qe(600,!1)})})(),Nc=n;const t=n.get(TI);(function SI(n){n.get(XS,null)?.forEach(e=>e())})(n)}(function DI(n=[],t){return Gs.create({name:t,providers:[{provide:Y_,useValue:"platform"},{provide:S0,useValue:new Set([()=>Nc=null])},...n]})}(a,r))}return function Z3(n){const t=D0();if(!t)throw new qe(401,!1);return t}()}}function D0(){return Nc?.get(TI)??null}let TI=(()=>{class n{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const s=function Y3(n="zone.js",t){return"noop"===n?new W3:"zone.js"===n?new wn(t):n}(r?.ngZone,function II(n){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:n?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:n?.runCoalescing??!1}}({eventCoalescing:r?.ngZoneEventCoalescing,runCoalescing:r?.ngZoneRunCoalescing}));return s.run(()=>{const o=function yV(n,t,e){return new Jv(n,t,e)}(e.moduleType,this.injector,function RI(n){return[{provide:wn,useFactory:n},{provide:Cp,multi:!0,useFactory:()=>{const t=Ft(J3,{optional:!0});return()=>t.initialize()}},{provide:MI,useFactory:Q3},{provide:bI,useFactory:_I}]}(()=>s)),i=o.injector.get(Ka,null);return s.runOutsideAngular(()=>{const a=s.onError.subscribe({next:l=>{i.handleError(l)}});o.onDestroy(()=>{$g(this._modules,o),a.unsubscribe()})}),function AI(n,t,e){try{const r=e();return $p(r)?r.catch(s=>{throw t.runOutsideAngular(()=>n.handleError(s)),s}):r}catch(r){throw t.runOutsideAngular(()=>n.handleError(r)),r}}(i,s,()=>{const a=o.injector.get(y0);return a.runInitializers(),a.donePromise.then(()=>(function YD(n){ts(n,"Expected localeId to be defined"),"string"==typeof n&&(ZD=n.toLowerCase().replace(/_/g,"-"))}(o.injector.get(el,Xd)||Xd),this._moduleDoBootstrap(o),o))})})}bootstrapModule(e,r=[]){const s=NI({},r);return function G3(n,t,e){const r=new e0(e);return Promise.resolve(r)}(0,0,e).then(o=>this.bootstrapModuleFactory(o,s))}_moduleDoBootstrap(e){const r=e.injector.get(Ll);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(s=>r.bootstrap(s));else{if(!e.instance.ngDoBootstrap)throw new qe(-403,!1);e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new qe(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get(S0,null);e&&(e.forEach(r=>r()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return n.\u0275fac=function(e){return new(e||n)(Ke(Gs))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();function NI(n,t){return Array.isArray(t)?t.reduce(NI,n):{...n,...t}}let Ll=(()=>{class n{constructor(){this._bootstrapListeners=[],this._runningTick=!1,this._destroyed=!1,this._destroyListeners=[],this._views=[],this.internalErrorHandler=Ft(MI),this.componentTypes=[],this.components=[],this.isStable=Ft(bI),this._injector=Ft(kl)}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(e,r){const s=e instanceof eE;if(!this._injector.get(y0).done)throw!s&&function Ri(n){const t=jn(n)||rs(n)||Ns(n);return null!==t&&t.standalone}(e),new qe(405,!1);let i;i=s?e:this._injector.get(Rd).resolveComponentFactory(e),this.componentTypes.push(i.componentType);const a=function K3(n){return n.isBoundToModule}(i)?void 0:this._injector.get(qd),c=i.create(Gs.NULL,[],r||i.selector,a),u=c.location.nativeElement,d=c.injector.get(vI,null);return d?.registerApplication(u),c.onDestroy(()=>{this.detachView(c.hostView),$g(this.components,c),d?.unregisterApplication(u)}),this._loadComponent(c),c}tick(){if(this._runningTick)throw new qe(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this.internalErrorHandler(e)}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;$g(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e);const r=this._injector.get(E0,[]);r.push(...this._bootstrapListeners),r.forEach(s=>s(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy())}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>$g(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new qe(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function $g(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}const MI=new Ct("",{providedIn:"root",factory:()=>Ft(Ka).handleError.bind(void 0)});function Q3(){const n=Ft(wn),t=Ft(Ka);return e=>n.runOutsideAngular(()=>t.handleError(e))}let J3=(()=>{class n{constructor(){this.zone=Ft(wn),this.applicationRef=Ft(Ll)}initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.zone.run(()=>{this.applicationRef.tick()})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();let tl=(()=>{class n{}return n.__NG_ELEMENT_ID__=nU,n})();function nU(n){return function rU(n,t,e){if(di(n)&&!e){const r=co(n.index,t);return new kp(r,r)}return 47&n.type?new kp(t[Rr],t):null}(bs(),ft(),16==(16&n))}class $I{constructor(){}supports(t){return _g(t)}create(t){return new cU(t)}}const lU=(n,t)=>t;class cU{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||lU}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,r=this._removalsHead,s=0,o=null;for(;e||r;){const i=!r||e&&e.currentIndex<BI(r,s,o)?e:r,a=BI(i,s,o),l=i.currentIndex;if(i===r)s--,r=r._nextRemoved;else if(e=e._next,null==i.previousIndex)s++;else{o||(o=[]);const c=a-s,u=l-s;if(c!=u){for(let p=0;p<c;p++){const m=p<o.length?o[p]:o[p]=0,y=m+p;u<=y&&y<c&&(o[p]=m+1)}o[i.previousIndex]=u-c}}a!==l&&t(i,a,l)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!_g(t))throw new qe(900,!1);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let s,o,i,e=this._itHead,r=!1;if(Array.isArray(t)){this.length=t.length;for(let a=0;a<this.length;a++)o=t[a],i=this._trackByFn(a,o),null!==e&&Object.is(e.trackById,i)?(r&&(e=this._verifyReinsertion(e,o,i,a)),Object.is(e.item,o)||this._addIdentityChange(e,o)):(e=this._mismatch(e,o,i,a),r=!0),e=e._next}else s=0,function Q$(n,t){if(Array.isArray(n))for(let e=0;e<n.length;e++)t(n[e]);else{const e=n[Symbol.iterator]();let r;for(;!(r=e.next()).done;)t(r.value)}}(t,a=>{i=this._trackByFn(s,a),null!==e&&Object.is(e.trackById,i)?(r&&(e=this._verifyReinsertion(e,a,i,s)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,i,s),r=!0),e=e._next,s++}),this.length=s;return this._truncate(e),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,r,s){let o;return null===t?o=this._itTail:(o=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,o,s)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(r,s))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,o,s)):t=this._addAfter(new uU(e,r),o,s),t}_verifyReinsertion(t,e,r,s){let o=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null);return null!==o?t=this._reinsertAfter(o,t._prev,s):t.currentIndex!=s&&(t.currentIndex=s,this._addToMoves(t,s)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,r){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const s=t._prevRemoved,o=t._nextRemoved;return null===s?this._removalsHead=o:s._nextRemoved=o,null===o?this._removalsTail=s:o._prevRemoved=s,this._insertAfter(t,e,r),this._addToMoves(t,r),t}_moveAfter(t,e,r){return this._unlink(t),this._insertAfter(t,e,r),this._addToMoves(t,r),t}_addAfter(t,e,r){return this._insertAfter(t,e,r),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,r){const s=null===e?this._itHead:e._next;return t._next=s,t._prev=e,null===s?this._itTail=t:s._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new LI),this._linkedRecords.put(t),t.currentIndex=r,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,r=t._next;return null===e?this._itHead=r:e._next=r,null===r?this._itTail=e:r._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new LI),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class uU{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class dU{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let r;for(r=this._head;null!==r;r=r._nextDup)if((null===e||e<=r.currentIndex)&&Object.is(r.trackById,t))return r;return null}remove(t){const e=t._prevDup,r=t._nextDup;return null===e?this._head=r:e._nextDup=r,null===r?this._tail=e:r._prevDup=e,null===this._head}}class LI{constructor(){this.map=new Map}put(t){const e=t.trackById;let r=this.map.get(e);r||(r=new dU,this.map.set(e,r)),r.add(t)}get(t,e){const s=this.map.get(t);return s?s.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function BI(n,t,e){const r=n.previousIndex;if(null===r)return r;let s=0;return e&&r<e.length&&(s=e[r]),r+t+s}class VI{constructor(){}supports(t){return t instanceof Map||Iv(t)}create(){return new hU}}class hU{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||Iv(t)))throw new qe(900,!1)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(r,s)=>{if(e&&e.key===s)this._maybeAddToChanges(e,r),this._appendAfter=e,e=e._next;else{const o=this._getOrCreateRecordForKey(s,r);e=this._insertBeforeOrAppend(e,o)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let r=e;null!==r;r=r._nextRemoved)r===this._mapHead&&(this._mapHead=null),this._records.delete(r.key),r._nextRemoved=r._next,r.previousValue=r.currentValue,r.currentValue=null,r._prev=null,r._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const r=t._prev;return e._next=t,e._prev=r,t._prev=e,r&&(r._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const s=this._records.get(t);this._maybeAddToChanges(s,e);const o=s._prev,i=s._next;return o&&(o._next=i),i&&(i._prev=o),s._next=null,s._prev=null,s}const r=new pU(t);return this._records.set(t,r),r.currentValue=e,this._addToAdditions(r),r}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(r=>e(t[r],r))}}class pU{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function UI(){return new Vg([new $I])}let Vg=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(null!=r){const s=r.factories.slice();e=e.concat(s)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||UI()),deps:[[n,new In,new er]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(null!=r)return r;throw new qe(901,!1)}}return n.\u0275prov=b({token:n,providedIn:"root",factory:UI}),n})();function zI(){return new Kp([new VI])}let Kp=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(r){const s=r.factories.slice();e=e.concat(s)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||zI()),deps:[[n,new In,new er]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(r)return r;throw new qe(901,!1)}}return n.\u0275prov=b({token:n,providedIn:"root",factory:zI}),n})();const gU=EI(null,"core",[]);let yU=(()=>{class n{constructor(e){}}return n.\u0275fac=function(e){return new(e||n)(Ke(Ll))},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({}),n})(),XI=(()=>{class n{get whenAllTasksComplete(){return 0===this.collection.size&&this.complete(),this.promise}constructor(){this.taskId=0,this.collection=new Set,this.ngZone=Ft(wn),this.completed=!1,this.ngZone.runOutsideAngular(()=>{this.promise=new Promise(e=>{this.resolve=e})})}add(){if(this.completed)return-1;const e=this.taskId++;return this.collection.add(e),e}remove(e){this.completed||(this.collection.delete(e),0===this.collection.size&&this.complete())}ngOnDestroy(){this.complete(),this.collection.clear()}complete(){this.completed=!0,this.resolve()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),R0=null;function kc(){return R0}class AU{}const kn=new Ct("DocumentToken");let O0=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:function(){return Ft(kU)},providedIn:"platform"}),n})();const NU=new Ct("Location Initialized");let kU=(()=>{class n extends O0{constructor(){super(),this._doc=Ft(kn),this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return kc().getBaseHref(this._doc)}onPopState(e){const r=kc().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=kc().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(e){this._location.pathname=e}pushState(e,r,s){this._history.pushState(e,r,s)}replaceState(e,r,s){this._history.replaceState(e,r,s)}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:function(){return new n},providedIn:"platform"}),n})();function F0(n,t){if(0==n.length)return t;if(0==t.length)return n;let e=0;return n.endsWith("/")&&e++,t.startsWith("/")&&e++,2==e?n+t.substring(1):1==e?n+t:n+"/"+t}function ZI(n){const t=n.match(/#|\?|$/),e=t&&t.index||n.length;return n.slice(0,e-("/"===n[e-1]?1:0))+n.slice(e)}function Bl(n){return n&&"?"!==n[0]?"?"+n:n}let ku=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:function(){return Ft(QI)},providedIn:"root"}),n})();const YI=new Ct("appBaseHref");let QI=(()=>{class n extends ku{constructor(e,r){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??Ft(kn).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return F0(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+Bl(this._platformLocation.search),s=this._platformLocation.hash;return s&&e?`${r}${s}`:r}pushState(e,r,s,o){const i=this.prepareExternalUrl(s+Bl(o));this._platformLocation.pushState(e,r,i)}replaceState(e,r,s,o){const i=this.prepareExternalUrl(s+Bl(o));this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(Ke(O0),Ke(YI,8))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),MU=(()=>{class n extends ku{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=F0(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,s,o){let i=this.prepareExternalUrl(s+Bl(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.pushState(e,r,i)}replaceState(e,r,s,o){let i=this.prepareExternalUrl(s+Bl(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(Ke(O0),Ke(YI,8))},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})(),zg=(()=>{class n{constructor(e){this._subject=new nr,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const r=this._locationStrategy.getBaseHref();this._basePath=function FU(n){if(new RegExp("^(https?:)?//").test(n)){const[,e]=n.split(/\/\/[^\/]+/);return e}return n}(ZI(JI(r))),this._locationStrategy.onPopState(s=>{this._subject.emit({url:this.path(!0),pop:!0,state:s.state,type:s.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+Bl(r))}normalize(e){return n.stripTrailingSlash(function OU(n,t){if(!n||!t.startsWith(n))return t;const e=t.substring(n.length);return""===e||["/",";","?","#"].includes(e[0])?e:t}(this._basePath,JI(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",s=null){this._locationStrategy.pushState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Bl(r)),s)}replaceState(e,r="",s=null){this._locationStrategy.replaceState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Bl(r)),s)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)})),()=>{const r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(s=>s(e,r))}subscribe(e,r,s){return this._subject.subscribe({next:e,error:r,complete:s})}}return n.normalizeQueryParams=Bl,n.joinWithSlash=F0,n.stripTrailingSlash=ZI,n.\u0275fac=function(e){return new(e||n)(Ke(ku))},n.\u0275prov=b({token:n,factory:function(){return function RU(){return new zg(Ke(ku))}()},providedIn:"root"}),n})();function JI(n){return n.replace(/\/index.html$/,"")}const j0=/\s+/,c1=[];let u1=(()=>{class n{constructor(e,r,s,o){this._iterableDiffers=e,this._keyValueDiffers=r,this._ngEl=s,this._renderer=o,this.initialClasses=c1,this.stateMap=new Map}set klass(e){this.initialClasses=null!=e?e.trim().split(j0):c1}set ngClass(e){this.rawClass="string"==typeof e?e.trim().split(j0):e}ngDoCheck(){for(const r of this.initialClasses)this._updateState(r,!0);const e=this.rawClass;if(Array.isArray(e)||e instanceof Set)for(const r of e)this._updateState(r,!0);else if(null!=e)for(const r of Object.keys(e))this._updateState(r,!!e[r]);this._applyStateDiff()}_updateState(e,r){const s=this.stateMap.get(e);void 0!==s?(s.enabled!==r&&(s.changed=!0,s.enabled=r),s.touched=!0):this.stateMap.set(e,{enabled:r,changed:!0,touched:!0})}_applyStateDiff(){for(const e of this.stateMap){const r=e[0],s=e[1];s.changed?(this._toggleClass(r,s.enabled),s.changed=!1):s.touched||(s.enabled&&this._toggleClass(r,!1),this.stateMap.delete(r)),s.touched=!1}}_toggleClass(e,r){(e=e.trim()).length>0&&e.split(j0).forEach(s=>{r?this._renderer.addClass(this._ngEl.nativeElement,s):this._renderer.removeClass(this._ngEl.nativeElement,s)})}}return n.\u0275fac=function(e){return new(e||n)(Ve(Vg),Ve(Kp),Ve(tr),Ve(Ol))},n.\u0275dir=It({type:n,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"},standalone:!0}),n})(),p1=(()=>{class n{constructor(e,r){this._viewContainer=e,this._context=new Cz,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){f1("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){f1("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(Ve(fi),Ve(Ja))},n.\u0275dir=It({type:n,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),n})();class Cz{constructor(){this.$implicit=null,this.ngIf=null}}function f1(n,t){if(t&&!t.createEmbeddedView)throw new Error(`${n} must be a TemplateRef, but received '${Jn(t)}'.`)}let Qg=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({}),n})();const y1="browser";function Z0(n){return n===y1}function b1(n){return"server"===n}let Zz=(()=>{class n{}return n.\u0275prov=b({token:n,providedIn:"root",factory:()=>new Yz(Ke(kn),window)}),n})();class Yz{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(!this.supportsScrolling())return;const e=function Qz(n,t){const e=n.getElementById(t)||n.getElementsByName(t)[0];if(e)return e;if("function"==typeof n.createTreeWalker&&n.body&&"function"==typeof n.body.attachShadow){const r=n.createTreeWalker(n.body,NodeFilter.SHOW_ELEMENT);let s=r.currentNode;for(;s;){const o=s.shadowRoot;if(o){const i=o.getElementById(t)||o.querySelector(`[name="${t}"]`);if(i)return i}s=r.nextNode()}}return null}(this.document,t);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),r=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,o=this.offset();this.window.scrollTo(r-o[0],s-o[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=_1(this.window.history)||_1(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch{return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}function _1(n){return Object.getOwnPropertyDescriptor(n,"scrollRestoration")}class DH extends AU{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class J0 extends DH{static makeCurrent(){!function IU(n){R0||(R0=n)}(new J0)}onAndCancel(t,e,r){return t.addEventListener(e,r),()=>{t.removeEventListener(e,r)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getBaseHref(t){const e=function TH(){return Yp=Yp||document.querySelector("base"),Yp?Yp.getAttribute("href"):null}();return null==e?null:function IH(n){ny=ny||document.createElement("a"),ny.setAttribute("href",n);const t=ny.pathname;return"/"===t.charAt(0)?t:`/${t}`}(e)}resetBaseElement(){Yp=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return function bz(n,t){t=encodeURIComponent(t);for(const e of n.split(";")){const r=e.indexOf("="),[s,o]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(s.trim()===t)return decodeURIComponent(o)}return null}(document.cookie,t)}}let ny,Yp=null,NH=(()=>{class n{build(){return new XMLHttpRequest}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})();const ex=new Ct("EventManagerPlugins");let S1=(()=>{class n{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(s=>{s.manager=this}),this._plugins=e.slice().reverse()}addEventListener(e,r,s){return this._findPluginFor(r).addEventListener(e,r,s)}getZone(){return this._zone}_findPluginFor(e){let r=this._eventNameToPlugin.get(e);if(r)return r;if(r=this._plugins.find(o=>o.supports(e)),!r)throw new qe(5101,!1);return this._eventNameToPlugin.set(e,r),r}}return n.\u0275fac=function(e){return new(e||n)(Ke(ex),Ke(wn))},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})();class E1{constructor(t){this._doc=t}}const tx="ng-app-id";let D1=(()=>{class n{constructor(e,r,s,o={}){this.doc=e,this.appId=r,this.nonce=s,this.platformId=o,this.styleRef=new Map,this.hostNodes=new Set,this.styleNodesInDOM=this.collectServerRenderedStyles(),this.platformIsServer=b1(o),this.resetHostNodes()}addStyles(e){for(const r of e)1===this.changeUsageCount(r,1)&&this.onStyleAdded(r)}removeStyles(e){for(const r of e)this.changeUsageCount(r,-1)<=0&&this.onStyleRemoved(r)}ngOnDestroy(){const e=this.styleNodesInDOM;e&&(e.forEach(r=>r.remove()),e.clear());for(const r of this.getAllStyles())this.onStyleRemoved(r);this.resetHostNodes()}addHost(e){this.hostNodes.add(e);for(const r of this.getAllStyles())this.addStyleToHost(e,r)}removeHost(e){this.hostNodes.delete(e)}getAllStyles(){return this.styleRef.keys()}onStyleAdded(e){for(const r of this.hostNodes)this.addStyleToHost(r,e)}onStyleRemoved(e){const r=this.styleRef;r.get(e)?.elements?.forEach(s=>s.remove()),r.delete(e)}collectServerRenderedStyles(){const e=this.doc.head?.querySelectorAll(`style[${tx}="${this.appId}"]`);if(e?.length){const r=new Map;return e.forEach(s=>{null!=s.textContent&&r.set(s.textContent,s)}),r}return null}changeUsageCount(e,r){const s=this.styleRef;if(s.has(e)){const o=s.get(e);return o.usage+=r,o.usage}return s.set(e,{usage:r,elements:[]}),r}getStyleElement(e,r){const s=this.styleNodesInDOM,o=s?.get(r);if(o?.parentNode===e)return s.delete(r),o.removeAttribute(tx),o;{const i=this.doc.createElement("style");return this.nonce&&i.setAttribute("nonce",this.nonce),i.textContent=r,this.platformIsServer&&i.setAttribute(tx,this.appId),i}}addStyleToHost(e,r){const s=this.getStyleElement(e,r);e.appendChild(s);const o=this.styleRef,i=o.get(r)?.elements;i?i.push(s):o.set(r,{elements:[s],usage:1})}resetHostNodes(){const e=this.hostNodes;e.clear(),e.add(this.doc.head)}}return n.\u0275fac=function(e){return new(e||n)(Ke(kn),Ke(wp),Ke(nv,8),Ke(Ml))},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})();const nx={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},rx=/%COMP%/g,OH=new Ct("RemoveStylesOnCompDestory",{providedIn:"root",factory:()=>!1});function I1(n,t){return t.map(e=>e.replace(rx,n))}let sx=(()=>{class n{constructor(e,r,s,o,i,a,l,c=null){this.eventManager=e,this.sharedStylesHost=r,this.appId=s,this.removeStylesOnCompDestory=o,this.doc=i,this.platformId=a,this.ngZone=l,this.nonce=c,this.rendererByCompId=new Map,this.platformIsServer=b1(a),this.defaultRenderer=new ox(e,i,l,this.platformIsServer)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;this.platformIsServer&&r.encapsulation===gs.ShadowDom&&(r={...r,encapsulation:gs.Emulated});const s=this.getOrCreateRenderer(e,r);return s instanceof N1?s.applyToHost(e):s instanceof ix&&s.applyStyles(),s}getOrCreateRenderer(e,r){const s=this.rendererByCompId;let o=s.get(r.id);if(!o){const i=this.doc,a=this.ngZone,l=this.eventManager,c=this.sharedStylesHost,u=this.removeStylesOnCompDestory,d=this.platformIsServer;switch(r.encapsulation){case gs.Emulated:o=new N1(l,c,r,this.appId,u,i,a,d);break;case gs.ShadowDom:return new LH(l,c,e,r,i,a,this.nonce,d);default:o=new ix(l,c,r,u,i,a,d)}o.onDestroy=()=>s.delete(r.id),s.set(r.id,o)}return o}ngOnDestroy(){this.rendererByCompId.clear()}}return n.\u0275fac=function(e){return new(e||n)(Ke(S1),Ke(D1),Ke(wp),Ke(OH),Ke(kn),Ke(Ml),Ke(wn),Ke(nv))},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})();class ox{constructor(t,e,r,s){this.eventManager=t,this.doc=e,this.ngZone=r,this.platformIsServer=s,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(t,e){return e?this.doc.createElementNS(nx[e]||e,t):this.doc.createElement(t)}createComment(t){return this.doc.createComment(t)}createText(t){return this.doc.createTextNode(t)}appendChild(t,e){(A1(t)?t.content:t).appendChild(e)}insertBefore(t,e,r){t&&(A1(t)?t.content:t).insertBefore(e,r)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let r="string"==typeof t?this.doc.querySelector(t):t;if(!r)throw new qe(5104,!1);return e||(r.textContent=""),r}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,r,s){if(s){e=s+":"+e;const o=nx[s];o?t.setAttributeNS(o,e,r):t.setAttribute(e,r)}else t.setAttribute(e,r)}removeAttribute(t,e,r){if(r){const s=nx[r];s?t.removeAttributeNS(s,e):t.removeAttribute(`${r}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,r,s){s&(jo.DashCase|jo.Important)?t.style.setProperty(e,r,s&jo.Important?"important":""):t.style[e]=r}removeStyle(t,e,r){r&jo.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,r){t[e]=r}setValue(t,e){t.nodeValue=e}listen(t,e,r){if("string"==typeof t&&!(t=kc().getGlobalEventTarget(this.doc,t)))throw new Error(`Unsupported event target ${t} for event ${e}`);return this.eventManager.addEventListener(t,e,this.decoratePreventDefault(r))}decoratePreventDefault(t){return e=>{if("__ngUnwrap__"===e)return t;!1===(this.platformIsServer?this.ngZone.runGuarded(()=>t(e)):t(e))&&e.preventDefault()}}}function A1(n){return"TEMPLATE"===n.tagName&&void 0!==n.content}class LH extends ox{constructor(t,e,r,s,o,i,a,l){super(t,o,i,l),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const c=I1(s.id,s.styles);for(const u of c){const d=document.createElement("style");a&&d.setAttribute("nonce",a),d.textContent=u,this.shadowRoot.appendChild(d)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,r){return super.insertBefore(this.nodeOrShadowRoot(t),e,r)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}}class ix extends ox{constructor(t,e,r,s,o,i,a,l){super(t,o,i,a),this.sharedStylesHost=e,this.removeStylesOnCompDestory=s,this.rendererUsageCount=0,this.styles=l?I1(l,r.styles):r.styles}applyStyles(){this.sharedStylesHost.addStyles(this.styles),this.rendererUsageCount++}destroy(){this.removeStylesOnCompDestory&&(this.sharedStylesHost.removeStyles(this.styles),this.rendererUsageCount--,0===this.rendererUsageCount&&this.onDestroy?.())}}class N1 extends ix{constructor(t,e,r,s,o,i,a,l){const c=s+"-"+r.id;super(t,e,r,o,i,a,l,c),this.contentAttr=function FH(n){return"_ngcontent-%COMP%".replace(rx,n)}(c),this.hostAttr=function PH(n){return"_nghost-%COMP%".replace(rx,n)}(c)}applyToHost(t){this.applyStyles(),this.setAttribute(t,this.hostAttr,"")}createElement(t,e){const r=super.createElement(t,e);return super.setAttribute(r,this.contentAttr,""),r}}let BH=(()=>{class n extends E1{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,s){return e.addEventListener(r,s,!1),()=>this.removeEventListener(e,r,s)}removeEventListener(e,r,s){return e.removeEventListener(r,s)}}return n.\u0275fac=function(e){return new(e||n)(Ke(kn))},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})();const k1=["alt","control","meta","shift"],VH={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},UH={alt:n=>n.altKey,control:n=>n.ctrlKey,meta:n=>n.metaKey,shift:n=>n.shiftKey};let zH=(()=>{class n extends E1{constructor(e){super(e)}supports(e){return null!=n.parseEventName(e)}addEventListener(e,r,s){const o=n.parseEventName(r),i=n.eventCallback(o.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>kc().onAndCancel(e,o.domEventName,i))}static parseEventName(e){const r=e.toLowerCase().split("."),s=r.shift();if(0===r.length||"keydown"!==s&&"keyup"!==s)return null;const o=n._normalizeKey(r.pop());let i="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),i="code."),k1.forEach(c=>{const u=r.indexOf(c);u>-1&&(r.splice(u,1),i+=c+".")}),i+=o,0!=r.length||0===o.length)return null;const l={};return l.domEventName=s,l.fullKey=i,l}static matchEventFullKeyCode(e,r){let s=VH[e.key]||e.key,o="";return r.indexOf("code.")>-1&&(s=e.code,o="code."),!(null==s||!s)&&(s=s.toLowerCase()," "===s?s="space":"."===s&&(s="dot"),k1.forEach(i=>{i!==s&&(0,UH[i])(e)&&(o+=i+".")}),o+=s,o===r)}static eventCallback(e,r,s){return o=>{n.matchEventFullKeyCode(o,e)&&s.runGuarded(()=>r(o))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return n.\u0275fac=function(e){return new(e||n)(Ke(kn))},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})();const GH=EI(gU,"browser",[{provide:Ml,useValue:y1},{provide:XS,useValue:function HH(){J0.makeCurrent()},multi:!0},{provide:kn,useFactory:function jH(){return function $P(n){z_=n}(document),document},deps:[]}]),KH=new Ct(""),O1=[{provide:Pg,useClass:class AH{addToWindow(t){be.getAngularTestability=(r,s=!0)=>{const o=t.findTestabilityInTree(r,s);if(null==o)throw new qe(5103,!1);return o},be.getAllAngularTestabilities=()=>t.getAllTestabilities(),be.getAllAngularRootElements=()=>t.getAllRootElements(),be.frameworkStabilizers||(be.frameworkStabilizers=[]),be.frameworkStabilizers.push(r=>{const s=be.getAllAngularTestabilities();let o=s.length,i=!1;const a=function(l){i=i||l,o--,0==o&&r(i)};s.forEach(function(l){l.whenStable(a)})})}findTestabilityInTree(t,e,r){return null==e?null:t.getTestability(e)??(r?kc().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null)}},deps:[]},{provide:vI,useClass:x0,deps:[wn,C0,Pg]},{provide:x0,useClass:x0,deps:[wn,C0,Pg]}],F1=[{provide:Y_,useValue:"root"},{provide:Ka,useFactory:function WH(){return new Ka},deps:[]},{provide:ex,useClass:BH,multi:!0,deps:[kn,wn,Ml]},{provide:ex,useClass:zH,multi:!0,deps:[kn]},sx,D1,S1,{provide:Tp,useExisting:sx},{provide:class Jz{},useClass:NH,deps:[]},[]];let P1=(()=>{class n{constructor(e){}static withServerTransition(e){return{ngModule:n,providers:[{provide:wp,useValue:e.appId}]}}}return n.\u0275fac=function(e){return new(e||n)(Ke(KH,12))},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({providers:[...F1,...O1],imports:[Qg,yU]}),n})(),$1=(()=>{class n{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}}return n.\u0275fac=function(e){return new(e||n)(Ke(kn))},n.\u0275prov=b({token:n,factory:function(e){let r=null;return r=e?new e:function qH(){return new $1(Ke(kn))}(),r},providedIn:"root"}),n})();typeof window<"u"&&window;let lx=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:function(e){let r=null;return r=e?new(e||n):Ke(V1),r},providedIn:"root"}),n})(),V1=(()=>{class n extends lx{constructor(e){super(),this._doc=e}sanitize(e,r){if(null==r)return null;switch(e){case Qn.NONE:return r;case Qn.HTML:return Ga(r,"HTML")?hi(r):PS(this._doc,String(r)).toString();case Qn.STYLE:return Ga(r,"Style")?hi(r):r;case Qn.SCRIPT:if(Ga(r,"Script"))return hi(r);throw new qe(5200,!1);case Qn.URL:return Ga(r,"URL")?hi(r):rg(String(r));case Qn.RESOURCE_URL:if(Ga(r,"ResourceURL"))return hi(r);throw new qe(5201,!1);default:throw new qe(5202,!1)}}bypassSecurityTrustHtml(e){return function WP(n){return new LP(n)}(e)}bypassSecurityTrustStyle(e){return function jP(n){return new BP(n)}(e)}bypassSecurityTrustScript(e){return function GP(n){return new VP(n)}(e)}bypassSecurityTrustUrl(e){return function KP(n){return new UP(n)}(e)}bypassSecurityTrustResourceUrl(e){return function XP(n){return new zP(n)}(e)}}return n.\u0275fac=function(e){return new(e||n)(Ke(kn))},n.\u0275prov=b({token:n,factory:function(e){let r=null;return r=e?new e:function JH(n){return new V1(n.get(kn))}(Ke(Gs)),r},providedIn:"root"}),n})();function sn(...n){return pr(n,$s(n))}class Vi extends et{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return!e.closed&&t.next(this._value),e}getValue(){const{hasError:t,thrownError:e,_value:r}=this;if(t)throw e;return this._throwIfClosed(),r}next(t){super.next(this._value=t)}}const{isArray:t4}=Array,{getPrototypeOf:n4,prototype:r4,keys:s4}=Object;function z1(n){if(1===n.length){const t=n[0];if(t4(t))return{args:t,keys:null};if(function o4(n){return n&&"object"==typeof n&&n4(n)===r4}(t)){const e=s4(t);return{args:e.map(r=>t[r]),keys:e}}}return{args:n,keys:null}}const{isArray:a4}=Array;function cx(n){return gt(t=>function l4(n,t){return a4(t)?n(...t):n(t)}(n,t))}function H1(n,t){return n.reduce((e,r,s)=>(e[r]=t[s],e),{})}function ry(...n){const t=$s(n),e=Aa(n),{args:r,keys:s}=z1(n);if(0===r.length)return pr([],t);const o=new Me(function c4(n,t,e=ze){return r=>{W1(t,()=>{const{length:s}=n,o=new Array(s);let i=s,a=s;for(let l=0;l<s;l++)W1(t,()=>{const c=pr(n[l],t);let u=!1;c.subscribe(Vt(r,d=>{o[l]=d,u||(u=!0,a--),a||r.next(e(o.slice()))},()=>{--i||r.complete()}))},r)},r)}}(r,t,s?i=>H1(s,i):ze));return e?o.pipe(cx(e)):o}function W1(n,t,e){n?Ps(e,n,t):t()}const sy=G(n=>function(){n(this),this.name="EmptyError",this.message="no elements in sequence"});function eh(...n){return function u4(){return ti(1)}()(pr(n,$s(n)))}function Qp(n){return new Me(t=>{Dr(n()).subscribe(t)})}function Mu(n,t){const e=xe(n)?n:()=>n,r=s=>s.error(e());return new Me(t?s=>t.schedule(r,0,s):r)}function ux(){return nn((n,t)=>{let e=null;n._refCount++;const r=Vt(t,void 0,void 0,void 0,()=>{if(!n||n._refCount<=0||0<--n._refCount)return void(e=null);const s=n._connection,o=e;e=null,s&&(!o||s===o)&&s.unsubscribe(),t.unsubscribe()});n.subscribe(r),r.closed||(e=n.connect())})}class dx extends Me{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,dn(t)&&(this.lift=t.lift)}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return(!t||t.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:t}=this;this._subject=this._connection=null,t?.unsubscribe()}connect(){let t=this._connection;if(!t){t=this._connection=new U;const e=this.getSubject();t.add(this.source.subscribe(Vt(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),t.closed&&(this._connection=null,t=U.EMPTY)}return t}refCount(){return ux()(this)}}function yi(n,t){return nn((e,r)=>{let s=null,o=0,i=!1;const a=()=>i&&!s&&r.complete();e.subscribe(Vt(r,l=>{s?.unsubscribe();let c=0;const u=o++;Dr(n(l,u)).subscribe(s=Vt(r,d=>r.next(t?t(l,d,u,c++):d),()=>{s=null,a()}))},()=>{i=!0,a()}))})}function Jr(n){return n<=0?()=>to:nn((t,e)=>{let r=0;t.subscribe(Vt(e,s=>{++r<=n&&(e.next(s),n<=r&&e.complete())}))})}function Jp(...n){const t=$s(n);return nn((e,r)=>{(t?eh(n,e,t):eh(n,e)).subscribe(r)})}function Or(n,t){return nn((e,r)=>{let s=0;e.subscribe(Vt(r,o=>n.call(t,o,s++)&&r.next(o)))})}function oy(n){return nn((t,e)=>{let r=!1;t.subscribe(Vt(e,s=>{r=!0,e.next(s)},()=>{r||e.next(n),e.complete()}))})}function j1(n=d4){return nn((t,e)=>{let r=!1;t.subscribe(Vt(e,s=>{r=!0,e.next(s)},()=>r?e.complete():e.error(n())))})}function d4(){return new sy}function Ru(n,t){const e=arguments.length>=2;return r=>r.pipe(n?Or((s,o)=>n(s,o,r)):ze,Jr(1),e?oy(t):j1(()=>new sy))}function th(n,t){return xe(t)?hr(n,t,1):hr(n,1)}function Es(n,t,e){const r=xe(n)||t||e?{next:n,error:t,complete:e}:n;return r?nn((s,o)=>{var i;null===(i=r.subscribe)||void 0===i||i.call(r);let a=!0;s.subscribe(Vt(o,l=>{var c;null===(c=r.next)||void 0===c||c.call(r,l),o.next(l)},()=>{var l;a=!1,null===(l=r.complete)||void 0===l||l.call(r),o.complete()},l=>{var c;a=!1,null===(c=r.error)||void 0===c||c.call(r,l),o.error(l)},()=>{var l,c;a&&(null===(l=r.unsubscribe)||void 0===l||l.call(r)),null===(c=r.finalize)||void 0===c||c.call(r)}))}):ze}function Rc(n){return nn((t,e)=>{let o,r=null,s=!1;r=t.subscribe(Vt(e,void 0,void 0,i=>{o=Dr(n(i,Rc(n)(t))),r?(r.unsubscribe(),r=null,o.subscribe(e)):s=!0})),s&&(r.unsubscribe(),r=null,o.subscribe(e))})}function hx(n){return n<=0?()=>to:nn((t,e)=>{let r=[];t.subscribe(Vt(e,s=>{r.push(s),n<r.length&&r.shift()},()=>{for(const s of r)e.next(s);e.complete()},void 0,()=>{r=null}))})}function iy(n){return gt(()=>n)}function ay(n){return nn((t,e)=>{try{t.subscribe(e)}finally{e.add(n)}})}const An="primary",ef=Symbol("RouteTitle");class m4{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function nh(n){return new m4(n)}function g4(n,t,e){const r=e.path.split("/");if(r.length>n.length||"full"===e.pathMatch&&(t.hasChildren()||r.length<n.length))return null;const s={};for(let o=0;o<r.length;o++){const i=r[o],a=n[o];if(i.startsWith(":"))s[i.substring(1)]=a;else if(i!==a.path)return null}return{consumed:n.slice(0,r.length),posParams:s}}function nl(n,t){const e=n?Object.keys(n):void 0,r=t?Object.keys(t):void 0;if(!e||!r||e.length!=r.length)return!1;let s;for(let o=0;o<e.length;o++)if(s=e[o],!G1(n[s],t[s]))return!1;return!0}function G1(n,t){if(Array.isArray(n)&&Array.isArray(t)){if(n.length!==t.length)return!1;const e=[...n].sort(),r=[...t].sort();return e.every((s,o)=>r[o]===s)}return n===t}function K1(n){return n.length>0?n[n.length-1]:null}function Oc(n){return function e4(n){return!!n&&(n instanceof Me||xe(n.lift)&&xe(n.subscribe))}(n)?n:$p(n)?pr(Promise.resolve(n)):sn(n)}const b4={exact:function Z1(n,t,e){if(!Ou(n.segments,t.segments)||!ly(n.segments,t.segments,e)||n.numberOfChildren!==t.numberOfChildren)return!1;for(const r in t.children)if(!n.children[r]||!Z1(n.children[r],t.children[r],e))return!1;return!0},subset:Y1},X1={exact:function _4(n,t){return nl(n,t)},subset:function v4(n,t){return Object.keys(t).length<=Object.keys(n).length&&Object.keys(t).every(e=>G1(n[e],t[e]))},ignored:()=>!0};function q1(n,t,e){return b4[e.paths](n.root,t.root,e.matrixParams)&&X1[e.queryParams](n.queryParams,t.queryParams)&&!("exact"===e.fragment&&n.fragment!==t.fragment)}function Y1(n,t,e){return Q1(n,t,t.segments,e)}function Q1(n,t,e,r){if(n.segments.length>e.length){const s=n.segments.slice(0,e.length);return!(!Ou(s,e)||t.hasChildren()||!ly(s,e,r))}if(n.segments.length===e.length){if(!Ou(n.segments,e)||!ly(n.segments,e,r))return!1;for(const s in t.children)if(!n.children[s]||!Y1(n.children[s],t.children[s],r))return!1;return!0}{const s=e.slice(0,n.segments.length),o=e.slice(n.segments.length);return!!(Ou(n.segments,s)&&ly(n.segments,s,r)&&n.children[An])&&Q1(n.children[An],t,o,r)}}function ly(n,t,e){return t.every((r,s)=>X1[e](n[s].parameters,r.parameters))}class rh{constructor(t=new lr([],{}),e={},r=null){this.root=t,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=nh(this.queryParams)),this._queryParamMap}toString(){return w4.serialize(this)}}class lr{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Object.values(e).forEach(r=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return cy(this)}}class tf{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=nh(this.parameters)),this._parameterMap}toString(){return tA(this)}}function Ou(n,t){return n.length===t.length&&n.every((e,r)=>e.path===t[r].path)}let nf=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:function(){return new px},providedIn:"root"}),n})();class px{parse(t){const e=new O4(t);return new rh(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){const e=`/${rf(t.root,!0)}`,r=function D4(n){const t=Object.keys(n).map(e=>{const r=n[e];return Array.isArray(r)?r.map(s=>`${uy(e)}=${uy(s)}`).join("&"):`${uy(e)}=${uy(r)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(t.queryParams);return`${e}${r}${"string"==typeof t.fragment?`#${function S4(n){return encodeURI(n)}(t.fragment)}`:""}`}}const w4=new px;function cy(n){return n.segments.map(t=>tA(t)).join("/")}function rf(n,t){if(!n.hasChildren())return cy(n);if(t){const e=n.children[An]?rf(n.children[An],!1):"",r=[];return Object.entries(n.children).forEach(([s,o])=>{s!==An&&r.push(`${s}:${rf(o,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function C4(n,t){let e=[];return Object.entries(n.children).forEach(([r,s])=>{r===An&&(e=e.concat(t(s,r)))}),Object.entries(n.children).forEach(([r,s])=>{r!==An&&(e=e.concat(t(s,r)))}),e}(n,(r,s)=>s===An?[rf(n.children[An],!1)]:[`${s}:${rf(r,!1)}`]);return 1===Object.keys(n.children).length&&null!=n.children[An]?`${cy(n)}/${e[0]}`:`${cy(n)}/(${e.join("//")})`}}function J1(n){return encodeURIComponent(n).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function uy(n){return J1(n).replace(/%3B/gi,";")}function fx(n){return J1(n).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function dy(n){return decodeURIComponent(n)}function eA(n){return dy(n.replace(/\+/g,"%20"))}function tA(n){return`${fx(n.path)}${function E4(n){return Object.keys(n).map(t=>`;${fx(t)}=${fx(n[t])}`).join("")}(n.parameters)}`}const T4=/^[^\/()?;#]+/;function mx(n){const t=n.match(T4);return t?t[0]:""}const I4=/^[^\/()?;=#]+/,N4=/^[^=?&#]+/,M4=/^[^&#]+/;class O4{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new lr([],{}):new lr([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(r[An]=new lr(t,e)),r}parseSegment(){const t=mx(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new qe(4009,!1);return this.capture(t),new tf(dy(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=function A4(n){const t=n.match(I4);return t?t[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const s=mx(this.remaining);s&&(r=s,this.capture(r))}t[dy(e)]=dy(r)}parseQueryParam(t){const e=function k4(n){const t=n.match(N4);return t?t[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const i=function R4(n){const t=n.match(M4);return t?t[0]:""}(this.remaining);i&&(r=i,this.capture(r))}const s=eA(e),o=eA(r);if(t.hasOwnProperty(s)){let i=t[s];Array.isArray(i)||(i=[i],t[s]=i),i.push(o)}else t[s]=o}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=mx(this.remaining),s=this.remaining[r.length];if("/"!==s&&")"!==s&&";"!==s)throw new qe(4010,!1);let o;r.indexOf(":")>-1?(o=r.slice(0,r.indexOf(":")),this.capture(o),this.capture(":")):t&&(o=An);const i=this.parseChildren();e[o]=1===Object.keys(i).length?i[An]:new lr([],i),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new qe(4011,!1)}}function nA(n){return n.segments.length>0?new lr([],{[An]:n}):n}function rA(n){const t={};for(const r of Object.keys(n.children)){const o=rA(n.children[r]);if(r===An&&0===o.segments.length&&o.hasChildren())for(const[i,a]of Object.entries(o.children))t[i]=a;else(o.segments.length>0||o.hasChildren())&&(t[r]=o)}return function F4(n){if(1===n.numberOfChildren&&n.children[An]){const t=n.children[An];return new lr(n.segments.concat(t.segments),t.children)}return n}(new lr(n.segments,t))}function Fu(n){return n instanceof rh}function sA(n){let t;const s=nA(function e(o){const i={};for(const l of o.children){const c=e(l);i[l.outlet]=c}const a=new lr(o.url,i);return o===n&&(t=a),a}(n.root));return t??s}function oA(n,t,e,r){let s=n;for(;s.parent;)s=s.parent;if(0===t.length)return gx(s,s,s,e,r);const o=function $4(n){if("string"==typeof n[0]&&1===n.length&&"/"===n[0])return new aA(!0,0,n);let t=0,e=!1;const r=n.reduce((s,o,i)=>{if("object"==typeof o&&null!=o){if(o.outlets){const a={};return Object.entries(o.outlets).forEach(([l,c])=>{a[l]="string"==typeof c?c.split("/"):c}),[...s,{outlets:a}]}if(o.segmentPath)return[...s,o.segmentPath]}return"string"!=typeof o?[...s,o]:0===i?(o.split("/").forEach((a,l)=>{0==l&&"."===a||(0==l&&""===a?e=!0:".."===a?t++:""!=a&&s.push(a))}),s):[...s,o]},[]);return new aA(e,t,r)}(t);if(o.toRoot())return gx(s,s,new lr([],{}),e,r);const i=function L4(n,t,e){if(n.isAbsolute)return new py(t,!0,0);if(!e)return new py(t,!1,NaN);if(null===e.parent)return new py(e,!0,0);const r=hy(n.commands[0])?0:1;return function B4(n,t,e){let r=n,s=t,o=e;for(;o>s;){if(o-=s,r=r.parent,!r)throw new qe(4005,!1);s=r.segments.length}return new py(r,!1,s-o)}(e,e.segments.length-1+r,n.numberOfDoubleDots)}(o,s,n),a=i.processChildren?af(i.segmentGroup,i.index,o.commands):lA(i.segmentGroup,i.index,o.commands);return gx(s,i.segmentGroup,a,e,r)}function hy(n){return"object"==typeof n&&null!=n&&!n.outlets&&!n.segmentPath}function sf(n){return"object"==typeof n&&null!=n&&n.outlets}function gx(n,t,e,r,s){let i,o={};r&&Object.entries(r).forEach(([l,c])=>{o[l]=Array.isArray(c)?c.map(u=>`${u}`):`${c}`}),i=n===t?e:iA(n,t,e);const a=nA(rA(i));return new rh(a,o,s)}function iA(n,t,e){const r={};return Object.entries(n.children).forEach(([s,o])=>{r[s]=o===t?e:iA(o,t,e)}),new lr(n.segments,r)}class aA{constructor(t,e,r){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=r,t&&r.length>0&&hy(r[0]))throw new qe(4003,!1);const s=r.find(sf);if(s&&s!==K1(r))throw new qe(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class py{constructor(t,e,r){this.segmentGroup=t,this.processChildren=e,this.index=r}}function lA(n,t,e){if(n||(n=new lr([],{})),0===n.segments.length&&n.hasChildren())return af(n,t,e);const r=function U4(n,t,e){let r=0,s=t;const o={match:!1,pathIndex:0,commandIndex:0};for(;s<n.segments.length;){if(r>=e.length)return o;const i=n.segments[s],a=e[r];if(sf(a))break;const l=`${a}`,c=r<e.length-1?e[r+1]:null;if(s>0&&void 0===l)break;if(l&&c&&"object"==typeof c&&void 0===c.outlets){if(!uA(l,c,i))return o;r+=2}else{if(!uA(l,{},i))return o;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(n,t,e),s=e.slice(r.commandIndex);if(r.match&&r.pathIndex<n.segments.length){const o=new lr(n.segments.slice(0,r.pathIndex),{});return o.children[An]=new lr(n.segments.slice(r.pathIndex),n.children),af(o,0,s)}return r.match&&0===s.length?new lr(n.segments,{}):r.match&&!n.hasChildren()?yx(n,t,e):r.match?af(n,0,s):yx(n,t,e)}function af(n,t,e){if(0===e.length)return new lr(n.segments,{});{const r=function V4(n){return sf(n[0])?n[0].outlets:{[An]:n}}(e),s={};if(!r[An]&&n.children[An]&&1===n.numberOfChildren&&0===n.children[An].segments.length){const o=af(n.children[An],t,e);return new lr(n.segments,o.children)}return Object.entries(r).forEach(([o,i])=>{"string"==typeof i&&(i=[i]),null!==i&&(s[o]=lA(n.children[o],t,i))}),Object.entries(n.children).forEach(([o,i])=>{void 0===r[o]&&(s[o]=i)}),new lr(n.segments,s)}}function yx(n,t,e){const r=n.segments.slice(0,t);let s=0;for(;s<e.length;){const o=e[s];if(sf(o)){const l=z4(o.outlets);return new lr(r,l)}if(0===s&&hy(e[0])){r.push(new tf(n.segments[t].path,cA(e[0]))),s++;continue}const i=sf(o)?o.outlets[An]:`${o}`,a=s<e.length-1?e[s+1]:null;i&&a&&hy(a)?(r.push(new tf(i,cA(a))),s+=2):(r.push(new tf(i,{})),s++)}return new lr(r,{})}function z4(n){const t={};return Object.entries(n).forEach(([e,r])=>{"string"==typeof r&&(r=[r]),null!==r&&(t[e]=yx(new lr([],{}),0,r))}),t}function cA(n){const t={};return Object.entries(n).forEach(([e,r])=>t[e]=`${r}`),t}function uA(n,t,e){return n==e.path&&nl(t,e.parameters)}const lf="imperative";class rl{constructor(t,e){this.id=t,this.url=e}}class bx extends rl{constructor(t,e,r="imperative",s=null){super(t,e),this.type=0,this.navigationTrigger=r,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Pu extends rl{constructor(t,e,r){super(t,e),this.urlAfterRedirects=r,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class fy extends rl{constructor(t,e,r,s){super(t,e),this.reason=r,this.code=s,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class cf extends rl{constructor(t,e,r,s){super(t,e),this.reason=r,this.code=s,this.type=16}}class _x extends rl{constructor(t,e,r,s){super(t,e),this.error=r,this.target=s,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class H4 extends rl{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class W4 extends rl{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class j4 extends rl{constructor(t,e,r,s,o){super(t,e),this.urlAfterRedirects=r,this.state=s,this.shouldActivate=o,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class G4 extends rl{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class K4 extends rl{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class X4{constructor(t){this.route=t,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class q4{constructor(t){this.route=t,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class Z4{constructor(t){this.snapshot=t,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Y4{constructor(t){this.snapshot=t,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Q4{constructor(t){this.snapshot=t,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class J4{constructor(t){this.snapshot=t,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class dA{constructor(t,e,r){this.routerEvent=t,this.position=e,this.anchor=r,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class eW{constructor(){this.outlet=null,this.route=null,this.injector=null,this.children=new uf,this.attachRef=null}}let uf=(()=>{class n{constructor(){this.contexts=new Map}onChildOutletCreated(e,r){const s=this.getOrCreateContext(e);s.outlet=r,this.contexts.set(e,s)}onChildOutletDestroyed(e){const r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new eW,this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class hA{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=vx(t,this._root);return e?e.children.map(r=>r.value):[]}firstChild(t){const e=vx(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=xx(t,this._root);return e.length<2?[]:e[e.length-2].children.map(s=>s.value).filter(s=>s!==t)}pathFromRoot(t){return xx(t,this._root).map(e=>e.value)}}function vx(n,t){if(n===t.value)return t;for(const e of t.children){const r=vx(n,e);if(r)return r}return null}function xx(n,t){if(n===t.value)return[t];for(const e of t.children){const r=xx(n,e);if(r.length)return r.unshift(t),r}return[]}class Ul{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function sh(n){const t={};return n&&n.children.forEach(e=>t[e.value.outlet]=e),t}class pA extends hA{constructor(t,e){super(t),this.snapshot=e,Cx(this,t)}toString(){return this.snapshot.toString()}}function fA(n,t){const e=function tW(n,t){const i=new my([],{},{},"",{},An,t,null,{});return new gA("",new Ul(i,[]))}(0,t),r=new Vi([new tf("",{})]),s=new Vi({}),o=new Vi({}),i=new Vi({}),a=new Vi(""),l=new oh(r,s,i,a,o,An,t,e.root);return l.snapshot=e.root,new pA(new Ul(l,[]),e)}class oh{constructor(t,e,r,s,o,i,a,l){this.urlSubject=t,this.paramsSubject=e,this.queryParamsSubject=r,this.fragmentSubject=s,this.dataSubject=o,this.outlet=i,this.component=a,this._futureSnapshot=l,this.title=this.dataSubject?.pipe(gt(c=>c[ef]))??sn(void 0),this.url=t,this.params=e,this.queryParams=r,this.fragment=s,this.data=o}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(gt(t=>nh(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(gt(t=>nh(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function mA(n,t="emptyOnly"){const e=n.pathFromRoot;let r=0;if("always"!==t)for(r=e.length-1;r>=1;){const s=e[r],o=e[r-1];if(s.routeConfig&&""===s.routeConfig.path)r--;else{if(o.component)break;r--}}return function nW(n){return n.reduce((t,e)=>({params:{...t.params,...e.params},data:{...t.data,...e.data},resolve:{...e.data,...t.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(r))}class my{get title(){return this.data?.[ef]}constructor(t,e,r,s,o,i,a,l,c){this.url=t,this.params=e,this.queryParams=r,this.fragment=s,this.data=o,this.outlet=i,this.component=a,this.routeConfig=l,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=nh(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=nh(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class gA extends hA{constructor(t,e){super(e),this.url=t,Cx(this,e)}toString(){return yA(this._root)}}function Cx(n,t){t.value._routerState=n,t.children.forEach(e=>Cx(n,e))}function yA(n){const t=n.children.length>0?` { ${n.children.map(yA).join(", ")} } `:"";return`${n.value}${t}`}function wx(n){if(n.snapshot){const t=n.snapshot,e=n._futureSnapshot;n.snapshot=e,nl(t.queryParams,e.queryParams)||n.queryParamsSubject.next(e.queryParams),t.fragment!==e.fragment&&n.fragmentSubject.next(e.fragment),nl(t.params,e.params)||n.paramsSubject.next(e.params),function y4(n,t){if(n.length!==t.length)return!1;for(let e=0;e<n.length;++e)if(!nl(n[e],t[e]))return!1;return!0}(t.url,e.url)||n.urlSubject.next(e.url),nl(t.data,e.data)||n.dataSubject.next(e.data)}else n.snapshot=n._futureSnapshot,n.dataSubject.next(n._futureSnapshot.data)}function Sx(n,t){const e=nl(n.params,t.params)&&function x4(n,t){return Ou(n,t)&&n.every((e,r)=>nl(e.parameters,t[r].parameters))}(n.url,t.url);return e&&!(!n.parent!=!t.parent)&&(!n.parent||Sx(n.parent,t.parent))}let bA=(()=>{class n{constructor(){this.activated=null,this._activatedRoute=null,this.name=An,this.activateEvents=new nr,this.deactivateEvents=new nr,this.attachEvents=new nr,this.detachEvents=new nr,this.parentContexts=Ft(uf),this.location=Ft(fi),this.changeDetector=Ft(tl),this.environmentInjector=Ft(kl),this.inputBinder=Ft(gy,{optional:!0}),this.supportsBindingToComponentInputs=!0}get activatedComponentRef(){return this.activated}ngOnChanges(e){if(e.name){const{firstChange:r,previousValue:s}=e.name;if(r)return;this.isTrackedInParentContexts(s)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(s)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name),this.inputBinder?.unsubscribeFromRouteData(this)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new qe(4012,!1);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new qe(4012,!1);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new qe(4012,!1);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new qe(4013,!1);this._activatedRoute=e;const s=this.location,i=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,l=new rW(e,a,s.injector);this.activated=s.createComponent(i,{index:s.length,injector:l,environmentInjector:r??this.environmentInjector}),this.changeDetector.markForCheck(),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.activateEvents.emit(this.activated.instance)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=It({type:n,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[ao]}),n})();class rW{constructor(t,e,r){this.route=t,this.childContexts=e,this.parent=r}get(t,e){return t===oh?this.route:t===uf?this.childContexts:this.parent.get(t,e)}}const gy=new Ct("");let _A=(()=>{class n{constructor(){this.outletDataSubscriptions=new Map}bindActivatedRouteToOutletComponent(e){this.unsubscribeFromRouteData(e),this.subscribeToRouteData(e)}unsubscribeFromRouteData(e){this.outletDataSubscriptions.get(e)?.unsubscribe(),this.outletDataSubscriptions.delete(e)}subscribeToRouteData(e){const{activatedRoute:r}=e,s=ry([r.queryParams,r.params,r.data]).pipe(yi(([o,i,a],l)=>(a={...o,...i,...a},0===l?sn(a):Promise.resolve(a)))).subscribe(o=>{if(!e.isActivated||!e.activatedComponentRef||e.activatedRoute!==r||null===r.component)return void this.unsubscribeFromRouteData(e);const i=function TU(n){const t=jn(n);if(!t)return null;const e=new Mp(t);return{get selector(){return e.selector},get type(){return e.componentType},get inputs(){return e.inputs},get outputs(){return e.outputs},get ngContentSelectors(){return e.ngContentSelectors},get isStandalone(){return t.standalone}}}(r.component);if(i)for(const{templateName:a}of i.inputs)e.activatedComponentRef.setInput(a,o[a]);else this.unsubscribeFromRouteData(e)});this.outletDataSubscriptions.set(e,s)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})();function df(n,t,e){if(e&&n.shouldReuseRoute(t.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=t.value;const s=function oW(n,t,e){return t.children.map(r=>{for(const s of e.children)if(n.shouldReuseRoute(r.value,s.value.snapshot))return df(n,r,s);return df(n,r)})}(n,t,e);return new Ul(r,s)}{if(n.shouldAttach(t.value)){const o=n.retrieve(t.value);if(null!==o){const i=o.route;return i.value._futureSnapshot=t.value,i.children=t.children.map(a=>df(n,a)),i}}const r=function iW(n){return new oh(new Vi(n.url),new Vi(n.params),new Vi(n.queryParams),new Vi(n.fragment),new Vi(n.data),n.outlet,n.component,n)}(t.value),s=t.children.map(o=>df(n,o));return new Ul(r,s)}}const Ex="ngNavigationCancelingError";function vA(n,t){const{redirectTo:e,navigationBehaviorOptions:r}=Fu(t)?{redirectTo:t,navigationBehaviorOptions:void 0}:t,s=xA(!1,0,t);return s.url=e,s.navigationBehaviorOptions=r,s}function xA(n,t,e){const r=new Error("NavigationCancelingError: "+(n||""));return r[Ex]=!0,r.cancellationCode=t,e&&(r.url=e),r}function CA(n){return wA(n)&&Fu(n.url)}function wA(n){return n&&n[Ex]}let SA=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=ys({type:n,selectors:[["ng-component"]],standalone:!0,features:[ST],decls:1,vars:0,template:function(e,r){1&e&&Za(0,"router-outlet")},dependencies:[bA],encapsulation:2}),n})();function Dx(n){const t=n.children&&n.children.map(Dx),e=t?{...n,children:t}:{...n};return!e.component&&!e.loadComponent&&(t||e.loadChildren)&&e.outlet&&e.outlet!==An&&(e.component=SA),e}function va(n){return n.outlet||An}function hf(n){if(!n)return null;if(n.routeConfig?._injector)return n.routeConfig._injector;for(let t=n.parent;t;t=t.parent){const e=t.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class pW{constructor(t,e,r,s,o){this.routeReuseStrategy=t,this.futureState=e,this.currState=r,this.forwardEvent=s,this.inputBindingEnabled=o}activate(t){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,t),wx(this.futureState.root),this.activateChildRoutes(e,r,t)}deactivateChildRoutes(t,e,r){const s=sh(e);t.children.forEach(o=>{const i=o.value.outlet;this.deactivateRoutes(o,s[i],r),delete s[i]}),Object.values(s).forEach(o=>{this.deactivateRouteAndItsChildren(o,r)})}deactivateRoutes(t,e,r){const s=t.value,o=e?e.value:null;if(s===o)if(s.component){const i=r.getContext(s.outlet);i&&this.deactivateChildRoutes(t,e,i.children)}else this.deactivateChildRoutes(t,e,r);else o&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(t,e){t.value.component&&this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const r=e.getContext(t.value.outlet),s=r&&t.value.component?r.children:e,o=sh(t);for(const i of Object.keys(o))this.deactivateRouteAndItsChildren(o[i],s);if(r&&r.outlet){const i=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:i,route:t,contexts:a})}}deactivateRouteAndOutlet(t,e){const r=e.getContext(t.value.outlet),s=r&&t.value.component?r.children:e,o=sh(t);for(const i of Object.keys(o))this.deactivateRouteAndItsChildren(o[i],s);r&&(r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated()),r.attachRef=null,r.route=null)}activateChildRoutes(t,e,r){const s=sh(e);t.children.forEach(o=>{this.activateRoutes(o,s[o.value.outlet],r),this.forwardEvent(new J4(o.value.snapshot))}),t.children.length&&this.forwardEvent(new Y4(t.value.snapshot))}activateRoutes(t,e,r){const s=t.value,o=e?e.value:null;if(wx(s),s===o)if(s.component){const i=r.getOrCreateContext(s.outlet);this.activateChildRoutes(t,e,i.children)}else this.activateChildRoutes(t,e,r);else if(s.component){const i=r.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const a=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),i.children.onOutletReAttached(a.contexts),i.attachRef=a.componentRef,i.route=a.route.value,i.outlet&&i.outlet.attach(a.componentRef,a.route.value),wx(a.route.value),this.activateChildRoutes(t,null,i.children)}else{const a=hf(s.snapshot);i.attachRef=null,i.route=s,i.injector=a,i.outlet&&i.outlet.activateWith(s,i.injector),this.activateChildRoutes(t,null,i.children)}}else this.activateChildRoutes(t,null,r)}}class EA{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class yy{constructor(t,e){this.component=t,this.route=e}}function fW(n,t,e){const r=n._root;return pf(r,t?t._root:null,e,[r.value])}function ih(n,t){const e=Symbol(),r=t.get(n,e);return r===e?"function"!=typeof n||function J(n){return null!==ne(n)}(n)?t.get(n):n:r}function pf(n,t,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=sh(t);return n.children.forEach(i=>{(function gW(n,t,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=n.value,i=t?t.value:null,a=e?e.getContext(n.value.outlet):null;if(i&&o.routeConfig===i.routeConfig){const l=function yW(n,t,e){if("function"==typeof e)return e(n,t);switch(e){case"pathParamsChange":return!Ou(n.url,t.url);case"pathParamsOrQueryParamsChange":return!Ou(n.url,t.url)||!nl(n.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!Sx(n,t)||!nl(n.queryParams,t.queryParams);default:return!Sx(n,t)}}(i,o,o.routeConfig.runGuardsAndResolvers);l?s.canActivateChecks.push(new EA(r)):(o.data=i.data,o._resolvedData=i._resolvedData),pf(n,t,o.component?a?a.children:null:e,r,s),l&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new yy(a.outlet.component,i))}else i&&ff(t,a,s),s.canActivateChecks.push(new EA(r)),pf(n,null,o.component?a?a.children:null:e,r,s)})(i,o[i.value.outlet],e,r.concat([i.value]),s),delete o[i.value.outlet]}),Object.entries(o).forEach(([i,a])=>ff(a,e.getContext(i),s)),s}function ff(n,t,e){const r=sh(n),s=n.value;Object.entries(r).forEach(([o,i])=>{ff(i,s.component?t?t.children.getContext(o):null:t,e)}),e.canDeactivateChecks.push(new yy(s.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,s))}function mf(n){return"function"==typeof n}function DA(n){return n instanceof sy||"EmptyError"===n?.name}const by=Symbol("INITIAL_VALUE");function ah(){return yi(n=>ry(n.map(t=>t.pipe(Jr(1),Jp(by)))).pipe(gt(t=>{for(const e of t)if(!0!==e){if(e===by)return by;if(!1===e||e instanceof rh)return e}return!0}),Or(t=>t!==by),Jr(1)))}function TA(n){return function ye(...n){return ve(n)}(Es(t=>{if(Fu(t))throw vA(0,t)}),gt(t=>!0===t))}class _y{constructor(t){this.segmentGroup=t||null}}class IA{constructor(t){this.urlTree=t}}function lh(n){return Mu(new _y(n))}function AA(n){return Mu(new IA(n))}class $W{constructor(t,e){this.urlSerializer=t,this.urlTree=e}noMatchError(t){return new qe(4002,!1)}lineralizeSegments(t,e){let r=[],s=e.root;for(;;){if(r=r.concat(s.segments),0===s.numberOfChildren)return sn(r);if(s.numberOfChildren>1||!s.children[An])return Mu(new qe(4e3,!1));s=s.children[An]}}applyRedirectCommands(t,e,r){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),t,r)}applyRedirectCreateUrlTree(t,e,r,s){const o=this.createSegmentGroup(t,e.root,r,s);return new rh(o,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const r={};return Object.entries(t).forEach(([s,o])=>{if("string"==typeof o&&o.startsWith(":")){const a=o.substring(1);r[s]=e[a]}else r[s]=o}),r}createSegmentGroup(t,e,r,s){const o=this.createSegments(t,e.segments,r,s);let i={};return Object.entries(e.children).forEach(([a,l])=>{i[a]=this.createSegmentGroup(t,l,r,s)}),new lr(o,i)}createSegments(t,e,r,s){return e.map(o=>o.path.startsWith(":")?this.findPosParam(t,o,s):this.findOrReturn(o,r))}findPosParam(t,e,r){const s=r[e.path.substring(1)];if(!s)throw new qe(4001,!1);return s}findOrReturn(t,e){let r=0;for(const s of e){if(s.path===t.path)return e.splice(r),s;r++}return t}}const Tx={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function LW(n,t,e,r,s){const o=Ix(n,t,e);return o.matched?(r=function aW(n,t){return n.providers&&!n._injector&&(n._injector=t0(n.providers,t,`Route: ${n.path}`)),n._injector??t}(t,r),function OW(n,t,e,r){const s=t.canMatch;return s&&0!==s.length?sn(s.map(i=>{const a=ih(i,n);return Oc(function wW(n){return n&&mf(n.canMatch)}(a)?a.canMatch(t,e):n.runInContext(()=>a(t,e)))})).pipe(ah(),TA()):sn(!0)}(r,t,e).pipe(gt(i=>!0===i?o:{...Tx}))):sn(o)}function Ix(n,t,e){if(""===t.path)return"full"===t.pathMatch&&(n.hasChildren()||e.length>0)?{...Tx}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const s=(t.matcher||g4)(e,n,t);if(!s)return{...Tx};const o={};Object.entries(s.posParams??{}).forEach(([a,l])=>{o[a]=l.path});const i=s.consumed.length>0?{...o,...s.consumed[s.consumed.length-1].parameters}:o;return{matched:!0,consumedSegments:s.consumed,remainingSegments:e.slice(s.consumed.length),parameters:i,positionalParamSegments:s.posParams??{}}}function NA(n,t,e,r){return e.length>0&&function UW(n,t,e){return e.some(r=>vy(n,t,r)&&va(r)!==An)}(n,e,r)?{segmentGroup:new lr(t,VW(r,new lr(e,n.children))),slicedSegments:[]}:0===e.length&&function zW(n,t,e){return e.some(r=>vy(n,t,r))}(n,e,r)?{segmentGroup:new lr(n.segments,BW(n,0,e,r,n.children)),slicedSegments:e}:{segmentGroup:new lr(n.segments,n.children),slicedSegments:e}}function BW(n,t,e,r,s){const o={};for(const i of r)if(vy(n,e,i)&&!s[va(i)]){const a=new lr([],{});o[va(i)]=a}return{...s,...o}}function VW(n,t){const e={};e[An]=t;for(const r of n)if(""===r.path&&va(r)!==An){const s=new lr([],{});e[va(r)]=s}return e}function vy(n,t,e){return(!(n.hasChildren()||t.length>0)||"full"!==e.pathMatch)&&""===e.path}class GW{constructor(t,e,r,s,o,i,a){this.injector=t,this.configLoader=e,this.rootComponentType=r,this.config=s,this.urlTree=o,this.paramsInheritanceStrategy=i,this.urlSerializer=a,this.allowRedirects=!0,this.applyRedirects=new $W(this.urlSerializer,this.urlTree)}noMatchError(t){return new qe(4002,!1)}recognize(){const t=NA(this.urlTree.root,[],[],this.config).segmentGroup;return this.processSegmentGroup(this.injector,this.config,t,An).pipe(Rc(e=>{if(e instanceof IA)return this.allowRedirects=!1,this.urlTree=e.urlTree,this.match(e.urlTree);throw e instanceof _y?this.noMatchError(e):e}),gt(e=>{const r=new my([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},An,this.rootComponentType,null,{}),s=new Ul(r,e),o=new gA("",s),i=function P4(n,t,e=null,r=null){return oA(sA(n),t,e,r)}(r,[],this.urlTree.queryParams,this.urlTree.fragment);return i.queryParams=this.urlTree.queryParams,o.url=this.urlSerializer.serialize(i),this.inheritParamsAndData(o._root),{state:o,tree:i}}))}match(t){return this.processSegmentGroup(this.injector,this.config,t.root,An).pipe(Rc(r=>{throw r instanceof _y?this.noMatchError(r):r}))}inheritParamsAndData(t){const e=t.value,r=mA(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),t.children.forEach(s=>this.inheritParamsAndData(s))}processSegmentGroup(t,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.processChildren(t,e,r):this.processSegment(t,e,r,r.segments,s,!0)}processChildren(t,e,r){const s=[];for(const o of Object.keys(r.children))"primary"===o?s.unshift(o):s.push(o);return pr(s).pipe(th(o=>{const i=r.children[o],a=function dW(n,t){const e=n.filter(r=>va(r)===t);return e.push(...n.filter(r=>va(r)!==t)),e}(e,o);return this.processSegmentGroup(t,a,i,o)}),function p4(n,t){return nn(function h4(n,t,e,r,s){return(o,i)=>{let a=e,l=t,c=0;o.subscribe(Vt(i,u=>{const d=c++;l=a?n(l,u,d):(a=!0,u),r&&i.next(l)},s&&(()=>{a&&i.next(l),i.complete()})))}}(n,t,arguments.length>=2,!0))}((o,i)=>(o.push(...i),o)),oy(null),function f4(n,t){const e=arguments.length>=2;return r=>r.pipe(n?Or((s,o)=>n(s,o,r)):ze,hx(1),e?oy(t):j1(()=>new sy))}(),hr(o=>{if(null===o)return lh(r);const i=kA(o);return function KW(n){n.sort((t,e)=>t.value.outlet===An?-1:e.value.outlet===An?1:t.value.outlet.localeCompare(e.value.outlet))}(i),sn(i)}))}processSegment(t,e,r,s,o,i){return pr(e).pipe(th(a=>this.processSegmentAgainstRoute(a._injector??t,e,a,r,s,o,i).pipe(Rc(l=>{if(l instanceof _y)return sn(null);throw l}))),Ru(a=>!!a),Rc(a=>{if(DA(a))return function WW(n,t,e){return 0===t.length&&!n.children[e]}(r,s,o)?sn([]):lh(r);throw a}))}processSegmentAgainstRoute(t,e,r,s,o,i,a){return function HW(n,t,e,r){return!!(va(n)===r||r!==An&&vy(t,e,n))&&("**"===n.path||Ix(t,n,e).matched)}(r,s,o,i)?void 0===r.redirectTo?this.matchSegmentAgainstRoute(t,s,r,o,i,a):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,s,e,r,o,i):lh(s):lh(s)}expandSegmentAgainstRouteUsingRedirect(t,e,r,s,o,i){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,r,s,i):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,s,o,i)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,r,s){const o=this.applyRedirects.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?AA(o):this.applyRedirects.lineralizeSegments(r,o).pipe(hr(i=>{const a=new lr(i,{});return this.processSegment(t,e,a,i,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,s,o,i){const{matched:a,consumedSegments:l,remainingSegments:c,positionalParamSegments:u}=Ix(e,s,o);if(!a)return lh(e);const d=this.applyRedirects.applyRedirectCommands(l,s.redirectTo,u);return s.redirectTo.startsWith("/")?AA(d):this.applyRedirects.lineralizeSegments(s,d).pipe(hr(p=>this.processSegment(t,r,e,p.concat(c),i,!1)))}matchSegmentAgainstRoute(t,e,r,s,o,i){let a;if("**"===r.path){const l=s.length>0?K1(s).parameters:{};a=sn({snapshot:new my(s,l,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,MA(r),va(r),r.component??r._loadedComponent??null,r,RA(r)),consumedSegments:[],remainingSegments:[]}),e.children={}}else a=LW(e,r,s,t).pipe(gt(({matched:l,consumedSegments:c,remainingSegments:u,parameters:d})=>l?{snapshot:new my(c,d,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,MA(r),va(r),r.component??r._loadedComponent??null,r,RA(r)),consumedSegments:c,remainingSegments:u}:null));return a.pipe(yi(l=>null===l?lh(e):this.getChildConfig(t=r._injector??t,r,s).pipe(yi(({routes:c})=>{const u=r._loadedInjector??t,{snapshot:d,consumedSegments:p,remainingSegments:m}=l,{segmentGroup:y,slicedSegments:_}=NA(e,p,m,c);if(0===_.length&&y.hasChildren())return this.processChildren(u,c,y).pipe(gt(D=>null===D?null:[new Ul(d,D)]));if(0===c.length&&0===_.length)return sn([new Ul(d,[])]);const C=va(r)===o;return this.processSegment(u,c,y,_,C?An:o,!0).pipe(gt(D=>[new Ul(d,D)]))}))))}getChildConfig(t,e,r){return e.children?sn({routes:e.children,injector:t}):e.loadChildren?void 0!==e._loadedRoutes?sn({routes:e._loadedRoutes,injector:e._loadedInjector}):function RW(n,t,e,r){const s=t.canLoad;return void 0===s||0===s.length?sn(!0):sn(s.map(i=>{const a=ih(i,n);return Oc(function _W(n){return n&&mf(n.canLoad)}(a)?a.canLoad(t,e):n.runInContext(()=>a(t,e)))})).pipe(ah(),TA())}(t,e,r).pipe(hr(s=>s?this.configLoader.loadChildren(t,e).pipe(Es(o=>{e._loadedRoutes=o.routes,e._loadedInjector=o.injector})):function PW(n){return Mu(xA(!1,3))}())):sn({routes:[],injector:t})}}function XW(n){const t=n.value.routeConfig;return t&&""===t.path}function kA(n){const t=[],e=new Set;for(const r of n){if(!XW(r)){t.push(r);continue}const s=t.find(o=>r.value.routeConfig===o.value.routeConfig);void 0!==s?(s.children.push(...r.children),e.add(s)):t.push(r)}for(const r of e){const s=kA(r.children);t.push(new Ul(r.value,s))}return t.filter(r=>!e.has(r))}function MA(n){return n.data||{}}function RA(n){return n.resolve||{}}function OA(n){return"string"==typeof n.title||null===n.title}function Ax(n){return yi(t=>{const e=n(t);return e?pr(e).pipe(gt(()=>t)):sn(t)})}const ch=new Ct("ROUTES");let Nx=(()=>{class n{constructor(){this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap,this.compiler=Ft(hI)}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return sn(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const r=Oc(e.loadComponent()).pipe(gt(FA),Es(o=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=o}),ay(()=>{this.componentLoaders.delete(e)})),s=new dx(r,()=>new et).pipe(ux());return this.componentLoaders.set(e,s),s}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return sn({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const o=this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(gt(a=>{this.onLoadEndListener&&this.onLoadEndListener(r);let l,c;return Array.isArray(a)?c=a:(l=a.create(e).injector,c=l.get(ch,[],Dt.Self|Dt.Optional).flat()),{routes:c.map(Dx),injector:l}}),ay(()=>{this.childrenLoaders.delete(r)})),i=new dx(o,()=>new et).pipe(ux());return this.childrenLoaders.set(r,i),i}loadModuleFactoryOrRoutes(e){return Oc(e()).pipe(gt(FA),hr(r=>r instanceof CT||Array.isArray(r)?sn(r):pr(this.compiler.compileModuleAsync(r))))}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function FA(n){return function tj(n){return n&&"object"==typeof n&&"default"in n}(n)?n.default:n}let xy=(()=>{class n{get hasRequestedNavigation(){return 0!==this.navigationId}constructor(){this.currentNavigation=null,this.lastSuccessfulNavigation=null,this.events=new et,this.configLoader=Ft(Nx),this.environmentInjector=Ft(kl),this.urlSerializer=Ft(nf),this.rootContexts=Ft(uf),this.inputBindingEnabled=null!==Ft(gy,{optional:!0}),this.navigationId=0,this.afterPreactivation=()=>sn(void 0),this.rootComponentType=null,this.configLoader.onLoadEndListener=s=>this.events.next(new q4(s)),this.configLoader.onLoadStartListener=s=>this.events.next(new X4(s))}complete(){this.transitions?.complete()}handleNavigationRequest(e){const r=++this.navigationId;this.transitions?.next({...this.transitions.value,...e,id:r})}setupNavigations(e){return this.transitions=new Vi({id:0,currentUrlTree:e.currentUrlTree,currentRawUrl:e.currentUrlTree,extractedUrl:e.urlHandlingStrategy.extract(e.currentUrlTree),urlAfterRedirects:e.urlHandlingStrategy.extract(e.currentUrlTree),rawUrl:e.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:lf,restoredState:null,currentSnapshot:e.routerState.snapshot,targetSnapshot:null,currentRouterState:e.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(Or(r=>0!==r.id),gt(r=>({...r,extractedUrl:e.urlHandlingStrategy.extract(r.rawUrl)})),yi(r=>{let s=!1,o=!1;return sn(r).pipe(Es(i=>{this.currentNavigation={id:i.id,initialUrl:i.rawUrl,extractedUrl:i.extractedUrl,trigger:i.source,extras:i.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null}}),yi(i=>{const a=e.browserUrlTree.toString(),l=!e.navigated||i.extractedUrl.toString()!==a||a!==e.currentUrlTree.toString();if(!l&&"reload"!==(i.extras.onSameUrlNavigation??e.onSameUrlNavigation)){const u="";return this.events.next(new cf(i.id,e.serializeUrl(r.rawUrl),u,0)),e.rawUrlTree=i.rawUrl,i.resolve(null),to}if(e.urlHandlingStrategy.shouldProcessUrl(i.rawUrl))return PA(i.source)&&(e.browserUrlTree=i.extractedUrl),sn(i).pipe(yi(u=>{const d=this.transitions?.getValue();return this.events.next(new bx(u.id,this.urlSerializer.serialize(u.extractedUrl),u.source,u.restoredState)),d!==this.transitions?.getValue()?to:Promise.resolve(u)}),function qW(n,t,e,r,s,o){return hr(i=>function jW(n,t,e,r,s,o,i="emptyOnly"){return new GW(n,t,e,r,s,i,o).recognize()}(n,t,e,r,i.extractedUrl,s,o).pipe(gt(({state:a,tree:l})=>({...i,targetSnapshot:a,urlAfterRedirects:l}))))}(this.environmentInjector,this.configLoader,this.rootComponentType,e.config,this.urlSerializer,e.paramsInheritanceStrategy),Es(u=>{if(r.targetSnapshot=u.targetSnapshot,r.urlAfterRedirects=u.urlAfterRedirects,this.currentNavigation={...this.currentNavigation,finalUrl:u.urlAfterRedirects},"eager"===e.urlUpdateStrategy){if(!u.extras.skipLocationChange){const p=e.urlHandlingStrategy.merge(u.urlAfterRedirects,u.rawUrl);e.setBrowserUrl(p,u)}e.browserUrlTree=u.urlAfterRedirects}const d=new H4(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot);this.events.next(d)}));if(l&&e.urlHandlingStrategy.shouldProcessUrl(e.rawUrlTree)){const{id:u,extractedUrl:d,source:p,restoredState:m,extras:y}=i,_=new bx(u,this.urlSerializer.serialize(d),p,m);this.events.next(_);const C=fA(0,this.rootComponentType).snapshot;return sn(r={...i,targetSnapshot:C,urlAfterRedirects:d,extras:{...y,skipLocationChange:!1,replaceUrl:!1}})}{const u="";return this.events.next(new cf(i.id,e.serializeUrl(r.extractedUrl),u,1)),e.rawUrlTree=i.rawUrl,i.resolve(null),to}}),Es(i=>{const a=new W4(i.id,this.urlSerializer.serialize(i.extractedUrl),this.urlSerializer.serialize(i.urlAfterRedirects),i.targetSnapshot);this.events.next(a)}),gt(i=>r={...i,guards:fW(i.targetSnapshot,i.currentSnapshot,this.rootContexts)}),function EW(n,t){return hr(e=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:o,canDeactivateChecks:i}}=e;return 0===i.length&&0===o.length?sn({...e,guardsResult:!0}):function DW(n,t,e,r){return pr(n).pipe(hr(s=>function MW(n,t,e,r,s){const o=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return o&&0!==o.length?sn(o.map(a=>{const l=hf(t)??s,c=ih(a,l);return Oc(function CW(n){return n&&mf(n.canDeactivate)}(c)?c.canDeactivate(n,t,e,r):l.runInContext(()=>c(n,t,e,r))).pipe(Ru())})).pipe(ah()):sn(!0)}(s.component,s.route,e,t,r)),Ru(s=>!0!==s,!0))}(i,r,s,n).pipe(hr(a=>a&&function bW(n){return"boolean"==typeof n}(a)?function TW(n,t,e,r){return pr(t).pipe(th(s=>eh(function AW(n,t){return null!==n&&t&&t(new Z4(n)),sn(!0)}(s.route.parent,r),function IW(n,t){return null!==n&&t&&t(new Q4(n)),sn(!0)}(s.route,r),function kW(n,t,e){const r=t[t.length-1],o=t.slice(0,t.length-1).reverse().map(i=>function mW(n){const t=n.routeConfig?n.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:n,guards:t}:null}(i)).filter(i=>null!==i).map(i=>Qp(()=>sn(i.guards.map(l=>{const c=hf(i.node)??e,u=ih(l,c);return Oc(function xW(n){return n&&mf(n.canActivateChild)}(u)?u.canActivateChild(r,n):c.runInContext(()=>u(r,n))).pipe(Ru())})).pipe(ah())));return sn(o).pipe(ah())}(n,s.path,e),function NW(n,t,e){const r=t.routeConfig?t.routeConfig.canActivate:null;if(!r||0===r.length)return sn(!0);const s=r.map(o=>Qp(()=>{const i=hf(t)??e,a=ih(o,i);return Oc(function vW(n){return n&&mf(n.canActivate)}(a)?a.canActivate(t,n):i.runInContext(()=>a(t,n))).pipe(Ru())}));return sn(s).pipe(ah())}(n,s.route,e))),Ru(s=>!0!==s,!0))}(r,o,n,t):sn(a)),gt(a=>({...e,guardsResult:a})))})}(this.environmentInjector,i=>this.events.next(i)),Es(i=>{if(r.guardsResult=i.guardsResult,Fu(i.guardsResult))throw vA(0,i.guardsResult);const a=new j4(i.id,this.urlSerializer.serialize(i.extractedUrl),this.urlSerializer.serialize(i.urlAfterRedirects),i.targetSnapshot,!!i.guardsResult);this.events.next(a)}),Or(i=>!!i.guardsResult||(e.restoreHistory(i),this.cancelNavigationTransition(i,"",3),!1)),Ax(i=>{if(i.guards.canActivateChecks.length)return sn(i).pipe(Es(a=>{const l=new G4(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(l)}),yi(a=>{let l=!1;return sn(a).pipe(function ZW(n,t){return hr(e=>{const{targetSnapshot:r,guards:{canActivateChecks:s}}=e;if(!s.length)return sn(e);let o=0;return pr(s).pipe(th(i=>function YW(n,t,e,r){const s=n.routeConfig,o=n._resolve;return void 0!==s?.title&&!OA(s)&&(o[ef]=s.title),function QW(n,t,e,r){const s=function JW(n){return[...Object.keys(n),...Object.getOwnPropertySymbols(n)]}(n);if(0===s.length)return sn({});const o={};return pr(s).pipe(hr(i=>function ej(n,t,e,r){const s=hf(t)??r,o=ih(n,s);return Oc(o.resolve?o.resolve(t,e):s.runInContext(()=>o(t,e)))}(n[i],t,e,r).pipe(Ru(),Es(a=>{o[i]=a}))),hx(1),iy(o),Rc(i=>DA(i)?to:Mu(i)))}(o,n,t,r).pipe(gt(i=>(n._resolvedData=i,n.data=mA(n,e).resolve,s&&OA(s)&&(n.data[ef]=s.title),null)))}(i.route,r,n,t)),Es(()=>o++),hx(1),hr(i=>o===s.length?sn(e):to))})}(e.paramsInheritanceStrategy,this.environmentInjector),Es({next:()=>l=!0,complete:()=>{l||(e.restoreHistory(a),this.cancelNavigationTransition(a,"",2))}}))}),Es(a=>{const l=new K4(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(l)}))}),Ax(i=>{const a=l=>{const c=[];l.routeConfig?.loadComponent&&!l.routeConfig._loadedComponent&&c.push(this.configLoader.loadComponent(l.routeConfig).pipe(Es(u=>{l.component=u}),gt(()=>{})));for(const u of l.children)c.push(...a(u));return c};return ry(a(i.targetSnapshot.root)).pipe(oy(),Jr(1))}),Ax(()=>this.afterPreactivation()),gt(i=>{const a=function sW(n,t,e){const r=df(n,t._root,e?e._root:void 0);return new pA(r,t)}(e.routeReuseStrategy,i.targetSnapshot,i.currentRouterState);return r={...i,targetRouterState:a}}),Es(i=>{e.currentUrlTree=i.urlAfterRedirects,e.rawUrlTree=e.urlHandlingStrategy.merge(i.urlAfterRedirects,i.rawUrl),e.routerState=i.targetRouterState,"deferred"===e.urlUpdateStrategy&&(i.extras.skipLocationChange||e.setBrowserUrl(e.rawUrlTree,i),e.browserUrlTree=i.urlAfterRedirects)}),((n,t,e,r)=>gt(s=>(new pW(t,s.targetRouterState,s.currentRouterState,e,r).activate(n),s)))(this.rootContexts,e.routeReuseStrategy,i=>this.events.next(i),this.inputBindingEnabled),Jr(1),Es({next:i=>{s=!0,this.lastSuccessfulNavigation=this.currentNavigation,e.navigated=!0,this.events.next(new Pu(i.id,this.urlSerializer.serialize(i.extractedUrl),this.urlSerializer.serialize(e.currentUrlTree))),e.titleStrategy?.updateTitle(i.targetRouterState.snapshot),i.resolve(!0)},complete:()=>{s=!0}}),ay(()=>{s||o||this.cancelNavigationTransition(r,"",1),this.currentNavigation?.id===r.id&&(this.currentNavigation=null)}),Rc(i=>{if(o=!0,wA(i)){CA(i)||(e.navigated=!0,e.restoreHistory(r,!0));const a=new fy(r.id,this.urlSerializer.serialize(r.extractedUrl),i.message,i.cancellationCode);if(this.events.next(a),CA(i)){const l=e.urlHandlingStrategy.merge(i.url,e.rawUrlTree),c={skipLocationChange:r.extras.skipLocationChange,replaceUrl:"eager"===e.urlUpdateStrategy||PA(r.source)};e.scheduleNavigation(l,lf,null,c,{resolve:r.resolve,reject:r.reject,promise:r.promise})}else r.resolve(!1)}else{e.restoreHistory(r,!0);const a=new _x(r.id,this.urlSerializer.serialize(r.extractedUrl),i,r.targetSnapshot??void 0);this.events.next(a);try{r.resolve(e.errorHandler(i))}catch(l){r.reject(l)}}return to}))}))}cancelNavigationTransition(e,r,s){const o=new fy(e.id,this.urlSerializer.serialize(e.extractedUrl),r,s);this.events.next(o),e.resolve(!1)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function PA(n){return n!==lf}let $A=(()=>{class n{buildTitle(e){let r,s=e.root;for(;void 0!==s;)r=this.getResolvedTitleForRoute(s)??r,s=s.children.find(o=>o.outlet===An);return r}getResolvedTitleForRoute(e){return e.data[ef]}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:function(){return Ft(nj)},providedIn:"root"}),n})(),nj=(()=>{class n extends $A{constructor(e){super(),this.title=e}updateTitle(e){const r=this.buildTitle(e);void 0!==r&&this.title.setTitle(r)}}return n.\u0275fac=function(e){return new(e||n)(Ke($1))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),rj=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:function(){return Ft(oj)},providedIn:"root"}),n})();class sj{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}let oj=(()=>{class n extends sj{}return n.\u0275fac=function(){let t;return function(r){return(t||(t=function vs(n){return ci(()=>{const t=n.prototype.constructor,e=t[ui]||pp(t),r=Object.prototype;let s=Object.getPrototypeOf(n.prototype).constructor;for(;s&&s!==r;){const o=s[ui]||pp(s);if(o&&o!==e)return o;s=Object.getPrototypeOf(s)}return o=>new o})}(n)))(r||n)}}(),n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Cy=new Ct("",{providedIn:"root",factory:()=>({})});let ij=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:function(){return Ft(aj)},providedIn:"root"}),n})(),aj=(()=>{class n{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,r){return e}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();var bi=(()=>((bi=bi||{})[bi.COMPLETE=0]="COMPLETE",bi[bi.FAILED=1]="FAILED",bi[bi.REDIRECTING=2]="REDIRECTING",bi))();function LA(n,t){n.events.pipe(Or(e=>e instanceof Pu||e instanceof fy||e instanceof _x||e instanceof cf),gt(e=>e instanceof Pu||e instanceof cf?bi.COMPLETE:e instanceof fy&&(0===e.code||1===e.code)?bi.REDIRECTING:bi.FAILED),Or(e=>e!==bi.REDIRECTING),Jr(1)).subscribe(()=>{t()})}function lj(n){throw n}function cj(n,t,e){return t.parse("/")}const uj={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},dj={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let Ui=(()=>{class n{get navigationId(){return this.navigationTransitions.navigationId}get browserPageId(){if("computed"===this.canceledNavigationResolution)return this.location.getState()?.\u0275routerPageId}get events(){return this.navigationTransitions.events}constructor(){this.disposed=!1,this.currentPageId=0,this.console=Ft(dI),this.isNgZoneEnabled=!1,this.options=Ft(Cy,{optional:!0})||{},this.pendingTasks=Ft(XI),this.errorHandler=this.options.errorHandler||lj,this.malformedUriErrorHandler=this.options.malformedUriErrorHandler||cj,this.navigated=!1,this.lastSuccessfulId=-1,this.urlHandlingStrategy=Ft(ij),this.routeReuseStrategy=Ft(rj),this.titleStrategy=Ft($A),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.config=Ft(ch,{optional:!0})?.flat()??[],this.navigationTransitions=Ft(xy),this.urlSerializer=Ft(nf),this.location=Ft(zg),this.componentInputBindingEnabled=!!Ft(gy,{optional:!0}),this.isNgZoneEnabled=Ft(wn)instanceof wn&&wn.isInAngularZone(),this.resetConfig(this.config),this.currentUrlTree=new rh,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=fA(0,null),this.navigationTransitions.setupNavigations(this).subscribe(e=>{this.lastSuccessfulId=e.id,this.currentPageId=this.browserPageId??0},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}resetRootComponentType(e){this.routerState.root.component=e,this.navigationTransitions.rootComponentType=e}initialNavigation(){if(this.setUpLocationChangeListener(),!this.navigationTransitions.hasRequestedNavigation){const e=this.location.getState();this.navigateToSyncWithBrowser(this.location.path(!0),lf,e)}}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{this.navigateToSyncWithBrowser(e.url,r,e.state)},0)}))}navigateToSyncWithBrowser(e,r,s){const o={replaceUrl:!0},i=s?.navigationId?s:null;if(s){const l={...s};delete l.navigationId,delete l.\u0275routerPageId,0!==Object.keys(l).length&&(o.state=l)}const a=this.parseUrl(e);this.scheduleNavigation(a,r,i,o)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}get lastSuccessfulNavigation(){return this.navigationTransitions.lastSuccessfulNavigation}resetConfig(e){this.config=e.map(Dx),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,r={}){const{relativeTo:s,queryParams:o,fragment:i,queryParamsHandling:a,preserveFragment:l}=r,c=l?this.currentUrlTree.fragment:i;let d,u=null;switch(a){case"merge":u={...this.currentUrlTree.queryParams,...o};break;case"preserve":u=this.currentUrlTree.queryParams;break;default:u=o||null}null!==u&&(u=this.removeEmptyProps(u));try{d=sA(s?s.snapshot:this.routerState.snapshot.root)}catch{("string"!=typeof e[0]||!e[0].startsWith("/"))&&(e=[]),d=this.currentUrlTree.root}return oA(d,e,u,c??null)}navigateByUrl(e,r={skipLocationChange:!1}){const s=Fu(e)?e:this.parseUrl(e),o=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(o,lf,null,r)}navigate(e,r={skipLocationChange:!1}){return function hj(n){for(let t=0;t<n.length;t++)if(null==n[t])throw new qe(4008,!1)}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(s){r=this.malformedUriErrorHandler(s,this.urlSerializer,e)}return r}isActive(e,r){let s;if(s=!0===r?{...uj}:!1===r?{...dj}:r,Fu(e))return q1(this.currentUrlTree,e,s);const o=this.parseUrl(e);return q1(this.currentUrlTree,o,s)}removeEmptyProps(e){return Object.keys(e).reduce((r,s)=>{const o=e[s];return null!=o&&(r[s]=o),r},{})}scheduleNavigation(e,r,s,o,i){if(this.disposed)return Promise.resolve(!1);let a,l,c;i?(a=i.resolve,l=i.reject,c=i.promise):c=new Promise((d,p)=>{a=d,l=p});const u=this.pendingTasks.add();return LA(this,()=>{Promise.resolve().then(()=>this.pendingTasks.remove(u))}),this.navigationTransitions.handleNavigationRequest({source:r,restoredState:s,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl:e,extras:o,resolve:a,reject:l,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(d=>Promise.reject(d))}setBrowserUrl(e,r){const s=this.urlSerializer.serialize(e);if(this.location.isCurrentPathEqualTo(s)||r.extras.replaceUrl){const i={...r.extras.state,...this.generateNgRouterState(r.id,this.browserPageId)};this.location.replaceState(s,"",i)}else{const o={...r.extras.state,...this.generateNgRouterState(r.id,(this.browserPageId??0)+1)};this.location.go(s,"",o)}}restoreHistory(e,r=!1){if("computed"===this.canceledNavigationResolution){const o=this.currentPageId-(this.browserPageId??this.currentPageId);0!==o?this.location.historyGo(o):this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===o&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree())}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class BA{}let mj=(()=>{class n{constructor(e,r,s,o,i){this.router=e,this.injector=s,this.preloadingStrategy=o,this.loader=i}setUpPreloading(){this.subscription=this.router.events.pipe(Or(e=>e instanceof Pu),th(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const s=[];for(const o of r){o.providers&&!o._injector&&(o._injector=t0(o.providers,e,`Route: ${o.path}`));const i=o._injector??e,a=o._loadedInjector??i;(o.loadChildren&&!o._loadedRoutes&&void 0===o.canLoad||o.loadComponent&&!o._loadedComponent)&&s.push(this.preloadConfig(i,o)),(o.children||o._loadedRoutes)&&s.push(this.processRoutes(a,o.children??o._loadedRoutes))}return pr(s).pipe(ti())}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>{let s;s=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(e,r):sn(null);const o=s.pipe(hr(i=>null===i?sn(void 0):(r._loadedRoutes=i.routes,r._loadedInjector=i.injector,this.processRoutes(i.injector??e,i.routes))));return r.loadComponent&&!r._loadedComponent?pr([o,this.loader.loadComponent(r)]).pipe(ti()):o})}}return n.\u0275fac=function(e){return new(e||n)(Ke(Ui),Ke(hI),Ke(kl),Ke(BA),Ke(Nx))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Mx=new Ct("");let VA=(()=>{class n{constructor(e,r,s,o,i={}){this.urlSerializer=e,this.transitions=r,this.viewportScroller=s,this.zone=o,this.options=i,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},i.scrollPositionRestoration=i.scrollPositionRestoration||"disabled",i.anchorScrolling=i.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof bx?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof Pu?(this.lastId=e.id,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.urlAfterRedirects).fragment)):e instanceof cf&&0===e.code&&(this.lastSource=void 0,this.restoredId=0,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.url).fragment))})}consumeScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof dA&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.transitions.events.next(new dA(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription?.unsubscribe(),this.scrollEventsSubscription?.unsubscribe()}}return n.\u0275fac=function(e){pg()},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})();function zl(n,t){return{\u0275kind:n,\u0275providers:t}}function zA(){const n=Ft(Gs);return t=>{const e=n.get(Ll);if(t!==e.components[0])return;const r=n.get(Ui),s=n.get(HA);1===n.get(Rx)&&r.initialNavigation(),n.get(WA,null,Dt.Optional)?.setUpPreloading(),n.get(Mx,null,Dt.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),s.closed||(s.next(),s.complete(),s.unsubscribe())}}const HA=new Ct("",{factory:()=>new et}),Rx=new Ct("",{providedIn:"root",factory:()=>1}),WA=new Ct("");function _j(n){return zl(0,[{provide:WA,useExisting:mj},{provide:BA,useExisting:n}])}const jA=new Ct("ROUTER_FORROOT_GUARD"),xj=[zg,{provide:nf,useClass:px},Ui,uf,{provide:oh,useFactory:function UA(n){return n.routerState.root},deps:[Ui]},Nx,[]];function Cj(){return new wI("Router",Ui)}let GA=(()=>{class n{constructor(e){}static forRoot(e,r){return{ngModule:n,providers:[xj,[],{provide:ch,multi:!0,useValue:e},{provide:jA,useFactory:Dj,deps:[[Ui,new er,new In]]},{provide:Cy,useValue:r||{}},r?.useHash?{provide:ku,useClass:MU}:{provide:ku,useClass:QI},{provide:Mx,useFactory:()=>{const n=Ft(Zz),t=Ft(wn),e=Ft(Cy),r=Ft(xy),s=Ft(nf);return e.scrollOffset&&n.setOffset(e.scrollOffset),new VA(s,r,n,t,e)}},r?.preloadingStrategy?_j(r.preloadingStrategy).\u0275providers:[],{provide:wI,multi:!0,useFactory:Cj},r?.initialNavigation?Tj(r):[],r?.bindToComponentInputs?zl(8,[_A,{provide:gy,useExisting:_A}]).\u0275providers:[],[{provide:KA,useFactory:zA},{provide:E0,multi:!0,useExisting:KA}]]}}static forChild(e){return{ngModule:n,providers:[{provide:ch,multi:!0,useValue:e}]}}}return n.\u0275fac=function(e){return new(e||n)(Ke(jA,8))},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({}),n})();function Dj(n){return"guarded"}function Tj(n){return["disabled"===n.initialNavigation?zl(3,[{provide:Fg,multi:!0,useFactory:()=>{const t=Ft(Ui);return()=>{t.setUpLocationChangeListener()}}},{provide:Rx,useValue:2}]).\u0275providers:[],"enabledBlocking"===n.initialNavigation?zl(2,[{provide:Rx,useValue:0},{provide:Fg,multi:!0,deps:[Gs],useFactory:t=>{const e=t.get(NU,Promise.resolve());return()=>e.then(()=>new Promise(r=>{const s=t.get(Ui),o=t.get(HA);LA(s,()=>{r(!0)}),t.get(xy).afterPreactivation=()=>(r(!0),o.closed?sn(void 0):o),s.initialNavigation()}))}}]).\u0275providers:[]]}const KA=new Ct(""),Aj=[];let Nj=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({imports:[GA.forRoot(Aj),GA]}),n})();var xa=O(5861),kj=O(5103),h=O(3798);function qt(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&h.util.assert("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}const Mj=h.kernel_impls.whereImpl;let Rj=(()=>{class n extends h.KernelBackend{nextDataId(){return n.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new h.DataStorage(this,(0,h.engine)())}write(e,r,s){this.firstUse&&(this.firstUse=!1,(0,h.env)().get("IS_NODE")&&h.backend_util.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:s,refCount:1}),o}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&h.util.isString(s[0])){const i=s.map(a=>h.util.encodeString(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return{dataId:o,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,s,o,i){this.data.set(e,{values:r,dtype:o,refCount:i})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return(0,xa.Z)(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);if("complex64"===r){const o=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return h.backend_util.mergeRealAndImagArrays(o,i)}return h.util.convertBackendValuesAndArrayBuffer(this.data.get(e).values,r)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(o=>h.util.decodeString(o));return(0,h.buffer)(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,h.buffer)(e.shape,e.dtype,r)}makeOutput(e,r,s){return(0,h.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(r,s,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return(0,xa.Z)(function*(){const r=h.util.now();return e(),{kernelMs:h.util.now()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){qt([e],"where");const r=this.readSync(e.dataId);return Mj(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();function sl(n){return(t,e,r)=>{const s=h.util.getArrayFromDType(e,t.length);for(let o=0;o<t.length;++o)s[o]=n(t[o],r);return s}}function rr(n,t,e){return Fc(n,sl(t),e)}function Fc(n,t,e){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;qt(i,n);const a=o,l=a.data.get(i.dataId).values;let c;if("string"===i.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=h.backend_util.fromUint8ToStringArray(l)}else c=l;const u=e||i.dtype,d=t(c,u,s);return a.makeTensorInfo(i.shape,u,d)}}(0,h.registerBackend)("cpu",()=>new Rj,1);const XA=rr(h.Elu,n=>n>=0?n:Math.exp(n)-1),Oj={kernelName:h.Elu,backendName:"cpu",kernelFunc:XA};function ol(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Fj={kernelName:h.Identity,backendName:"cpu",kernelFunc:ol};function qA(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:o}=r;qt([s],"leakyRelu");const i=h.util.sizeFromShape(s.shape),a=e.data.get(s.dataId).values,l=h.util.getTypedArrayFromDType("float32",i);for(let c=0;c<a.length;c++)l[c]=a[c]<0?o*a[c]:a[c];return e.makeTensorInfo(s.shape,"float32",l)}const Pj={kernelName:h.LeakyRelu,backendName:"cpu",kernelFunc:qA};function Hr(n){return(t,e,r,s,o)=>{const i=h.backend_util.assertAndGetBroadcastShape(t,e),a=i.length,l=h.util.computeStrides(i),c=h.util.sizeFromShape(i),u=h.util.getTypedArrayFromDType(o,c),d=t.length,p=e.length,m=h.util.computeStrides(t),y=h.util.computeStrides(e),_=h.backend_util.getBroadcastDims(t,i),C=h.backend_util.getBroadcastDims(e,i);if(_.length+C.length===0)for(let D=0;D<u.length;++D)u[D]=n(r[D%r.length],s[D%s.length]);else for(let D=0;D<u.length;++D){const N=h.util.indexToLoc(D,a,l),W=N.slice(-d);_.forEach(Ee=>W[Ee]=0);const j=h.util.locToIndex(W,d,m),te=N.slice(-p);C.forEach(Ee=>te[Ee]=0);const _e=h.util.locToIndex(te,p,y);u[D]=n(r[j],s[_e])}return[u,i]}}const $j=Hr((n,t)=>n<0?t*n:n);function ZA(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t;qt([r,s],"prelu");const o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,[a,l]=$j(r.shape,s.shape,o,i,"float32");return e.makeTensorInfo(l,"float32",a)}const Lj={kernelName:h.Prelu,backendName:"cpu",kernelFunc:ZA},YA=rr(h.Relu,n=>Math.max(0,n)),Bj={kernelName:h.Relu,backendName:"cpu",kernelFunc:YA},QA=rr(h.Relu6,n=>Math.min(Math.max(0,n),6)),Vj={kernelName:h.Relu6,backendName:"cpu",kernelFunc:QA},Uj=sl(n=>1/(1+Math.exp(-n))),JA=rr(h.Sigmoid,n=>1/(1+Math.exp(-n))),zj={kernelName:h.Sigmoid,backendName:"cpu",kernelFunc:JA};function wy(n,t,e,r,s){if("linear"===e)return ol({inputs:{x:t},backend:n});if("relu"===e)return YA({inputs:{x:t},backend:n});if("elu"===e)return XA({inputs:{x:t},backend:n});if("relu6"===e)return QA({inputs:{x:t},backend:n});if("prelu"===e)return ZA({inputs:{x:t,alpha:r},backend:n});if("leakyrelu"===e)return qA({inputs:{x:t},backend:n,attrs:{alpha:s}});if("sigmoid"===e)return JA({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Xo(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",o),imag:e.makeTensorInfo(s.shape,"float32",i)},a}const Hj={kernelName:h.Complex,backendName:"cpu",kernelFunc:Xo};function Sy(n,t,e="float32"){if("complex64"===e)return Xo({inputs:{real:Sy(n,t,"float32"),imag:Sy(n,t,"float32")},backend:n});const r=h.util.makeZerosTypedArray(h.util.sizeFromShape(t),e);return n.makeTensorInfo(t,e,r)}function $u(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.real,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const Wj={kernelName:h.Real,backendName:"cpu",kernelFunc:$u};function eN(n,t,e,r){if("int32"===r)return[t,"int32",Int32Array.from(n)];if("bool"===r){const s=h.util.toTypedArray([0],e),[o,i]=Hr((a,l)=>a!==l?1:0)(t,[],n,s,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function Pc(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return ol({inputs:{x:s},backend:e});const u=Sy(e,s.shape,s.dtype),d=Pc({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),p=Xo({inputs:{real:d,imag:u},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),p}if("complex64"===s.dtype){const u=$u({inputs:{input:s},backend:e}),d=Pc({inputs:{x:u},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(u),d}if(!h.util.hasEncodingLoss(s.dtype,o)){const u=ol({inputs:{x:s},backend:e});return{dataId:u.dataId,shape:u.shape,dtype:o}}const i=e.data.get(s.dataId).values,[a,l,c]=eN(i,s.shape,s.dtype,o);return e.makeTensorInfo(a,l,c)}const jj={kernelName:h.Cast,backendName:"cpu",kernelFunc:Pc};function ds(n,t,e,r){return null==e?({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;qt([i,a],n);const c=l.data.get(i.dataId).values,u=l.data.get(a.dataId).values,d="string"===i.dtype?h.backend_util.fromUint8ToStringArray(c):c,p="string"===i.dtype?h.backend_util.fromUint8ToStringArray(u):u,m=r||i.dtype,[y,_]=t(i.shape,a.shape,d,p,m);return l.makeTensorInfo(_,m,y)}:({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;if("complex64"===i.dtype||"complex64"===a.dtype){const c=Pc({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),p=u.complexTensorInfos.imag,m=l.data.get(u.complexTensorInfos.real.dataId).values,y=l.data.get(p.dataId).values,_=Pc({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),C=l.data.get(_.dataId),N=C.complexTensorInfos.imag,W=l.data.get(C.complexTensorInfos.real.dataId).values,j=l.data.get(N.dataId).values,[te,_e,Ee]=e(i.shape,a.shape,m,y,W,j),Ne=l.makeTensorInfo(Ee,"float32",te),je=l.makeTensorInfo(Ee,"float32",_e),He=Xo({inputs:{real:Ne,imag:je},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(_),l.disposeIntermediateTensorInfo(Ne),l.disposeIntermediateTensorInfo(je),He}{const c=l.data.get(i.dataId).values,u=l.data.get(a.dataId).values,d=r||i.dtype,[p,m]=t(i.shape,a.shape,c,u,d);return l.makeTensorInfo(m,d,p)}}}function Ox(n){return(t,e,r,s,o,i)=>{const a=h.backend_util.assertAndGetBroadcastShape(t,e),l=h.util.sizeFromShape(a),c=a.length,u=h.util.computeStrides(a),d=h.util.getTypedArrayFromDType("float32",l),p=h.util.getTypedArrayFromDType("float32",l),m=h.backend_util.getBroadcastDims(t,a),y=h.backend_util.getBroadcastDims(e,a),_=h.backend_util.mergeRealAndImagArrays(r,s),C=h.backend_util.mergeRealAndImagArrays(o,i),D=t.length,N=h.util.computeStrides(t),W=e.length,j=h.util.computeStrides(e);if(m.length+y.length===0)for(let te=0;te<d.length;te++){const _e=te%_.length,Ee=te%C.length,Ne=n(_[2*_e],_[2*_e+1],C[2*Ee],C[2*Ee+1]);d[te]=Ne.real,p[te]=Ne.imag}else for(let te=0;te<d.length;te++){const _e=h.util.indexToLoc(te,c,u),Ee=_e.slice(-D);m.forEach(at=>Ee[at]=0);const Ne=h.util.locToIndex(Ee,D,N),je=_e.slice(-W);y.forEach(at=>je[at]=0);const He=h.util.locToIndex(je,W,j),it=n(_[2*Ne],_[2*Ne+1],C[2*He],C[2*He+1]);d[te]=it.real,p[te]=it.imag}return[d,p,a]}}const tN=Hr((n,t)=>n+t),Gj=Ox((n,t,e,r)=>({real:n+e,imag:t+r})),uh=ds(h.Add,tN,Gj),Kj={kernelName:h.Add,backendName:"cpu",kernelFunc:uh};function gr(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:o}=r,i=h.util.sizeFromShape(s.shape),a=h.util.inferFromImplicitShape(o,i),l=h.util.sizeFromShape(a);h.util.assert(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);const c=e.data.get(s.dataId);if(null!=c.complexTensorInfos){const d=c.complexTensorInfos.imag;c.complexTensorInfos.real.shape=a,d.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const Xj={kernelName:h.Reshape,backendName:"cpu",kernelFunc:gr};function nN(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o}=t,{transposeA:i,transposeB:a}=r;qt([s,o],"matMul");const l=s.shape.length,c=o.shape.length,u=i?s.shape[l-2]:s.shape[l-1],d=a?o.shape[c-1]:o.shape[c-2],p=i?s.shape[l-1]:s.shape[l-2],m=a?o.shape[c-2]:o.shape[c-1],y=s.shape.slice(0,-2),_=o.shape.slice(0,-2),C=h.util.sizeFromShape(y),D=h.util.sizeFromShape(_),W=h.broadcast_util.assertAndGetBroadcastShape(s.shape.slice(0,-2),o.shape.slice(0,-2)).concat([p,m]);h.util.assert(u===d,()=>`Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${i} and transposeB=${a} must match.`);const te=a?[D,m,d]:[D,d,m],_e=gr({inputs:{x:s},backend:e,attrs:{shape:i?[C,u,p]:[C,p,u]}}),Ee=gr({inputs:{x:o},backend:e,attrs:{shape:te}}),Ne=i?_e.shape[1]:_e.shape[2],je=i?_e.shape[2]:_e.shape[1],He=a?Ee.shape[1]:Ee.shape[2],it=Math.max(C,D),at=e.data.get(_e.dataId).values,tt=e.data.get(Ee.dataId).values,lt=h.util.computeStrides(_e.shape),st=h.util.computeStrides(Ee.shape),[Pe,We,Ue]=i?[lt[0],1,lt[1]]:[lt[0],lt[1],1],[Ye,pt,yt]=a?[1,st[1],st[0]]:[st[1],1,st[0]],Et=je*He,wt=(0,h.buffer)([it,je,He],_e.dtype),vt=wt.values,kt=e.blockSize;for(let jt=0;jt<it;jt++){const Ut=jt%C,tn=jt%D;for(let Xt=0;Xt<je;Xt+=kt){const Cn=Math.min(Xt+kt,je);for(let Sn=0;Sn<He;Sn+=kt){const sr=Math.min(Sn+kt,He);for(let yr=0;yr<Ne;yr+=kt){const Vr=Math.min(yr+kt,Ne);for(let br=Xt;br<Cn;br++)for(let dr=Sn;dr<sr;dr++){let Fr=0;for(let kr=yr;kr<Vr;kr++)Fr+=at[Ut*Pe+br*We+kr*Ue]*tt[kr*Ye+dr*pt+tn*yt];vt[jt*Et+(br*He+dr)]+=Fr}}}}}return e.disposeIntermediateTensorInfo(_e),e.disposeIntermediateTensorInfo(Ee),e.makeTensorInfo(W,wt.dtype,wt.values)}const qj={kernelName:h.BatchMatMul,backendName:"cpu",kernelFunc:nN},Yj={kernelName:h._FusedMatMul,backendName:"cpu",kernelFunc:function Zj(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o,bias:i,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=r;let p,m,y;const _=[];p=nN({inputs:{a:s,b:o},attrs:{transposeA:l,transposeB:c},backend:e}),i&&(m=uh({inputs:{a:p,b:i},backend:e}),_.push(p),p=m),u&&(y=wy(e,p,u,a,d),_.push(p),p=y);for(const D of _)e.disposeIntermediateTensorInfo(D);return p}};function rN(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const Jj={kernelName:h.Abs,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;qt(t,"abs");let r=new Float32Array(h.util.sizeFromShape(t.shape));return r=rN(e.data.get(t.dataId).values),e.makeOutput(r,t.shape,t.dtype)}},eG=rr(h.Acos,n=>Math.acos(n)),tG={kernelName:h.Acos,backendName:"cpu",kernelFunc:eG},nG=rr(h.Acosh,n=>Math.acosh(n)),rG={kernelName:h.Acosh,backendName:"cpu",kernelFunc:nG},oG={kernelName:h.AddN,backendName:"cpu",kernelFunc:function sG(n){const{inputs:t,backend:e}=n,r=t;qt(t,"addN");const s=r.map(a=>e.data.get(a.dataId).values),o=(0,h.buffer)(r[0].shape,r[0].dtype),i=o.values;for(let a=0;a<r.length;a++){const l=s[a];for(let c=0;c<i.length;c++)i[c]+=l[c]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}};function Fx(n,t,e,r,s){const o=t.length,i=h.util.sizeFromShape(t),a=h.util.computeStrides(t),l=h.util.computeStrides(s),c=h.util.getTypedArrayFromDType(e,h.util.sizeFromShape(s));for(let u=0;u<i;++u){const d=h.util.indexToLoc(u,o,a),p=new Array(d.length);for(let y=0;y<p.length;y++)p[y]=d[r[y]];c[h.util.locToIndex(p,o,l)]=n[u]}return c}function Ro(n){const{inputs:t,attrs:e,backend:r}=n,{x:s}=t,{perm:o}=e;qt(s,"transpose");const a=new Array(s.shape.length);for(let d=0;d<a.length;d++)a[d]=s.shape[o[d]];const c=Fx(r.data.get(s.dataId).values,s.shape,s.dtype,o,a);return{dataId:r.write(c,a,s.dtype),shape:a,dtype:s.dtype}}const iG={kernelName:h.Transpose,backendName:"cpu",kernelFunc:Ro},lG={kernelName:h.All,backendName:"cpu",kernelFunc:function aG(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;qt(s,"all");const a=h.util.parseAxisParam(o,s.shape);let l=a;const c=h.backend_util.getAxesPermutation(l,s.shape.length);let u=s;null!=c&&(u=Ro({inputs:{x:s},backend:e,attrs:{perm:c}}),l=h.backend_util.getInnerMostAxes(l.length,s.shape.length)),h.backend_util.assertAxesAreInnerMostDims("all",l,u.shape.length);const[d,p]=h.backend_util.computeOutAndReduceShapes(u.shape,l),m=h.util.sizeFromShape(p),y=h.util.makeZerosTypedArray(h.util.sizeFromShape(d),u.dtype),_=e.data.get(u.dataId).values;for(let D=0;D<y.length;++D){const N=D*m;let W=_[N];for(let j=0;j<m;++j)W=W&&_[N+j];y[D]=W}null!=c&&e.disposeIntermediateTensorInfo(u);const C=e.makeTensorInfo(d,u.dtype,y);if(i){const N=gr({inputs:{x:C},backend:e,attrs:{shape:h.backend_util.expandShapeToKeepDim(d,a)}});return e.disposeIntermediateTensorInfo(C),N}return C}},uG={kernelName:h.Any,backendName:"cpu",kernelFunc:function cG(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;qt(s,"any");const a=h.util.parseAxisParam(o,s.shape);let l=a;const c=h.backend_util.getAxesPermutation(l,s.shape.length);let u=s;null!=c&&(u=Ro({inputs:{x:s},backend:e,attrs:{perm:c}}),l=h.backend_util.getInnerMostAxes(l.length,s.shape.length)),h.backend_util.assertAxesAreInnerMostDims("any",l,u.shape.length);const[d,p]=h.backend_util.computeOutAndReduceShapes(u.shape,l),m=h.util.sizeFromShape(p),y=h.util.makeZerosTypedArray(h.util.sizeFromShape(d),u.dtype),_=e.data.get(u.dataId).values;for(let D=0;D<y.length;++D){const N=D*m;let W=_[N];for(let j=0;j<m;++j)W=W||_[N+j];y[D]=W}null!=c&&e.disposeIntermediateTensorInfo(u);const C=e.makeTensorInfo(d,u.dtype,y);if(i){const N=gr({inputs:{x:C},backend:e,attrs:{shape:h.backend_util.expandShapeToKeepDim(d,a)}});return e.disposeIntermediateTensorInfo(C),N}return C}},hG={kernelName:h.ArgMax,backendName:"cpu",kernelFunc:function dG(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;qt(s,"argMax");let i=h.util.parseAxisParam(o,s.shape);const a=h.backend_util.getAxesPermutation(i,s.shape.length);let l=s;const c=[];null!=a&&(l=Ro({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),i=h.backend_util.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],h.backend_util.assertAxesAreInnerMostDims("argMax",i,l.shape.length);const[u,d]=h.backend_util.computeOutAndReduceShapes(l.shape,i),p=h.util.sizeFromShape(u),m=h.util.makeZerosTypedArray(p,"int32"),y=h.util.sizeFromShape(d),_=e.data.get(l.dataId).values;for(let C=0;C<m.length;++C){const D=C*y;let N=_[D],W=0;for(let j=0;j<y;++j){const te=_[D+j];te>N&&(N=te,W=j)}m[C]=W}return c.forEach(C=>e.disposeIntermediateTensorInfo(C)),e.makeTensorInfo(u,"int32",m)}},fG={kernelName:h.ArgMin,backendName:"cpu",kernelFunc:function pG(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;qt(s,"argMin");let i=h.util.parseAxisParam(o,s.shape);const a=h.backend_util.getAxesPermutation(i,s.shape.length);let l=s;const c=[];null!=a&&(l=Ro({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),i=h.backend_util.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],h.backend_util.assertAxesAreInnerMostDims("argMin",i,l.shape.length);const[u,d]=h.backend_util.computeOutAndReduceShapes(l.shape,i),p=h.util.sizeFromShape(u),m=h.util.makeZerosTypedArray(p,"int32"),y=h.util.sizeFromShape(d),_=e.data.get(l.dataId).values;for(let C=0;C<m.length;++C){const D=C*y;let N=_[D],W=0;for(let j=0;j<y;++j){const te=_[D+j];te<N&&(N=te,W=j)}m[C]=W}return c.forEach(C=>e.disposeIntermediateTensorInfo(C)),e.makeTensorInfo(u,"int32",m)}},mG=rr(h.Asin,n=>Math.asin(n)),gG={kernelName:h.Asin,backendName:"cpu",kernelFunc:mG},yG=rr(h.Asinh,n=>Math.asinh(n)),bG={kernelName:h.Asinh,backendName:"cpu",kernelFunc:yG},_G=rr(h.Atan,n=>Math.atan(n)),vG={kernelName:h.Atan,backendName:"cpu",kernelFunc:_G},xG=Hr((n,t)=>Math.atan2(n,t)),CG=ds(h.Atan2,xG),wG={kernelName:h.Atan2,backendName:"cpu",kernelFunc:CG},SG=rr(h.Atanh,n=>Math.atanh(n)),EG={kernelName:h.Atanh,backendName:"cpu",kernelFunc:SG};function Px(n,t,e,r,s,o){const i=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,c=s.dilationWidth,u=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,m=s.padInfo.left,y="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,_=(0,h.buffer)(s.outShape,e),C=_.values,D=s.outShape[1]*s.outShape[2]*s.outShape[3],N=s.outShape[2]*s.outShape[3],W=s.outShape[3];for(let j=0;j<s.batchSize;++j){const te=j*D,_e=j*r[0];for(let Ee=0;Ee<s.inChannels;++Ee)for(let Ne=0;Ne<s.outHeight;++Ne){const je=Ne*i-p,He=Math.max(0,je),it=Math.min(s.inHeight,u+je),at=te+Ne*N;for(let tt=0;tt<s.outWidth;++tt){const lt=tt*a-m,st=Math.max(0,lt),Pe=Math.min(s.inWidth,d+lt);let We=y,Ue=0,Ye=0;for(let yt=He;yt<it;yt+=l){const Et=_e+yt*r[1];for(let wt=st;wt<Pe;wt+=c){const kt=n[Et+wt*r[2]+Ee];"max"===o&&kt>We?We=kt:"avg"===o&&(Ue+=kt,Ye++)}if(isNaN(We))break}C[at+tt*W+Ee]="avg"===o?Ue/Ye:We}}}return _}function sN(n,t,e,r,s=!1,o=!1){const i=(0,h.buffer)(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,m=r.padInfo.top,y=r.padInfo.left,_=(0,h.buffer)(t,e,n);for(let C=0;C<r.batchSize;++C)for(let D=0;D<r.inChannels;++D)for(let N=0;N<r.outHeight;++N){const W=N*a-m;let j=W;for(;j<0;)j+=c;const te=Math.min(r.inHeight,d+W);for(let _e=0;_e<r.outWidth;++_e){const Ee=_e*l-y;let Ne=Ee;for(;Ne<0;)Ne+=u;const je=Math.min(r.inWidth,p+Ee);let He=Number.NEGATIVE_INFINITY,it=-1;for(let at=j;at<te;at+=c){const tt=at-W;for(let lt=Ne;lt<je;lt+=u){const st=lt-Ee,Pe=_.get(C,at,lt,D);Pe>He&&(He=Pe,it=s?o?((C*r.inHeight+at)*r.inWidth+lt)*r.inChannels+D:(at*r.inWidth+lt)*r.inChannels+D:tt*p+st)}}i.set(it,C,N,_e,D)}}return i}function oN(n,t,e,r,s,o){const i=s.strideDepth,a=s.strideHeight,l=s.strideWidth,c=s.dilationDepth,u=s.dilationHeight,d=s.dilationWidth,p=s.effectiveFilterDepth,m=s.effectiveFilterHeight,y=s.effectiveFilterWidth,_=s.padInfo.front,C=s.padInfo.top,D=s.padInfo.left,N="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,W=(0,h.buffer)(s.outShape,e),j=W.values,te=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],_e=s.outShape[2]*s.outShape[3]*s.outShape[4],Ee=s.outShape[3]*s.outShape[4],Ne=s.outShape[4];for(let je=0;je<s.batchSize;++je){const He=je*te,it=je*r[0];for(let at=0;at<s.inChannels;++at)for(let tt=0;tt<s.outDepth;++tt){const lt=tt*i-_;let st=lt;for(;st<0;)st+=c;const Pe=Math.min(s.inDepth,p+lt),We=He+tt*_e;for(let Ue=0;Ue<s.outHeight;++Ue){const Ye=Ue*a-C;let pt=Ye;for(;pt<0;)pt+=u;const yt=Math.min(s.inHeight,m+Ye),Et=We+Ue*Ee;for(let wt=0;wt<s.outWidth;++wt){const vt=wt*l-D;let kt=vt;for(;kt<0;)kt+=d;const jt=Math.min(s.inWidth,y+vt),Ut=Et+wt*Ne;let tn=N,Xt=0,Cn=0;for(let sr=st;sr<Pe;sr+=c){const yr=it+sr*r[1];for(let Vr=pt;Vr<yt;Vr+=u){const br=yr+Vr*r[2];for(let dr=kt;dr<jt;dr+=d){const kr=n[br+dr*r[3]+at];if("max"===o&&kr>tn?tn=kr:"avg"===o&&(Xt+=kr,Cn++),isNaN(tn))break}if(isNaN(tn))break}if(isNaN(tn))break}j[Ut+at]="avg"===o?Xt/Math.max(Cn,1):tn}}}}return W}const IG={kernelName:h.AvgPool,backendName:"cpu",kernelFunc:function TG(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;qt(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;h.util.assert(h.backend_util.eitherStridesOrDilationsAreOne(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const u=h.backend_util.computePool2DInfo(s.shape,o,i,1,a,l);let d;if(1===u.filterWidth&&1===u.filterHeight&&h.util.arraysEqual(u.inShape,u.outShape))d=ol({inputs:{x:s},backend:e});else{const p=e.data.get(s.dataId).values,m=h.util.computeStrides(s.shape),y=Px(p,0,s.dtype,m,u,"avg");d=e.makeTensorInfo(u.outShape,s.dtype,y.values)}return d}},NG={kernelName:h.AvgPool3D,backendName:"cpu",kernelFunc:function AG(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:c}=r;qt(s,"avgPool3d");const u=h.backend_util.computePool3DInfo(s.shape,o,i,1,a,l,c),p=oN(e.data.get(s.dataId).values,0,s.dtype,h.util.computeStrides(s.shape),u,"avg");return e.makeTensorInfo(p.shape,"float32",p.values)}},MG={kernelName:h.AvgPool3DGrad,backendName:"cpu",kernelFunc:function kG(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,{filterSize:i,strides:a,pad:l,dimRoundingMode:c}=r;qt([s,o],"avgPool3DGrad");const u=h.backend_util.computePool3DInfo(o.shape,i,a,1,l,c),d=u.strideDepth,p=u.strideHeight,m=u.strideWidth,y=u.filterDepth,_=u.filterHeight,C=u.filterWidth,D=u.dilationDepth,N=u.dilationHeight,W=u.dilationWidth,j=u.effectiveFilterDepth,te=u.effectiveFilterHeight,_e=u.effectiveFilterWidth,Ee=j-1-u.padInfo.front,Ne=_e-1-u.padInfo.left,je=te-1-u.padInfo.top,He=(0,h.buffer)(o.shape,"float32"),it=1/(y*_*C),at=e.bufferSync(s);for(let tt=0;tt<u.batchSize;++tt)for(let lt=0;lt<u.inChannels;++lt)for(let st=0;st<u.inDepth;++st)for(let Pe=0;Pe<u.inHeight;++Pe)for(let We=0;We<u.inWidth;++We){const Ue=st-Ee,Ye=Pe-je,pt=We-Ne;let yt=0;for(let Et=0;Et<j;Et+=D){const wt=(Ue+Et)/d;if(!(wt<0||wt>=u.outDepth||Math.floor(wt)!==wt))for(let vt=0;vt<te;vt+=N){const kt=(Ye+vt)/p;if(!(kt<0||kt>=u.outHeight||Math.floor(kt)!==kt))for(let jt=0;jt<_e;jt+=W){const Ut=(pt+jt)/m;Ut<0||Ut>=u.outWidth||Math.floor(Ut)!==Ut||(yt+=at.get(tt,wt,kt,Ut,lt))}}}He.set(yt*it,tt,st,Pe,We,lt)}return e.makeTensorInfo(He.shape,He.dtype,He.values)}},OG={kernelName:h.AvgPoolGrad,backendName:"cpu",kernelFunc:function RG(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,i=o;qt([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=h.backend_util.computePool2DInfo(i.shape,a,l,1,c),d=u.strideHeight,p=u.strideWidth,m=u.filterHeight,y=u.filterWidth,_=u.dilationHeight,C=u.dilationWidth,D=u.effectiveFilterHeight,N=u.effectiveFilterWidth,W=N-1-u.padInfo.left,j=D-1-u.padInfo.top,te=(0,h.buffer)(i.shape,"float32"),_e=1/(m*y),Ee=e.data.get(s.dataId).values,Ne=(0,h.buffer)(s.shape,"float32",Ee);for(let je=0;je<u.batchSize;++je)for(let He=0;He<u.inChannels;++He)for(let it=0;it<u.inHeight;++it)for(let at=0;at<u.inWidth;++at){const tt=it-j,lt=at-W;let st=0;for(let Pe=0;Pe<D;Pe+=_){const We=(tt+Pe)/d;if(!(We<0||We>=u.outHeight||Math.floor(We)!==We))for(let Ue=0;Ue<N;Ue+=C){const Ye=(lt+Ue)/p;Ye<0||Ye>=u.outWidth||Math.floor(Ye)!==Ye||(st+=Ne.get(je,We,Ye,He))}}te.set(st*_e,je,it,at,He)}return e.makeTensorInfo(te.shape,te.dtype,te.values)}},PG={kernelName:h.FusedBatchNorm,backendName:"cpu",kernelFunc:function FG(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,scale:o,offset:i,mean:a,variance:l}=t;h.util.assert(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),h.util.assert(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),h.util.assert(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),qt([s,a,l,o,i],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const u=e.data.get(s.dataId).values,d=e.data.get(a.dataId).values,p=e.data.get(l.dataId).values,m=o?e.data.get(o.dataId).values:new Float32Array([1]),y=i?e.data.get(i.dataId).values:new Float32Array([0]),_=new Float32Array(u.length),C=y.length,D=m.length,N=p.length,W=d.length;let j=0,te=0,_e=0,Ee=0;for(let Ne=0;Ne<u.length;++Ne)_[Ne]=y[j++]+(u[Ne]-d[te++])*m[_e++]/Math.sqrt(p[Ee++]+c),j>=C&&(j=0),te>=W&&(te=0),_e>=D&&(_e=0),Ee>=N&&(Ee=0);return e.makeTensorInfo(s.shape,s.dtype,_)}};function iN(n,t,e,r,s){const o=h.slice_util.isSliceContinous(r,t,e),i=h.util.sizeFromShape(e),a=h.util.computeStrides(r);if(o){const d=h.slice_util.computeFlatOffset(t,a);return"string"===s?n.slice(d,d+i):n.subarray(d,d+i)}const l="string"===s?h.backend_util.fromUint8ToStringArray(n):n,c=(0,h.buffer)(r,s,l),u=(0,h.buffer)(e,s);for(let d=0;d<u.size;++d){const p=u.indexToLoc(d),m=p.map((y,_)=>y+t[_]);u.set(c.get(...m),...p)}return"string"===s?h.backend_util.fromStringArrayToUint8(u.values):u.values}function Lu(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,size:i}=r;qt(s,"slice");const[a,l]=h.slice_util.parseSliceParams(s,o,i);h.slice_util.assertParamsValid(s,a,l);const u=iN(e.data.get(s.dataId).values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,u)}const $G={kernelName:h.Slice,backendName:"cpu",kernelFunc:Lu},BG={kernelName:h.BatchToSpaceND,backendName:"cpu",kernelFunc:function LG(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,crops:i}=r;qt([s],"batchToSpaceND");const a=o.reduce((D,N)=>D*N),l=h.backend_util.getReshaped(s.shape,o,a),c=h.backend_util.getPermuted(l.length,o.length),u=h.backend_util.getReshapedPermuted(s.shape,o,a),d=h.backend_util.getSliceBeginCoords(i,o.length),p=h.backend_util.getSliceSize(u,i,o.length),m=gr({inputs:{x:s},backend:e,attrs:{shape:l}}),y=Ro({inputs:{x:m},backend:e,attrs:{perm:c}}),_=gr({inputs:{x:y},backend:e,attrs:{shape:u}}),C=Lu({inputs:{x:_},backend:e,attrs:{begin:d,size:p}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_),C}};function $x(n,t,e,r,s){const o=h.util.sizeFromShape(r),i=h.util.makeZerosTypedArray(s,e);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(i[l]+=o>0?t[a]:1)}return i}function aN(n,t,e,r=!1){const s=n.shape[0],o=n.shape[1],i=(0,h.buffer)([s,e],t.dtype);for(let a=0;a<s;a++)for(let l=0;l<o;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=e||i.set(r?1:t.size>0?i.get(a,c)+t.get(a,l):i.get(a,c)+1,a,c)}return i}const UG={kernelName:h.Bincount,backendName:"cpu",kernelFunc:function VG(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:i}=r,c=$x(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}},zG=Hr((n,t)=>n&t),HG=ds(h.BitwiseAnd,zG),WG={kernelName:h.BitwiseAnd,backendName:"cpu",kernelFunc:HG},GG={kernelName:h.BroadcastArgs,backendName:"cpu",kernelFunc:function jG(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,a=h.backend_util.assertAndGetBroadcastShape(Array.from(o),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},lN=sl(n=>Math.ceil(n)),KG=Fc(h.Ceil,lN),XG={kernelName:h.Ceil,backendName:"cpu",kernelFunc:KG},qG=rr(h.ClipByValue,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),ZG={kernelName:h.ClipByValue,backendName:"cpu",kernelFunc:qG},QG={kernelName:h.ComplexAbs,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,r=new Float32Array(h.util.sizeFromShape(t.shape)),s=e.data.get(t.dataId),i=s.complexTensorInfos.imag,a=e.data.get(s.complexTensorInfos.real.dataId).values,l=e.data.get(i.dataId).values;for(let c=0;c<a.length;c++)r[c]=Math.hypot(a[c],l[c]);return e.makeOutput(r,t.shape,"float32")}};function cN(n,t,e,r){const s=h.util.getArrayFromDType(e,h.util.sizeFromShape(t));if(r&&"string"!==e){let o=0;n.forEach(i=>{const a=h.util.sizeFromShape(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;n.forEach(i=>{const a="string"===e?h.backend_util.fromUint8ToStringArray(i.vals):i.vals;let l=0;for(let c=0;c<i.shape[0];++c){const u=c*t[1]+o;for(let d=0;d<i.shape[1];++d)s[u+d]=a[l++]}o+=i.shape[1]})}return s}function dh(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.imag,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const JG={kernelName:h.Imag,backendName:"cpu",kernelFunc:dh};function hh(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,o=h.util.parseAxisParam(s,t[0].shape)[0],i=t.map(_=>_.shape);h.backend_util.assertParamsConsistent(i,o);let a=h.backend_util.computeOutShape(t.map(_=>_.shape),o);if(0===h.util.sizeFromShape(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(_=>h.util.sizeFromShape(_.shape)>0);if(1===l.length)return ol({inputs:{x:l[0]},backend:e});if("complex64"===l[0].dtype){const _=l.map(j=>$u({inputs:{input:j},backend:e})),C=l.map(j=>dh({inputs:{input:j},backend:e})),D=hh({inputs:_,backend:e,attrs:{axis:o}}),N=hh({inputs:C,backend:e,attrs:{axis:o}}),W=Xo({inputs:{real:D,imag:N},backend:e});return _.forEach(j=>e.disposeIntermediateTensorInfo(j)),C.forEach(j=>e.disposeIntermediateTensorInfo(j)),e.disposeIntermediateTensorInfo(D),e.disposeIntermediateTensorInfo(N),W}const c=l.map(_=>{const D=[-1,h.util.sizeFromShape(_.shape.slice(o))];return gr({inputs:{x:_},backend:e,attrs:{shape:D}})}),u=c.map(_=>({vals:e.data.get(_.dataId).values,shape:_.shape}));a=h.backend_util.computeOutShape(c.map(_=>_.shape),1);const p=cN(u,a,t[0].dtype,1===c[0].shape[0]),m=h.backend_util.computeOutShape(l.map(_=>_.shape),o),y=e.makeTensorInfo(m,t[0].dtype,p);return c.forEach(_=>e.disposeIntermediateTensorInfo(_)),y}const e8={kernelName:h.Concat,backendName:"cpu",kernelFunc:hh};function uN(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r;qt([s,o],"conv2d");const d=h.backend_util.convertConv2DDataFormat(l),p=h.backend_util.computeConv2DInfo(s.shape,o.shape,i,c,a,u,!1,d),m=p.filterHeight,y=p.filterWidth,_=p.dilationHeight,C=p.dilationWidth,D=p.padInfo.left,N=p.padInfo.top,W="channelsLast"===p.dataFormat,j=new h.TensorBuffer(p.outShape,s.dtype),te=h.util.computeStrides(s.shape),_e=h.util.computeStrides(o.shape),Ee=te[0],Ne=W?te[1]:te[2],je=W?te[2]:1,He=W?1:te[1],it=j.strides[0],at=W?j.strides[1]:j.strides[2],tt=W?j.strides[2]:1,lt=W?1:j.strides[1],st=e.data.get(s.dataId).values,Pe=e.data.get(o.dataId).values,We=j.values;for(let Ue=0;Ue<p.batchSize;++Ue){const Ye=Ue*Ee,pt=Ue*it;for(let yt=0;yt<p.outHeight;++yt){const Et=pt+yt*at,wt=yt*p.strideHeight-N;for(let vt=0;vt<m;++vt){const kt=wt+vt*_;if(kt<0||kt>=p.inHeight)continue;const jt=vt*_e[0],Ut=Ye+kt*Ne;for(let tn=0;tn<p.outWidth;++tn){const Xt=Et+tn*tt,Cn=tn*p.strideWidth-D;for(let Sn=0;Sn<y;++Sn){const sr=Cn+Sn*C;if(sr<0||sr>=p.inWidth)continue;const Vr=Ut+sr*je;let br=jt+Sn*_e[1];for(let dr=0;dr<p.inChannels;++dr){const Fr=st[Vr+dr*He];for(let kr=0;kr<p.outChannels;++kr)We[Xt+kr*lt]+=Fr*Pe[br+kr];br+=p.outChannels}}}}}}return e.makeTensorInfo(j.shape,j.dtype,We)}const t8={kernelName:h.Conv2D,backendName:"cpu",kernelFunc:uN},r8={kernelName:h.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function n8(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;qt([s,o],"conv2dBackpropFilter");const d=h.backend_util.convertConv2DDataFormat(l),p=h.backend_util.computeConv2DInfo(s.shape,u,i,1,a,c,!1,d),{strideHeight:m,strideWidth:y,filterHeight:_,filterWidth:C}=p,D="channelsLast"===p.dataFormat,N=new h.TensorBuffer(p.filterShape,"float32"),W=p.padInfo.left,j=p.padInfo.top,te=e.data.get(s.dataId).values,_e=e.data.get(o.dataId).values,Ee=new h.TensorBuffer(s.shape,s.dtype,te),Ne=new h.TensorBuffer(o.shape,o.dtype,_e);for(let je=0;je<_;++je){const He=Math.max(0,Math.ceil((j-je)/m)),it=Math.min(p.outHeight,(p.inHeight+j-je)/m);for(let at=0;at<C;++at){const tt=Math.max(0,Math.ceil((W-at)/y)),lt=Math.min(p.outWidth,(p.inWidth+W-at)/y);for(let st=0;st<p.inChannels;++st)for(let Pe=0;Pe<p.outChannels;++Pe){let We=0;for(let Ue=0;Ue<p.batchSize;++Ue)for(let Ye=He;Ye<it;++Ye){const pt=je+Ye*m-j;for(let yt=tt;yt<lt;++yt){const Et=at+yt*y-W;We+=D?Ee.get(Ue,pt,Et,st)*Ne.get(Ue,Ye,yt,Pe):Ee.get(Ue,st,pt,Et)*Ne.get(Ue,Pe,Ye,yt)}}N.set(We,je,at,st,Pe)}}}return e.makeTensorInfo(N.shape,N.dtype,N.values)}},o8={kernelName:h.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function s8(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{inputShape:i,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r;qt([s,o],"conv2dBackpropInput");const d=h.util.computeStrides(o.shape),p=h.util.computeStrides(s.shape);let m=h.backend_util.convertConv2DDataFormat(c);const y=h.backend_util.computeConv2DInfo(i,o.shape,a,1,l,u,!1,m),_=new h.TensorBuffer(y.inShape,"float32"),C=_.values,D=e.data.get(s.dataId).values,N=e.data.get(o.dataId).values,[W,j,te]=d,{batchSize:_e,filterHeight:Ee,filterWidth:Ne,inChannels:je,inHeight:He,inWidth:it,outChannels:at,outHeight:tt,outWidth:lt,strideHeight:st,strideWidth:Pe}=y;m=y.dataFormat;const We=Ee-1-y.padInfo.top,Ue=Ne-1-y.padInfo.left,Ye="channelsLast"===m,pt=_.strides[0],yt=Ye?_.strides[1]:_.strides[2],Et=Ye?_.strides[2]:1,wt=Ye?1:_.strides[1],vt=p[0],kt=Ye?p[1]:p[2],jt=Ye?p[2]:1,Ut=Ye?1:p[1];for(let tn=0;tn<_e;++tn)for(let Xt=0;Xt<je;++Xt)for(let Cn=0;Cn<He;++Cn){const Sn=Cn-We,sr=Math.max(0,Math.ceil(Sn/st)),yr=Math.min(tt,(Ee+Sn)/st);for(let Vr=0;Vr<it;++Vr){const br=Vr-Ue,dr=Math.max(0,Math.ceil(br/Pe)),Fr=Math.min(lt,(Ne+br)/Pe);let kr=0;for(let Fs=sr;Fs<yr;++Fs){const Yc=Fs*st-Sn;for(let Ci=dr;Ci<Fr;++Ci){const Sa=vt*tn+kt*Fs+jt*Ci,Xl=W*(Ee-1-Yc)+j*(Ne-1-(Ci*Pe-br))+te*Xt;for(let Qc=0;Qc<at;++Qc)kr+=D[Sa+Ut*Qc]*N[Xl+Qc]}}C[pt*tn+yt*Cn+Et*Vr+wt*Xt]=kr}}return e.makeTensorInfo(_.shape,_.dtype,_.values)}},a8={kernelName:h.Conv3D,backendName:"cpu",kernelFunc:function i8(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l}=r;qt([s,o],"conv3d");const c=h.backend_util.computeConv3DInfo(s.shape,o.shape,i,l,a),{filterDepth:u,filterHeight:d,filterWidth:p,dilationDepth:m,dilationHeight:y,dilationWidth:_,padInfo:C}=c,D=C.front,N=C.left,W=C.top,j=new h.TensorBuffer(c.outShape,s.dtype),te=e.data.get(s.dataId).values,_e=e.data.get(o.dataId).values,Ee=j.values,Ne=h.util.computeStrides(s.shape),je=h.util.computeStrides(o.shape);for(let He=0;He<c.batchSize;++He){const it=He*Ne[0],at=He*j.strides[0];for(let tt=0;tt<c.outDepth;++tt){const lt=at+tt*j.strides[1],st=tt*c.strideDepth-D;for(let Pe=0;Pe<u;++Pe){const We=st+Pe*m;if(We<0||We>=c.inDepth)continue;const Ue=Pe*je[0],Ye=it+We*Ne[1];for(let pt=0;pt<c.outHeight;++pt){const yt=lt+pt*j.strides[2],Et=pt*c.strideHeight-W;for(let wt=0;wt<d;++wt){const vt=Et+wt*y;if(vt<0||vt>=c.inHeight)continue;const kt=Ue+wt*je[1],jt=Ye+vt*Ne[2];for(let Ut=0;Ut<c.outWidth;++Ut){const tn=yt+Ut*c.outChannels,Xt=Ut*c.strideWidth-N;for(let Cn=0;Cn<p;++Cn){const Sn=Xt+Cn*_;if(Sn<0||Sn>=c.inWidth)continue;const yr=jt+Sn*c.inChannels;let Vr=kt+Cn*je[2];for(let br=0;br<c.inChannels;++br){const dr=te[yr+br];for(let Fr=0;Fr<c.outChannels;++Fr)Ee[tn+Fr]+=dr*_e[Vr+Fr];Vr+=c.outChannels}}}}}}}}return e.makeTensorInfo(j.shape,j.dtype,j.values)}},c8={kernelName:h.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function l8(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,pad:a,filterShape:l}=r;qt([s,o],"conv3dBackpropFilterV2");const c=h.util.computeStrides(s.shape),u=h.util.computeStrides(o.shape),d=h.backend_util.computeConv3DInfo(s.shape,l,i,1,a),p=d.strideDepth,m=d.strideHeight,y=d.strideWidth,_=d.filterDepth,C=d.filterHeight,D=d.filterWidth,N=new h.TensorBuffer(d.filterShape,"float32"),W=N.values,[j,te,_e,Ee]=N.strides,Ne=e.data.get(o.dataId).values,[je,He,it,at]=u,tt=e.data.get(s.dataId).values,[lt,st,Pe,We]=c,Ue=d.padInfo.front,Ye=d.padInfo.left,pt=d.padInfo.top;for(let yt=0;yt<_;++yt){const Et=Math.max(0,Math.ceil((Ue-yt)/p)),wt=Math.min(d.outDepth,(d.inDepth+Ue-yt)/p),vt=yt*j;for(let kt=0;kt<C;++kt){const jt=Math.max(0,Math.ceil((pt-kt)/m)),Ut=Math.min(d.outHeight,(d.inHeight+pt-kt)/m),tn=kt*te+vt;for(let Xt=0;Xt<D;++Xt){const Cn=Math.max(0,Math.ceil((Ye-Xt)/y)),Sn=Math.min(d.outWidth,(d.inWidth+Ye-Xt)/y),sr=Xt*_e+tn;for(let yr=0;yr<d.inChannels;++yr){const Vr=yr*Ee+sr;for(let br=0;br<d.outChannels;++br){let dr=0;for(let Fr=0;Fr<d.batchSize;++Fr){const kr=Fr*lt,Kl=Fr*je;for(let Fs=Et;Fs<wt;++Fs){const Ci=(yt+Fs*p-Ue)*st+kr,td=Fs*He+Kl;for(let Sa=jt;Sa<Ut;++Sa){const Qc=(kt+Sa*m-pt)*Pe+Ci,Jc=Sa*it+td;for(let eu=Cn;eu<Sn;++eu)dr+=tt[(Xt+eu*y-Ye)*We+Qc+yr]*Ne[eu*at+Jc+br]}}}W[Vr+br]=dr}}}}}return e.makeTensorInfo(N.shape,N.dtype,N.values)}},d8={kernelName:h.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function u8(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{pad:i,strides:a,inputShape:l}=r;qt([s],"conv3dBackpropInputV2");const c=h.util.computeStrides(s.shape),u=h.util.computeStrides(o.shape),d=h.backend_util.computeConv3DInfo(l,o.shape,a,1,i),p=new h.TensorBuffer(d.inShape,"float32"),m=p.values,[y,_,C,D]=p.strides,N=e.data.get(s.dataId).values,[W,j,te,_e]=c,Ee=e.data.get(o.dataId).values,[Ne,je,He,it]=u,{batchSize:at,filterDepth:tt,filterHeight:lt,filterWidth:st,inChannels:Pe,inDepth:We,inHeight:Ue,inWidth:Ye,outChannels:pt,outDepth:yt,outHeight:Et,outWidth:wt,strideDepth:vt,strideHeight:kt,strideWidth:jt}=d,Ut=tt-1-d.padInfo.front,tn=lt-1-d.padInfo.top,Xt=st-1-d.padInfo.left;for(let Cn=0;Cn<at;++Cn)for(let Sn=0;Sn<Pe;++Sn)for(let sr=0;sr<We;++sr){const yr=sr-Ut,Vr=Math.max(0,Math.ceil(yr/vt)),br=Math.min(yt,(tt+yr)/vt);for(let dr=0;dr<Ue;++dr){const Fr=dr-tn,kr=Math.max(0,Math.ceil(Fr/kt)),Kl=Math.min(Et,(lt+Fr)/kt);for(let Fs=0;Fs<Ye;++Fs){const Yc=Fs-Xt,Ci=Math.max(0,Math.ceil(Yc/jt)),td=Math.min(wt,(st+Yc)/jt);let Sa=0;for(let Xl=Vr;Xl<br;++Xl){const Qc=Xl*vt-yr;for(let Jc=kr;Jc<Kl;++Jc){const eu=Jc*kt-Fr;for(let Jf=Ci;Jf<td;++Jf){const kw=W*Cn+j*Xl+te*Jc+_e*Jf,Zue=Ne*(tt-1-Qc)+je*(lt-1-eu)+He*(st-1-(Jf*jt-Yc))+it*Sn;for(let Pb=0;Pb<pt;++Pb)Sa+=N[kw+Pb]*Ee[Zue+Pb]}}}m[y*Cn+_*sr+C*dr+D*Fs+Sn]=Sa}}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}},h8=rr(h.Cos,n=>Math.cos(n)),p8={kernelName:h.Cos,backendName:"cpu",kernelFunc:h8},f8=rr(h.Cosh,n=>Math.cosh(n)),m8={kernelName:h.Cosh,backendName:"cpu",kernelFunc:f8},y8={kernelName:h.CropAndResize,backendName:"cpu",kernelFunc:function g8(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:o,boxInd:i}=t,{cropSize:a,method:l,extrapolationValue:c}=r,[u,d,p,m]=s.shape,y=o.shape[0],[_,C]=a,D=(0,h.buffer)([y,_,C,m],"float32"),N=e.data.get(o.dataId).values,W=e.data.get(i.dataId).values,j=e.data.get(s.dataId).values,te=h.util.computeStrides(s.shape),_e=h.util.computeStrides(D.shape);for(let Ee=0;Ee<y;Ee++){const Ne=4*Ee,je=N[Ne],He=N[Ne+1],it=N[Ne+2],at=N[Ne+3],tt=W[Ee];if(tt>=u)continue;const lt=_>1?(it-je)*(d-1)/(_-1):0,st=C>1?(at-He)*(p-1)/(C-1):0;for(let Pe=0;Pe<_;Pe++){const We=_>1?je*(d-1)+Pe*lt:.5*(je+it)*(d-1);if(We<0||We>d-1)for(let Ue=0;Ue<C;Ue++)for(let Ye=0;Ye<m;Ye++)D.values[Ye+Ue*_e[2]+Pe*_e[1]+Ee*_e[0]]=c;else if("bilinear"===l){const Ue=Math.floor(We),Ye=Math.ceil(We),pt=We-Ue;for(let yt=0;yt<C;yt++){const Et=C>1?He*(p-1)+yt*st:.5*(He+at)*(p-1);if(Et<0||Et>p-1){for(let jt=0;jt<m;jt++)D.values[jt+yt*_e[2]+Pe*_e[1]+Ee*_e[0]]=c;continue}const wt=Math.floor(Et),vt=Math.ceil(Et),kt=Et-wt;for(let jt=0;jt<m;jt++){let Ut=jt+wt*te[2]+Ue*te[1]+tt*te[0];const tn=j[Ut];Ut=jt+vt*te[2]+Ue*te[1]+tt*te[0];const Xt=j[Ut];Ut=jt+wt*te[2]+Ye*te[1]+tt*te[0];const Cn=j[Ut];Ut=jt+vt*te[2]+Ye*te[1]+tt*te[0];const Sn=j[Ut],sr=tn+(Xt-tn)*kt;Ut=jt+yt*_e[2]+Pe*_e[1]+Ee*_e[0],D.values[Ut]=sr+(Cn+(Sn-Cn)*kt-sr)*pt}}}else for(let Ue=0;Ue<C;++Ue){const Ye=C>1?He*(p-1)+Ue*st:.5*(He+at)*(p-1);if(Ye<0||Ye>p-1){for(let Et=0;Et<m;Et++)D.values[Et+Ue*_e[2]+Pe*_e[1]+Ee*_e[0]]=c;continue}const pt=Math.round(Ye),yt=Math.round(We);for(let Et=0;Et<m;Et++)D.values[Et+Ue*_e[2]+Pe*_e[1]+Ee*_e[0]]=j[Et+pt*te[2]+yt*te[1]+tt*te[0]]}}}return e.makeTensorInfo(D.shape,D.dtype,D.values)}},_8={kernelName:h.Cumprod,backendName:"cpu",kernelFunc:function b8(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:i,reverse:a}=r;qt(s,"cumprod");const l=h.backend_util.getAxesPermutation([o],s.shape.length);let c=s;null!=l&&(c=Ro({inputs:{x:s},backend:e,attrs:{perm:l}}));const u=h.backend_util.getInnerMostAxes(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const d=(0,h.upcastType)(c.dtype,"int32"),p=h.util.makeOnesTypedArray(h.util.sizeFromShape(c.shape),d),m=e.data.get(c.dataId).values,y=c.shape[c.shape.length-1],_=a?(D,N)=>D+y-N-1:(D,N)=>D+N;for(let D=0;D<m.length;D+=y)for(let N=0;N<y;N++){const W=_(D,N);if(0===N)p[W]=i?1:m[W];else{const j=_(D,N-1);p[W]=i?m[j]*p[j]:m[W]*p[j]}}const C=e.makeTensorInfo(c.shape,d,p);if(null!=l){const N=Ro({inputs:{x:C},backend:e,attrs:{perm:h.backend_util.getUndoAxesPermutation(l)}});return e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(c),N}return C}},x8={kernelName:h.Cumsum,backendName:"cpu",kernelFunc:function v8(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:i,reverse:a}=r;qt(s,"cumsum");const l=h.backend_util.getAxesPermutation([o],s.shape.length);let c=s;null!=l&&(c=Ro({inputs:{x:s},backend:e,attrs:{perm:l}}));const u=h.backend_util.getInnerMostAxes(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const d=(0,h.upcastType)(c.dtype,"int32"),p=h.util.makeZerosTypedArray(h.util.sizeFromShape(c.shape),d),m=e.data.get(c.dataId).values,y=c.shape[c.shape.length-1],_=a?(D,N)=>D+y-N-1:(D,N)=>D+N;for(let D=0;D<m.length;D+=y)for(let N=0;N<y;N++){const W=_(D,N);if(0===N)p[W]=i?0:m[W];else{const j=_(D,N-1);p[W]=i?m[j]+p[j]:m[W]+p[j]}}const C=e.makeTensorInfo(c.shape,d,p);if(null!=l){const N=Ro({inputs:{x:C},backend:e,attrs:{perm:h.backend_util.getUndoAxesPermutation(l)}});return e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(c),N}return C}},w8={kernelName:h.DenseBincount,backendName:"cpu",kernelFunc:function C8(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const u=$x(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,u)}if(2===s.shape.length){const u=aN(e.bufferSync(s),e.bufferSync(o),i,a);return e.makeTensorInfo(u.shape,o.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},E8={kernelName:h.DepthToSpace,backendName:"cpu",kernelFunc:function S8(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:o,dataFormat:i}=r;h.util.assert("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const a=s.shape[0],l=s.shape[1],c=s.shape[2],u=s.shape[3],d=l*o,p=c*o,m=u/(o*o),y=e.data.get(s.dataId).values,_=new Float32Array(a*d*p*m);let C=0;for(let D=0;D<a;++D)for(let N=0;N<d;++N){const W=Math.floor(N/o),j=N%o;for(let te=0;te<p;++te){const _e=Math.floor(te/o),Ne=(j*o+te%o)*m;for(let je=0;je<m;++je)_[C++]=y[je+Ne+u*(_e+c*(W+l*D))]}}return e.makeTensorInfo([a,d,p,m],s.dtype,_)}};function dN(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l,dimRoundingMode:c}=r;qt([s,o],"depthwiseConv2DNative");const u=h.util.computeStrides(s.shape),d=h.util.computeStrides(o.shape);let p=l;null==p&&(p=[1,1]),h.util.assert(h.backend_util.eitherStridesOrDilationsAreOne(i,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);const m=h.backend_util.computeConv2DInfo(s.shape,o.shape,i,p,a,c,!0),{filterHeight:y,filterWidth:_,dilationHeight:C,dilationWidth:D,padInfo:N}=m,W=N.left,j=N.top,te=m.outChannels/m.inChannels,_e=new h.TensorBuffer(m.outShape,s.dtype),Ee=e.data.get(s.dataId).values,Ne=e.data.get(o.dataId).values,je=_e.values;for(let He=0;He<m.batchSize;++He){const it=He*u[0],at=He*_e.strides[0];for(let tt=0;tt<m.outHeight;++tt){const lt=at+tt*_e.strides[1],st=tt*m.strideHeight-j;for(let Pe=0;Pe<y;++Pe){const We=st+Pe*C;if(We<0||We>=m.inHeight)continue;const Ue=Pe*d[0],Ye=it+We*u[1];for(let pt=0;pt<m.outWidth;++pt){const yt=lt+pt*_e.strides[2],Et=pt*m.strideWidth-W;for(let wt=0;wt<_;++wt){const vt=Et+wt*D;if(vt<0||vt>=m.inWidth)continue;const jt=Ye+vt*m.inChannels;let Ut=yt,tn=Ue+wt*d[1];for(let Xt=0;Xt<m.inChannels;++Xt){const Cn=Ee[jt+Xt];for(let Sn=0;Sn<te;++Sn)je[Ut+Sn]+=Cn*Ne[tn+Sn];Ut+=te,tn+=te}}}}}}return e.makeTensorInfo(_e.shape,_e.dtype,_e.values)}const D8={kernelName:h.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:dN},I8={kernelName:h.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function T8(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r;qt([s,o],"depthwiseConv2dNativeBackpropFilter");const d=h.backend_util.computeConv2DInfo(s.shape,u,i,a,l,c,!0),{strideHeight:p,strideWidth:m,filterHeight:y,filterWidth:_}=d,C=new h.TensorBuffer(d.filterShape,"float32"),D=d.padInfo.left,N=d.padInfo.top,W=d.outChannels/d.inChannels,j=e.data.get(s.dataId).values,te=new h.TensorBuffer(s.shape,s.dtype,j),_e=e.data.get(o.dataId).values,Ee=new h.TensorBuffer(o.shape,o.dtype,_e);for(let Ne=0;Ne<y;++Ne){const je=Math.max(0,Math.ceil((N-Ne)/p)),He=Math.min(d.outHeight,(d.inHeight+N-Ne)/p);for(let it=0;it<_;++it){const at=Math.max(0,Math.ceil((D-it)/m)),tt=Math.min(d.outWidth,(d.inWidth+D-it)/m);for(let lt=0;lt<d.outChannels;++lt){const st=Math.trunc(lt/W),Pe=lt%W;let We=0;for(let Ue=0;Ue<d.batchSize;++Ue)for(let Ye=je;Ye<He;++Ye){const pt=Ne+Ye*p-N;for(let yt=at;yt<tt;++yt)We+=te.get(Ue,pt,it+yt*m-D,st)*Ee.get(Ue,Ye,yt,lt)}C.set(We,Ne,it,st,Pe)}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}},N8={kernelName:h.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function A8(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r;qt([s,o],"depthwiseConv2DNativeBackpropInput");const d=h.util.computeStrides(s.shape),p=h.util.computeStrides(o.shape),m=h.backend_util.computeConv2DInfo(u,o.shape,i,a,l,c,!0),y=new h.TensorBuffer(m.inShape,"float32"),_=y.values,[C,D,N]=y.strides,W=e.data.get(s.dataId).values,[j,te,_e]=d,Ee=e.data.get(o.dataId).values,[Ne,je,He]=p,{batchSize:it,filterHeight:at,filterWidth:tt,inChannels:lt,inHeight:st,inWidth:Pe,outChannels:We,outHeight:Ue,outWidth:Ye,strideHeight:pt,strideWidth:yt}=m,Et=at-1-m.padInfo.top,wt=tt-1-m.padInfo.left,vt=We/lt;for(let kt=0;kt<it;++kt)for(let jt=0;jt<lt;++jt)for(let Ut=0;Ut<st;++Ut){const tn=Ut-Et,Xt=Math.max(0,Math.ceil(tn/pt)),Cn=Math.min(Ue,(at+tn)/pt);for(let Sn=0;Sn<Pe;++Sn){const sr=Sn-wt,yr=Math.max(0,Math.ceil(sr/yt)),Vr=Math.min(Ye,(tt+sr)/yt);let br=0;for(let dr=Xt;dr<Cn;++dr){const Fr=dr*pt-tn;for(let kr=yr;kr<Vr;++kr){const Fs=j*kt+te*dr+_e*kr,Yc=Ne*(at-1-Fr)+je*(tt-1-(kr*yt-sr))+He*jt;for(let Ci=0;Ci<vt;++Ci)br+=W[Fs+(jt*vt+Ci)]*Ee[Yc+Ci]}}_[C*kt+D*Ut+N*Sn+jt]=br}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},M8={kernelName:h.Diag,backendName:"cpu",kernelFunc:function k8(n){const{inputs:t,backend:e}=n,{x:r}=t,s=h.util.sizeFromShape(r.shape),o=e.data.get(r.dataId).values,i=(0,h.buffer)([s,s],r.dtype),a=i.values;for(let c=0;c<o.length;c++)a[c*s+c]=o[c];const l=[...r.shape,...r.shape];return e.makeTensorInfo(l,i.dtype,i.values)}},R8={kernelName:h.Dilation2D,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s}=n,{strides:o,pad:i,dilations:a}=e,l=t,c=l.data.get(r.dataId).values,u=r.shape.length,d=l.data.get(s.dataId).values,p=s.shape.length,{batchSize:m,inHeight:y,inWidth:_,inChannels:C,outHeight:D,outWidth:N,padInfo:W,strideHeight:j,strideWidth:te,filterHeight:_e,filterWidth:Ee,dilationHeight:Ne,dilationWidth:je,outShape:He}=h.backend_util.computeDilation2DInfo(r.shape,s.shape,o,i,"NHWC",a),it=h.util.sizeFromShape(He),at=He.length,tt=h.util.getArrayFromDType(r.dtype,it);for(let st=0;st<m;++st)for(let Pe=0;Pe<D;++Pe){const We=Pe*j-W.top;for(let Ue=0;Ue<N;++Ue){const Ye=Ue*te-W.left;for(let pt=0;pt<C;++pt){let yt=Number.MIN_SAFE_INTEGER;for(let wt=0;wt<_e;++wt){const vt=We+wt*Ne;if(vt>=0&&vt<y)for(let kt=0;kt<Ee;++kt){const jt=Ye+kt*je;if(jt>=0&&jt<_){const Ut=h.util.locToIndex([st,vt,jt,pt],u,h.util.computeStrides(r.shape)),tn=h.util.locToIndex([wt,kt,pt],p,h.util.computeStrides(s.shape)),Xt=c[Ut]+d[tn];Xt>yt&&(yt=Xt)}}}tt[h.util.locToIndex([st,Pe,Ue,pt],at,h.util.computeStrides(He))]=yt}}}return{dataId:l.write(h.util.toTypedArray(tt,r.dtype),He,r.dtype),shape:He,dtype:r.dtype}}},O8={kernelName:h.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:o}=n,{strides:i,pad:a,dilations:l}=e,c=t,u=h.util.toNestedArray(r.shape,c.data.get(r.dataId).values),d=h.util.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:m,inWidth:y,inChannels:_,outHeight:C,outWidth:D,padInfo:N,strideHeight:W,strideWidth:j,filterHeight:te,filterWidth:_e,dilationHeight:Ee,dilationWidth:Ne,outShape:je}=h.backend_util.computeDilation2DInfo(r.shape,s.shape,i,a,"NHWC",l);h.util.assert(o.rank===je.length,()=>`Error in ${h.Dilation2DBackpropFilter}, dy must have the same rank as output ${je.length}, but got ${o.rank}`);const He=h.util.toNestedArray(je,c.data.get(o.dataId).values),it=h.util.makeZerosNestedTypedArray(s.shape,s.dtype);for(let tt=0;tt<p;++tt)for(let lt=0;lt<C;++lt){const st=lt*W-N.top;for(let Pe=0;Pe<D;++Pe){const We=Pe*j-N.left;for(let Ue=0;Ue<_;++Ue){let Ye=Number.MIN_SAFE_INTEGER,pt=0,yt=0;for(let Et=0;Et<te;++Et){const wt=st+Et*Ee;if(wt>=0&&wt<m)for(let vt=0;vt<_e;++vt){const kt=We+vt*Ne;if(kt>=0&&kt<y){const jt=u[tt][wt][kt][Ue]+d[Et][vt][Ue];jt>Ye&&(Ye=jt,pt=Et,yt=vt)}}}it[pt][yt][Ue]+=He[tt][lt][Pe][Ue]}}}return{dataId:c.write(h.util.toTypedArray(it,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},F8={kernelName:h.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:o}=n,{strides:i,pad:a,dilations:l}=e,c=t,u=h.util.toNestedArray(r.shape,c.data.get(r.dataId).values),d=h.util.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:m,inWidth:y,inChannels:_,outHeight:C,outWidth:D,padInfo:N,strideHeight:W,strideWidth:j,filterHeight:te,filterWidth:_e,dilationHeight:Ee,dilationWidth:Ne,outShape:je}=h.backend_util.computeDilation2DInfo(r.shape,s.shape,i,a,"NHWC",l);h.util.assert(o.rank===je.length,()=>`Error in ${h.Dilation2DBackpropInput}, dy must have the same rank as output ${je.length}, but got ${o.rank}`);const He=h.util.toNestedArray(je,c.data.get(o.dataId).values),it=h.util.makeZerosNestedTypedArray(r.shape,r.dtype);for(let tt=0;tt<p;++tt)for(let lt=0;lt<C;++lt){const st=lt*W-N.top;for(let Pe=0;Pe<D;++Pe){const We=Pe*j-N.left;for(let Ue=0;Ue<_;++Ue){let Ye=Number.MIN_SAFE_INTEGER,pt=st<0?0:st,yt=We<0?0:We;for(let Et=0;Et<te;++Et){const wt=st+Et*Ee;if(wt>=0&&wt<m)for(let vt=0;vt<_e;++vt){const kt=We+vt*Ne;if(kt>=0&&kt<y){const jt=u[tt][wt][kt][Ue]+d[Et][vt][Ue];jt>Ye&&(Ye=jt,pt=wt,yt=kt)}}}it[tt][pt][yt][Ue]+=He[tt][lt][Pe][Ue]}}}return{dataId:c.write(h.util.toTypedArray(it,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Lx=Hr((n,t)=>n*t),P8=Ox((n,t,e,r)=>({real:n*e-t*r,imag:n*r+t*e})),Ey=ds(h.Multiply,Lx,P8),$8={kernelName:h.Multiply,backendName:"cpu",kernelFunc:Ey};function gf(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;let a;qt(s,"sum"),a="bool"===s.dtype?Pc({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):ol({inputs:{x:s},backend:e});const l=a.shape.length,c=h.util.parseAxisParam(o,a.shape),u=h.backend_util.getAxesPermutation(c,l);let d=c,p=a;null!=u&&(p=Ro({inputs:{x:a},backend:e,attrs:{perm:u}}),d=h.backend_util.getInnerMostAxes(d.length,l)),h.backend_util.assertAxesAreInnerMostDims("sum",d,p.shape.length);const[m,y]=h.backend_util.computeOutAndReduceShapes(p.shape,d);let C=Sy(e,m,h.backend_util.upcastType(p.dtype,"int32"));const D=h.util.sizeFromShape(y),N=e.data.get(C.dataId).values,W=e.data.get(p.dataId).values;for(let j=0;j<N.length;++j){const te=j*D;let _e=0;for(let Ee=0;Ee<D;++Ee)_e+=W[te+Ee];N[j]=_e}if(i){const te=C;C=gr({inputs:{x:C},backend:e,attrs:{shape:h.backend_util.expandShapeToKeepDim(C.shape,c)}}),e.disposeIntermediateTensorInfo(te)}return e.disposeIntermediateTensorInfo(a),null!=u&&e.disposeIntermediateTensorInfo(p),C}const L8={kernelName:h.Sum,backendName:"cpu",kernelFunc:gf},V8={kernelName:h.Einsum,backendName:"cpu",kernelFunc:function B8(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,o=t,{allDims:i,summedDims:a,idDims:l}=h.backend_util.decodeEinsumEquation(s,o.length);h.backend_util.checkEinsumDimSizes(i.length,l,o);const{path:c,steps:u}=h.backend_util.getEinsumComputePath(a,l),d=u.length;let p=null,m=i.length;const y=[];for(let _=0;_<d;++_){for(const C of u[_]){const{permutationIndices:D,expandDims:N}=h.backend_util.getEinsumPermutation(m,l[C]);let W;h.backend_util.isIdentityPermutation(D)?W=o[C]:(W=Ro({inputs:{x:o[C]},backend:e,attrs:{perm:D}}),y.push(W));const j=W.shape.slice();for(let te=0;te<N.length;++te)j.splice(N[te],0,1);h.util.arraysEqual(W.shape,j)||(W=gr({inputs:{x:W},backend:e,attrs:{shape:j}}),y.push(W)),null===p?p=W:(p=Ey({inputs:{a:W,b:p},backend:e}),y.push(p))}_<d-1&&(c[_]>=0&&(p=gf({inputs:{x:p},backend:e,attrs:{axis:c[_]-(i.length-m),keepDims:!1}}),y.push(p)),m--)}for(const _ of y)_!==p&&e.disposeIntermediateTensorInfo(_);return p}},z8={kernelName:h.EluGrad,backendName:"cpu",kernelFunc:function U8(n){const{inputs:t,backend:e}=n,{dy:r,y:s}=t;qt([r,s],"eluGrad");const o=new Float32Array(h.util.sizeFromShape(s.shape)),i=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const c=i[l];o[l]=c>=0?a[l]:a[l]*(c+1)}return e.makeTensorInfo(s.shape,"float32",o)}},hN=Hr((n,t)=>n===t?1:0),pN=ds(h.Equal,hN,null,"bool"),H8={kernelName:h.Equal,backendName:"cpu",kernelFunc:pN},W8=h.backend_util.ERF_P,j8=h.backend_util.ERF_A1,G8=h.backend_util.ERF_A2,K8=h.backend_util.ERF_A3,X8=h.backend_util.ERF_A4,q8=h.backend_util.ERF_A5,Z8=rr(h.Erf,n=>{const t=Math.sign(n),e=Math.abs(n),r=1/(1+W8*e);return t*(1-((((q8*r+X8)*r+K8)*r+G8)*r+j8)*r*Math.exp(-e*e))}),Y8={kernelName:h.Erf,backendName:"cpu",kernelFunc:Z8},fN=sl(n=>Math.exp(n)),mN=Fc(h.Exp,fN,"float32"),Q8={kernelName:h.Exp,backendName:"cpu",kernelFunc:mN};function Dy(n){const{inputs:t,backend:e,attrs:r}=n,{input:s}=t,{dim:o}=r,i=s.shape.length,a=s.shape.slice();let l=o;return o<0&&(h.util.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+o+1),a.splice(l,0,1),gr({inputs:{x:s},backend:e,attrs:{shape:a}})}const J8={kernelName:h.ExpandDims,backendName:"cpu",kernelFunc:Dy},gN=sl(n=>Math.expm1(n)),e6=Fc(h.Expm1,gN),t6={kernelName:h.Expm1,backendName:"cpu",kernelFunc:e6},n6=Hr((n,t)=>n/t),Bx=ds(h.RealDiv,n6),Vx={kernelName:h.RealDiv,backendName:"cpu",kernelFunc:Bx},yN=Hr((n,t)=>n-t),r6=Ox((n,t,e,r)=>({real:n-e,imag:t-r})),Ux=ds(h.Sub,yN,r6),s6={kernelName:h.Sub,backendName:"cpu",kernelFunc:Ux};function bN(n,t,e){const r=n.shape,s=r[0],o=r[1],i=e.data.get(n.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,c=[s,o],u=h.util.sizeFromShape(c),d=h.util.getTypedArrayFromDType("float32",u),p=h.util.getTypedArrayFromDType("float32",u);for(let C=0;C<s;C++){const D=Lu({inputs:{x:a},backend:e,attrs:{begin:[C,0],size:[1,o]}}),N=Lu({inputs:{x:l},backend:e,attrs:{begin:[C,0],size:[1,o]}}),W=Xo({inputs:{real:D,imag:N},backend:e}),{real:j,imag:te}=o6(W,t,e),_e=h.backend_util.mergeRealAndImagArrays(j,te);for(let Ee=0;Ee<o;Ee++){const Ne=h.backend_util.getComplexWithIndex(_e,Ee);d[C*o+Ee]=Ne.real,p[C*o+Ee]=Ne.imag}e.disposeIntermediateTensorInfo(D),e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(W)}const m=e.makeTensorInfo(c,"float32",d),y=e.makeTensorInfo(c,"float32",p),_=Xo({inputs:{real:m,imag:y},backend:e});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),_}function o6(n,t,e){const r=h.util.sizeFromShape(n.shape),s=e.data.get(n.dataId),o=e.data.get(s.complexTensorInfos.real.dataId).values,i=e.data.get(s.complexTensorInfos.imag.dataId).values;if(function i6(n){return 0==(n&n-1)}(r)){const a=zx(o,i,r,t,e),l=[n.shape[0],n.shape[1]];if(t){const c=e.makeTensorInfo(l,"float32",a.real),u=e.makeTensorInfo(l,"float32",a.imag),d=e.makeTensorInfo([],"float32",h.util.createScalarValue(r,"float32")),p=ol({inputs:{x:d},backend:e}),m=Vx.kernelFunc({inputs:{a:c,b:d},backend:e}),y=Vx.kernelFunc({inputs:{a:u,b:p},backend:e}),_=e.data.get(m.dataId).values,C=e.data.get(y.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),{real:_,imag:C}}return a}{const l=function a6(n,t,e){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let o=0,i=0;for(let a=0;a<t;a++){const l=h.backend_util.exponent(s*a,t,e),c=h.backend_util.getComplexWithIndex(n,a);o+=c.real*l.real-c.imag*l.imag,i+=c.real*l.imag+c.imag*l.real}e&&(o/=t,i/=t),h.backend_util.assignToTypedArray(r,o,i,s)}return r}(h.backend_util.mergeRealAndImagArrays(o,i),r,t);return h.backend_util.splitRealAndImagArrays(l)}}function zx(n,t,e,r,s){if(1===e)return{real:n,imag:t};const o=h.backend_util.mergeRealAndImagArrays(n,t),i=e/2,a=h.backend_util.complexWithEvenIndex(o),l=a.real,c=a.imag,u=[l.length],d=s.makeTensorInfo(u,"float32",l),p=s.makeTensorInfo(u,"float32",c),m=Xo({inputs:{real:d,imag:p},backend:s}),y=h.backend_util.complexWithOddIndex(o),_=y.real,C=y.imag,D=[_.length],N=s.makeTensorInfo(D,"float32",_),W=s.makeTensorInfo(D,"float32",C),j=Xo({inputs:{real:N,imag:W},backend:s}),te=zx(l,c,i,r,s),_e=te.real,Ee=te.imag,Ne=[_e.length],je=s.makeTensorInfo(Ne,"float32",_e),He=s.makeTensorInfo(Ne,"float32",Ee),it=Xo({inputs:{real:je,imag:He},backend:s}),at=zx(_,C,i,r,s),tt=at.real,lt=at.imag,st=[tt.length],Pe=s.makeTensorInfo(st,"float32",tt),We=s.makeTensorInfo(st,"float32",lt),Ue=Xo({inputs:{real:Pe,imag:We},backend:s}),Ye=h.backend_util.exponents(e,r),pt=[Ye.real.length],yt=s.makeTensorInfo(pt,"float32",Ye.real),Et=s.makeTensorInfo(pt,"float32",Ye.imag),wt=Xo({inputs:{real:yt,imag:Et},backend:s}),vt=Ey({inputs:{a:wt,b:Ue},backend:s}),kt=uh({inputs:{a:it,b:vt},backend:s}),jt=Ux({inputs:{a:it,b:vt},backend:s}),Ut=$u({inputs:{input:kt},backend:s}),tn=$u({inputs:{input:jt},backend:s}),Xt=dh({inputs:{input:kt},backend:s}),Cn=dh({inputs:{input:jt},backend:s}),Sn=hh({inputs:[Ut,tn],backend:s,attrs:{axis:0}}),sr=hh({inputs:[Xt,Cn],backend:s,attrs:{axis:0}}),yr=s.data.get(Sn.dataId).values,Vr=s.data.get(sr.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(m),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(je),s.disposeIntermediateTensorInfo(He),s.disposeIntermediateTensorInfo(it),s.disposeIntermediateTensorInfo(Pe),s.disposeIntermediateTensorInfo(We),s.disposeIntermediateTensorInfo(Ue),s.disposeIntermediateTensorInfo(yt),s.disposeIntermediateTensorInfo(Et),s.disposeIntermediateTensorInfo(wt),s.disposeIntermediateTensorInfo(vt),s.disposeIntermediateTensorInfo(kt),s.disposeIntermediateTensorInfo(jt),s.disposeIntermediateTensorInfo(Ut),s.disposeIntermediateTensorInfo(Xt),s.disposeIntermediateTensorInfo(tn),s.disposeIntermediateTensorInfo(Cn),s.disposeIntermediateTensorInfo(Sn),s.disposeIntermediateTensorInfo(sr),{real:yr,imag:Vr}}const c6={kernelName:h.FFT,backendName:"cpu",kernelFunc:function l6(n){const{inputs:t,backend:e}=n,{input:r}=t,s=h.util.sizeFromShape(r.shape),o=r.shape[r.shape.length-1],a=gr({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),l=bN(a,!1,e),c=gr({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}};function Hx(n){const{backend:t,attrs:e}=n,{shape:r,value:s,dtype:o}=e,i=o||h.util.inferDtype(s),a=h.util.getArrayFromDType(i,h.util.sizeFromShape(r));return function d6(n,t,e){n.fill(t)}(a,s),t.makeTensorInfo(r,i,a)}const u6={kernelName:h.Fill,backendName:"cpu",kernelFunc:Hx},h6={kernelName:h.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:r}=n,s=e,o=h.util.getTypedArrayFromDType(r.dtype,h.util.sizeFromShape(r.shape)),[i,a,l,c]=r.shape,u=s.data.get(r.dataId).values;for(let p=0;p<i;p++){const m=p*l*a*c;for(let y=0;y<a;y++){const _=y*(l*c);for(let C=0;C<l;C++){const D=C*c;for(let N=0;N<c;N++){const W=Math.round(l-C-1),j=m+_+D+N;let te=u[j];W>=0&&W<l&&(te=u[m+_+W*c+N]),o[j]=te}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},_N=sl(n=>Math.floor(n)),p6=Fc(h.Floor,_N),f6={kernelName:h.Floor,backendName:"cpu",kernelFunc:p6},m6=Hr((n,t)=>Math.floor(n/t)),g6=ds(h.FloorDiv,m6,null,"int32"),y6={kernelName:h.FloorDiv,backendName:"cpu",kernelFunc:g6},_6={kernelName:h.FusedConv2D,backendName:"cpu",kernelFunc:function b6(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:y}=r;let _=uN({inputs:{x:s,filter:o},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:p}});if(i){const C=_;if("NCHW"===u&&1===i.shape.length&&1!==i.shape[0]){const D=gr({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});_=uh({inputs:{a:_,b:D},backend:e}),e.disposeIntermediateTensorInfo(D)}else _=uh({inputs:{a:_,b:i},backend:e});e.disposeIntermediateTensorInfo(C)}if(m){const C=_;if("NCHW"===u&&"prelu"===m&&1===a.shape.length&&1!==a.shape[0]){const D=gr({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});_=wy(e,_,m,D,y),e.disposeIntermediateTensorInfo(D)}else _=wy(e,_,m,a,y);e.disposeIntermediateTensorInfo(C)}return _}},x6={kernelName:h.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function v6(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:y}=r;let _=dN({inputs:{x:s,filter:o},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:p}});if(i){const C=_;_=uh({inputs:{a:_,b:i},backend:e}),e.disposeIntermediateTensorInfo(C)}if(m){const C=_;_=wy(e,_,m,a,y),e.disposeIntermediateTensorInfo(C)}return _}};function vN(n,t,e,r,s,o,i,a,l){const c=(0,h.buffer)([r,o],e);for(let u=0;u<r;u++){const d=[];let p=0;for(let m=0;m<s;m++){const y=n[u*s+m];p+=y*i[m],d.push(y)}if(p<0||p>=l/o)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let m=0;m<o;m++)c.values[u*o+m]=t.get(...t.indexToLoc(p*o+m))}return c}const w6={kernelName:h.GatherNd,backendName:"cpu",kernelFunc:function C6(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,o=h.util.sizeFromShape(r.shape),i=s.shape,a=i[i.length-1],[l,c,u,d]=h.backend_util.prepareAndValidate(r,s);if(0===c)return e.makeTensorInfo(l,r.dtype,[]);const y=vN(e.data.get(s.dataId).values,e.bufferSync(r),r.dtype,c,a,u,d,r.shape,o);return e.makeTensorInfo(l,r.dtype,y.values)}};function xN(n,t,e){const r=(0,h.buffer)(e,n.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),c=t.locToIndex([i[0],i[2]]);i[2]=t.values[c];const u=n.locToIndex(i);0<=u&&u<n.values.length&&(r.values[s]=n.values[u])}return r}const E6={kernelName:h.GatherV2,backendName:"cpu",kernelFunc:function S6(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:o}=t,{axis:i,batchDims:a}=r;qt([s,o],"gatherV2");const l=h.util.parseAxisParam(i,s.shape)[0],c=e.data.get(o.dataId).values,u=s.shape[l];for(let j=0;j<c.length;++j){const te=c[j];h.util.assert(te<=u-1&&te>=0,()=>`GatherV2: the index value ${te} is not in [0, ${u-1}]`)}let d=a;null==a&&(d=0);const p=h.util.sizeFromShape(o.shape),m=h.backend_util.segment_util.collectGatherOpShapeInfo(s,o,l,d),y=gr({inputs:{x:s},backend:e,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),_=gr({inputs:{x:o},backend:e,attrs:{shape:[m.batchSize,p/m.batchSize]}}),C=[m.batchSize,m.outerSize,p/m.batchSize,m.sliceSize],D=e.bufferSync(_),W=xN(e.bufferSync(y),D,C);return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_),e.makeTensorInfo(m.outputShape,W.dtype,W.values)}},CN=Hr((n,t)=>n>t?1:0),D6=ds(h.Greater,CN,null,"bool"),T6={kernelName:h.Greater,backendName:"cpu",kernelFunc:D6},wN=Hr((n,t)=>n>=t?1:0),I6=ds(h.GreaterEqual,wN,null,"bool"),A6={kernelName:h.GreaterEqual,backendName:"cpu",kernelFunc:I6},k6={kernelName:h.IFFT,backendName:"cpu",kernelFunc:function N6(n){const{inputs:t,backend:e}=n,{input:r}=t,s=h.util.sizeFromShape(r.shape),o=r.shape[r.shape.length-1],a=gr({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),l=bN(a,!0,e),c=gr({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}},M6=rr(h.IsFinite,n=>Number.isFinite(n)?1:0,"bool"),R6={kernelName:h.IsFinite,backendName:"cpu",kernelFunc:M6},O6=rr(h.IsInf,n=>Math.abs(n)===1/0?1:0,"bool"),F6={kernelName:h.IsInf,backendName:"cpu",kernelFunc:O6},P6=rr(h.IsNan,n=>Number.isNaN(n)?1:0,"bool"),$6={kernelName:h.IsNan,backendName:"cpu",kernelFunc:P6},SN=Hr((n,t)=>n<t?1:0),L6=ds(h.Less,SN,null,"bool"),B6={kernelName:h.Less,backendName:"cpu",kernelFunc:L6},EN=Hr((n,t)=>n<=t?1:0),V6=ds(h.LessEqual,EN,null,"bool"),U6={kernelName:h.LessEqual,backendName:"cpu",kernelFunc:V6};function DN(n,t,e){const r=(t-n)/(e-1),s=h.util.makeZerosTypedArray(e,"float32");s[0]=n;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}const H6={kernelName:h.LinSpace,backendName:"cpu",kernelFunc:function z6(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:o}=e,i=DN(r,s,o);return t.makeTensorInfo([i.length],"float32",i)}},TN=sl(n=>Math.log(n)),W6=Fc(h.Log,TN),j6={kernelName:h.Log,backendName:"cpu",kernelFunc:W6},G6=rr(h.Log1p,n=>Math.log1p(n)),K6={kernelName:h.Log1p,backendName:"cpu",kernelFunc:G6},X6=Hr((n,t)=>n&&t),q6=ds(h.LogicalAnd,X6,null,"bool"),Z6={kernelName:h.LogicalAnd,backendName:"cpu",kernelFunc:q6},Y6=rr(h.LogicalNot,n=>n?0:1,"bool"),Q6={kernelName:h.LogicalNot,backendName:"cpu",kernelFunc:Y6},J6=Hr((n,t)=>n||t),e5=ds(h.LogicalOr,J6,null,"bool"),t5={kernelName:h.LogicalOr,backendName:"cpu",kernelFunc:e5},r5={kernelName:h.LRN,backendName:"cpu",kernelFunc:function n5(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:o,bias:i,alpha:a,beta:l}=r;qt(s,"LRN");const c=s.shape[3],u=c-1,d=e.data.get(s.dataId).values,p=h.util.sizeFromShape(s.shape),m=new Float32Array(p);function y(_){const C=_%c;let D=_-C+Math.max(0,C-o);const N=_-C+Math.min(C+o,u);let W=0;for(;D<=N;D++){const j=d[D];W+=j*j}return W}for(let _=0;_<p;_++){const C=y(_),D=d[_]*Math.pow(i+a*C,-l);m[_]=D}return e.makeTensorInfo(s.shape,s.dtype,m)}},o5={kernelName:h.LRNGrad,backendName:"cpu",kernelFunc:function s5(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,y:o,dy:i}=t,{depthRadius:a,bias:l,alpha:c,beta:u}=r;qt(i,"LRNGrad");const d=h.util.sizeFromShape(i.shape),p=i.shape[3],m=e.data.get(i.dataId).values,y=e.data.get(s.dataId).values,_=e.data.get(o.dataId).values,C=new Float32Array(d),D=d;for(let N=0;N<D;N++){const W=N%p,j=N-W+Math.max(0,W-a),te=N-W+Math.min(p,W+a+1);let _e=0;for(let Ee=j;Ee<te;Ee++)_e+=Math.pow(y[Ee],2);_e=c*_e+l;for(let Ee=j;Ee<te;Ee++){let Ne=-2*c*u*y[Ee]*_[N]/_e;N===Ee&&(Ne+=Math.pow(_e,-u)),Ne*=m[N],C[Ee]+=Ne}}return e.makeTensorInfo(i.shape,s.dtype,C)}};function IN(n,t,e,r){const s=h.util.getTypedArrayFromDType(r,h.util.sizeFromShape(e));for(let o=0;o<s.length;++o){const i=o*t;let a=n[i];for(let l=0;l<t;++l){const c=n[i+l];(Number.isNaN(c)||c>a)&&(a=c)}s[o]=a}return s}function AN(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:o,keepDims:i}=r,a=e;let l=s.shape;const c=l.length,u=h.util.parseAxisParam(o,l);let d=u;const p=h.backend_util.getAxesPermutation(d,c);let m=a.data.get(s.dataId).values;if(null!=p){const j=new Array(c);for(let te=0;te<j.length;te++)j[te]=l[p[te]];m=Fx(m,l,s.dtype,p,j),d=h.backend_util.getInnerMostAxes(d.length,c),l=j}qt(s,"max"),h.backend_util.assertAxesAreInnerMostDims("max",d,c);const[y,_]=h.backend_util.computeOutAndReduceShapes(l,d),D=IN(m,h.util.sizeFromShape(_),y,s.dtype),N=a.write(D,y,s.dtype);let W=y;return i&&(W=h.backend_util.expandShapeToKeepDim(y,u)),{dataId:N,shape:W,dtype:s.dtype}}const a5={kernelName:h.Max,backendName:"cpu",kernelFunc:AN},NN=Hr((n,t)=>Math.max(n,t)),l5=ds(h.Maximum,NN),c5={kernelName:h.Maximum,backendName:"cpu",kernelFunc:l5},d5={kernelName:h.MaxPool,backendName:"cpu",kernelFunc:function u5(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;qt(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;h.util.assert(h.backend_util.eitherStridesOrDilationsAreOne(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const u=h.backend_util.computePool2DInfo(s.shape,o,i,1,a,l);let d;if(1===u.filterWidth&&1===u.filterHeight&&h.util.arraysEqual(u.inShape,u.outShape))d=ol({inputs:{x:s},backend:e});else{const p=e.data.get(s.dataId).values,m=h.util.computeStrides(s.shape),y=Px(p,0,s.dtype,m,u,"max");d=e.makeTensorInfo(u.outShape,s.dtype,y.values)}return d}},p5={kernelName:h.MaxPool3D,backendName:"cpu",kernelFunc:function h5(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:c}=r;qt(s,"maxPool3d");const u=h.backend_util.computePool3DInfo(s.shape,o,i,1,a,l,c),p=oN(e.data.get(s.dataId).values,0,s.dtype,h.util.computeStrides(s.shape),u,"max");return e.makeTensorInfo(p.shape,"float32",p.values)}},m5={kernelName:h.MaxPool3DGrad,backendName:"cpu",kernelFunc:function f5(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,{filterSize:i,strides:a,pad:l,dimRoundingMode:c}=r;qt([s,o],"maxPool3DGrad");const u=h.backend_util.computePool3DInfo(o.shape,i,a,1,l,c),p=function DG(n,t){const e=(0,h.buffer)(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,o=t.strideWidth,i=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=t.padInfo.front,m=t.padInfo.top,y=t.padInfo.left;for(let _=0;_<t.batchSize;++_)for(let C=0;C<t.inChannels;++C)for(let D=0;D<t.outDepth;++D){const N=D*r-p;let W=N;for(;W<0;)W+=i;const j=Math.min(t.inDepth,c+N);for(let te=0;te<t.outHeight;++te){const _e=te*s-m;let Ee=_e;for(;Ee<0;)Ee+=a;const Ne=Math.min(t.inHeight,u+_e);for(let je=0;je<t.outWidth;++je){const He=je*o-y;let it=He;for(;it<0;)it+=l;const at=Math.min(t.inWidth,d+He);let tt=Number.NEGATIVE_INFINITY,lt=-1;for(let st=W;st<j;st+=i){const Pe=st-N;for(let We=Ee;We<Ne;We+=a){const Ue=We-_e;for(let Ye=it;Ye<at;Ye+=l){const pt=Ye-He,yt=n.get(_,st,We,Ye,C);yt>=tt&&(tt=yt,lt=Pe*u*d+Ue*u+pt)}}}e.set(lt,_,D,te,je,C)}}}return e}(e.bufferSync(o),u),m=u.strideDepth,y=u.strideHeight,_=u.strideWidth,C=u.dilationDepth,D=u.dilationHeight,N=u.dilationWidth,W=u.effectiveFilterDepth,j=u.effectiveFilterHeight,te=u.effectiveFilterWidth,_e=W-1-u.padInfo.front,Ee=te-1-u.padInfo.left,Ne=j-1-u.padInfo.top,je=(0,h.buffer)(o.shape,"float32"),He=e.bufferSync(s);for(let it=0;it<u.batchSize;++it)for(let at=0;at<u.inChannels;++at)for(let tt=0;tt<u.inDepth;++tt)for(let lt=0;lt<u.inHeight;++lt)for(let st=0;st<u.inWidth;++st){const Pe=tt-_e,We=lt-Ne,Ue=st-Ee;let Ye=0;for(let pt=0;pt<W;pt+=C){const yt=(Pe+pt)/m;if(!(yt<0||yt>=u.outDepth||Math.floor(yt)!==yt))for(let Et=0;Et<j;Et+=D){const wt=(We+Et)/y;if(!(wt<0||wt>=u.outHeight||Math.floor(wt)!==wt))for(let vt=0;vt<te;vt+=N){const kt=(Ue+vt)/_;if(kt<0||kt>=u.outWidth||Math.floor(kt)!==kt)continue;const tn=W*j*te-1-p.get(it,yt,wt,kt,at)===pt*j*te+Et*te+vt?1:0;0!==tn&&(Ye+=He.get(it,yt,wt,kt,at)*tn)}}}je.set(Ye,it,tt,lt,st,at)}return e.makeTensorInfo(je.shape,je.dtype,je.values)}},y5={kernelName:h.MaxPoolGrad,backendName:"cpu",kernelFunc:function g5(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o,output:i}=t,a=o;qt([o,i],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=r,p=h.backend_util.computePool2DInfo(a.shape,l,c,1,u,d),m=e.data.get(a.dataId).values,y=(0,h.buffer)(p.outShape,a.dtype,sN(m,a.shape,a.dtype,p).values),_=p.strideHeight,C=p.strideWidth,D=p.dilationHeight,N=p.dilationWidth,W=p.effectiveFilterHeight,j=p.effectiveFilterWidth,te=j-1-p.padInfo.left,_e=W-1-p.padInfo.top,Ee=(0,h.buffer)(a.shape,"float32"),Ne=e.data.get(s.dataId).values,je=(0,h.buffer)(s.shape,"float32",Ne);for(let He=0;He<p.batchSize;++He)for(let it=0;it<p.inChannels;++it)for(let at=0;at<p.inHeight;++at)for(let tt=0;tt<p.inWidth;++tt){const lt=at-_e,st=tt-te;let Pe=0;for(let We=0;We<W;We+=D){const Ue=(lt+We)/_;if(!(Ue<0||Ue>=p.outHeight||Math.floor(Ue)!==Ue))for(let Ye=0;Ye<j;Ye+=N){const pt=(st+Ye)/C;if(pt<0||pt>=p.outWidth||Math.floor(pt)!==pt)continue;const wt=W*j-1-y.get(He,Ue,pt,it)===We*j+Ye?1:0;0!==wt&&(Pe+=je.get(He,Ue,pt,it)*wt)}}Ee.set(Pe,He,at,tt,it)}return e.makeTensorInfo(Ee.shape,Ee.dtype,Ee.values)}},_5={kernelName:h.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=t,l=e;qt(r,"MaxPoolWithArgmax");const c=l.data.get(r.dataId).values,u=h.backend_util.computePool2DInfo(r.shape,s,o,[1,1],i),[d,p]=function b5(n,t,e,r,s){const i=Px(n,0,e,h.util.computeStrides(t),s,"max"),a=sN(n,t,e,s,!0,r);return[i.values,a.values]}(c,r.shape,r.dtype,a,u),m=l.write(d,u.outShape,r.dtype),y=l.write(p,u.outShape,r.dtype);return[{dataId:m,shape:u.outShape,dtype:r.dtype},{dataId:y,shape:u.outShape,dtype:"int32"}]}},x5={kernelName:h.Mean,backendName:"cpu",kernelFunc:function v5(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=h.util.parseAxisParam(o,s.shape),c=h.backend_util.computeOutAndReduceShapes(s.shape,a)[1],u=h.util.sizeFromShape(c),d=[],p=e.makeTensorInfo([],"float32",new Float32Array([u]));d.push(p);const m=Pc({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});d.push(m);const y=Bx({inputs:{a:m,b:p},backend:e});d.push(y);const _=gf({inputs:{x:y},backend:e,attrs:{axis:o,keepDims:i}});return d.forEach(C=>e.disposeIntermediateTensorInfo(C)),_}},w5={kernelName:h.Min,backendName:"cpu",kernelFunc:function C5(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;qt(s,"min");const a=h.util.parseAxisParam(o,s.shape);let l=a;const c=h.backend_util.getAxesPermutation(l,s.shape.length);let u=s;null!=c&&(u=Ro({inputs:{x:s},backend:e,attrs:{perm:c}}),l=h.backend_util.getInnerMostAxes(l.length,s.shape.length)),h.backend_util.assertAxesAreInnerMostDims("min",l,u.shape.length);const[d,p]=h.backend_util.computeOutAndReduceShapes(u.shape,l),m=h.util.sizeFromShape(p),y=h.util.makeZerosTypedArray(h.util.sizeFromShape(d),u.dtype),_=e.data.get(u.dataId).values;for(let D=0;D<y.length;++D){const N=D*m;let W=_[N];for(let j=0;j<m;++j){const te=_[N+j];(Number.isNaN(te)||te<W)&&(W=te)}y[D]=W}null!=c&&e.disposeIntermediateTensorInfo(u);const C=e.makeTensorInfo(d,u.dtype,y);if(i){const N=gr({inputs:{x:C},backend:e,attrs:{shape:h.backend_util.expandShapeToKeepDim(d,a)}});return e.disposeIntermediateTensorInfo(C),N}return C}},kN=Hr((n,t)=>Math.min(n,t)),S5=ds(h.Minimum,kN),E5={kernelName:h.Minimum,backendName:"cpu",kernelFunc:S5},T5={kernelName:h.MirrorPad,backendName:"cpu",kernelFunc:function D5(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:o,mode:i}=r;qt(s,"mirrorPad");const a=o.map((W,j)=>W[0]+s.shape[j]+W[1]),l=o.map(W=>W[0]),c=o.map((W,j)=>W[0]+s.shape[j]),u="reflect"===i?0:1,d=e.data.get(s.dataId).values,p=s.shape.length,m=h.util.computeStrides(s.shape),y=h.util.sizeFromShape(a),_=a.length,C=h.util.computeStrides(a),D=h.util.getTypedArrayFromDType(s.dtype,y);for(let W=0;W<y;W++){let j=h.util.indexToLoc(W,_,C);for(let _e=0;_e<_;_e++)j[_e]<l[_e]?j[_e]=2*l[_e]-j[_e]-u:j[_e]>=c[_e]&&(j[_e]=2*(c[_e]-1)-j[_e]+u);j=j.map((_e,Ee)=>_e-l[Ee]);const te=h.util.locToIndex(j,p,m);D[W]=d[te]}return{dataId:e.write(D,a,s.dtype),shape:a,dtype:s.dtype}}},I5=Hr((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),A5=ds(h.Mod,I5),N5={kernelName:h.Mod,backendName:"cpu",kernelFunc:A5};var k5=O(340);function MN(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:o}=r,i=s.shape.length;let a=o;if(-1===a&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);const l=h.util.parseAxisParam([a],s.shape),c=AN({inputs:{x:s},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),u=h.backend_util.expandShapeToKeepDim(c.shape,l),d=gr({inputs:{x:c},backend:e,attrs:{shape:u}}),p=Ux({inputs:{a:s,b:d},backend:e}),m=mN({inputs:{x:p},backend:e}),y=gf({inputs:{x:m},backend:e,attrs:{axis:l,keepDims:!1}}),_=gr({inputs:{x:y},backend:e,attrs:{shape:u}}),C=Bx({inputs:{a:m,b:_},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_),C}const M5={kernelName:h.Softmax,backendName:"cpu",kernelFunc:MN},O5={kernelName:h.Multinomial,backendName:"cpu",kernelFunc:function R5(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:o,seed:i,normalized:a}=r;qt(s,"multinomial");const l=a?s:MN({inputs:{logits:s},backend:e,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],d=e.data.get(l.dataId).values,p=[c,o],m=h.util.makeZerosTypedArray(h.util.sizeFromShape(p),"int32");for(let y=0;y<c;++y){const _=y*u,C=new Float32Array(u-1);C[0]=d[_];for(let W=1;W<C.length;++W)C[W]=C[W-1]+d[_+W];const D=k5.alea(i.toString()),N=y*o;for(let W=0;W<o;++W){const j=D();m[N+W]=C.length;for(let te=0;te<C.length;te++)if(j<C[te]){m[N+W]=te;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(p,"int32",m)}};function RN(n,t,e){const r=h.util.createScalarValue(-1,e);return Lx([],t,r,n,e)}const P5={kernelName:h.Neg,backendName:"cpu",kernelFunc:function F5(n){const{inputs:t,backend:e}=n,{x:r}=t;qt(r,"neg");const s=e.data.get(r.dataId).values,[o,i]=RN(s,r.shape,r.dtype);return e.makeTensorInfo(i,r.dtype,o)}},$5=h.kernel_impls.nonMaxSuppressionV3Impl,B5={kernelName:h.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function L5(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r;qt(s,"NonMaxSuppression");const c=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,{selectedIndices:d}=$5(c,u,i,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},V5=h.kernel_impls.nonMaxSuppressionV4Impl,z5={kernelName:h.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function U5(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r;qt(s,"NonMaxSuppressionPadded");const u=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,{selectedIndices:p,validOutputs:m}=V5(u,d,i,a,l,c);return[e.makeTensorInfo([p.length],"int32",new Int32Array(p)),e.makeTensorInfo([],"int32",new Int32Array([m]))]}},H5=h.kernel_impls.nonMaxSuppressionV5Impl,j5={kernelName:h.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function W5(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r;qt(s,"NonMaxSuppressionWithScore");const u=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,p=i,m=a,y=l,_=c,{selectedIndices:C,selectedScores:D}=H5(u,d,p,m,y,_);return[e.makeTensorInfo([C.length],"int32",new Int32Array(C)),e.makeTensorInfo([D.length],"float32",new Float32Array(D))]}},ON=Hr((n,t)=>n!==t?1:0),G5=ds(h.NotEqual,ON,null,"bool"),K5={kernelName:h.NotEqual,backendName:"cpu",kernelFunc:G5},q5={kernelName:h.OneHot,backendName:"cpu",kernelFunc:function X5(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:o,depth:i,onValue:a,offValue:l}=r;qt(s,"oneHot");const c=h.util.sizeFromShape(s.shape),u=new Float32Array(c*i);u.fill(l);const d=e.data.get(s.dataId).values;for(let p=0;p<c;++p)d[p]>=0&&d[p]<i&&(u[p*i+d[p]]=a);return e.makeTensorInfo([...s.shape,i],o,u)}};function Ty(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=$u({inputs:{input:r},backend:e}),o=Ty({inputs:{x:s},backend:e}),i=dh({inputs:{input:r},backend:e}),a=Ty({inputs:{x:i},backend:e}),l=Xo({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return Hx({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const Z5={kernelName:h.ZerosLike,backendName:"cpu",kernelFunc:Ty},Y5={kernelName:h.OnesLike,backendName:"cpu",kernelFunc:function FN(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=$u({inputs:{input:r},backend:e}),o=FN({inputs:{x:s},backend:e}),i=dh({inputs:{input:r},backend:e}),a=Ty({inputs:{x:i},backend:e}),l=Xo({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return Hx({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function PN(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return Dy({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const o=t[0].shape,i=t[0].dtype;t.forEach(u=>{h.util.assertShapesMatch(o,u.shape,"All tensors passed to stack must have matching shapes"),h.util.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=hh({inputs:t.map(u=>{const d=Dy({inputs:{input:u},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}const Q5={kernelName:h.Pack,backendName:"cpu",kernelFunc:PN},$N={kernelName:h.PadV2,backendName:"cpu",kernelFunc:function J5(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:o,constantValue:i}=r;qt(s,"pad");const a=o.map((N,W)=>N[0]+s.shape[W]+N[1]),l=o.map(N=>N[0]),c=e.data.get(s.dataId).values,u=h.util.sizeFromShape(s.shape),d=s.shape.length,p=h.util.computeStrides(s.shape),m=h.util.sizeFromShape(a),y=a.length,_=h.util.computeStrides(a),C=h.util.getTypedArrayFromDType(s.dtype,m);0!==i&&C.fill(i);for(let N=0;N<u;N++){const j=h.util.indexToLoc(N,d,p).map((_e,Ee)=>_e+l[Ee]);C[h.util.locToIndex(j,y,_)]=c[N]}return{dataId:e.write(C,a,s.dtype),shape:a,dtype:s.dtype}}},eK=Hr((n,t)=>Math.pow(n,t)),tK=ds(h.Pow,eK),nK={kernelName:h.Pow,backendName:"cpu",kernelFunc:tK};function LN(n,t,e,r){const[s,o]=h.backend_util.computeOutAndReduceShapes(n,r),i=(0,h.upcastType)(t,"int32"),a=h.util.makeZerosTypedArray(h.util.sizeFromShape(s),i),l=h.util.sizeFromShape(o);for(let c=0;c<a.length;++c){const u=c*l;let d=1;for(let p=0;p<l;++p)d*=e[u+p];a[c]=d}return{outVals:a,outShape:s,outDtype:i}}const sK={kernelName:h.Prod,backendName:"cpu",kernelFunc:function rK(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;qt(s,"prod");const a=s.shape.length,l=h.util.parseAxisParam(o,s.shape),c=h.backend_util.getAxesPermutation(l,a);let u=l,d=s;const p=[];null!=c&&(d=Ro({inputs:{x:s},backend:e,attrs:{perm:c}}),p.push(d),u=h.backend_util.getInnerMostAxes(u.length,a));const m=e.data.get(d.dataId).values,{outVals:y,outShape:_,outDtype:C}=LN(d.shape,d.dtype,m,u);let D=_;return i&&(D=h.backend_util.expandShapeToKeepDim(_,l)),p.forEach(N=>e.disposeIntermediateTensorInfo(N)),e.makeTensorInfo(D,C,y)}};function BN(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let r=t;r<n.length;r++)e[t-1]*=n[r];return e}function VN(n,t,e,r,s,o,i,a){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function oK(n,t,e){n.forEach((r,s)=>{if(r<0||r>=e){const o=h.util.indexToLoc(s,t.length,h.util.computeStrides(t)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${e})`)}})}(o,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:u,valueSlices:d,numValues:p}=function aK(n,t,e,r){const s=[];let o=0;const a=new Array(t.length-1+e.length).fill(null).map(()=>[0]);!function iK(n,t){for(let e=0;e<n.length;++e){const r=n[e],s=e===n.length-1?t:n[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];const u=t[c+1];for(let d=1;d<l+1;++d)a[c].push(d*u)}for(let c=0;c<n.length;++c){let u=n[c],d=n[c]+1;for(let p=0;p<e.length;++p){const m=e[p],y=p+t.length-1;if(y>=0){const _=a[y],C=_[_.length-1]-m[u];for(let D=u;D<d;++D)a[y].push(m[D+1]+C)}u=m[u],d=m[d]}d!==u&&(s.push([u,d]),o+=d-u)}return{outSplits:a,valueSlices:s,numValues:o}}(o,i,n,c),m=function lK(n){const t=[];for(let e=0;e<n.length;++e){const s=h.util.getArrayFromDType("int32",n[e].length);t.push(s),n[e].forEach((o,i)=>s[i]=o)}return t}(u),y=function uK(n,t,e,r,s){const o=t.slice();o[0]=s;const i=h.util.getArrayFromDType(e,h.util.sizeFromShape(o)),a=n.length;return function cK(n,t,e,r,s,o){const i=BN(t,2)[1],a=BN(o,2)[1];let l=0;for(const c of e)for(let u=c[0];u<c[1];++u){for(let d=0;d<r;++d)s[l*a+d]=n[u*i+d];++l}}(n,t,r,0===a?0:a/t[0],i,o),[i,o]}(e,r,s,d,p);return[m,y[0],y[1]]}const hK={kernelName:h.RaggedGather,backendName:"cpu",kernelFunc:function dK(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=t,l=s.map(D=>e.data.get(D.dataId).values),c=s.map(D=>D.shape),u=e.data.get(o.dataId).values,d=e.data.get(i.dataId).values,[p,m,y]=VN(l,c,u,o.shape,o.dtype,d,i.shape),_=p.map(D=>e.makeTensorInfo([D.length],"int32",D)),C=e.makeTensorInfo(y,o.dtype,m);return _.concat([C])}},UN=2147483647;function zN(n,t,e,r,s,o,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=0===t.length,l=0===s.length,c=0===i.length,u=[];a||u.push(t[0]),l||u.push(s[0]),c||u.push(i[0]);for(let C=1;C<u.length;++C)if(u[C]!==u[C-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===u.length?1:u[0],p=h.util.getArrayFromDType("int32",d+1);p[0]=0;for(let C=0;C<d;++C){const D=a?n[0]:n[C],N=l?r[0]:r[C],W=c?o[0]:o[C];if(0===W)throw new Error("Requires delta != 0");let j;if(W>0&&N<D||W<0&&N>D)j=0;else if(j=Math.ceil(Math.abs((N-D)/W)),j>UN)throw new Error(`Requires ((limit - start) / delta) <= ${UN}`);p[C+1]=p[C]+j}const y=h.util.getArrayFromDType(e,p[d]);let _=0;for(let C=0;C<d;++C){const D=p[C+1]-p[C];let N=a?n[0]:n[C];const W=c?o[0]:o[C];for(let j=0;j<D;++j)y[_++]=N,N+=W}return[p,y]}const fK={kernelName:h.RaggedRange,backendName:"cpu",kernelFunc:function pK(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:o}=t,i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[c,u]=zN(i,r.shape,r.dtype,a,s.shape,l,o.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([u.length],r.dtype,u)]}};var zi=h.backend_util.RowPartitionType;class Iy{constructor(t,e,r,s,o,i,a,l,c,u){this.shape=t,this.shapeShape=e,this.values=r,this.valuesShape=s,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=h.backend_util.getRowPartitionTypesHelper(u),this.raggedRank=h.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===zi.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===zi.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case zi.VALUE_ROWIDS:return Iy.getMaxWidthValueRowID(e);case zi.ROW_SPLITS:return Iy.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${zi[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let r=0;for(let s=0;s<e-1;++s){const o=t[s+1]-t[s];o>r&&(r=o)}return r}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let r=0,s=t[0],o=0;for(let i=1;i<e;++i){const a=t[i];a!==s&&(s=a,o=Math.max(i-r,o),r=i)}return Math.max(e-r,o)}tensorShapeFromTensor(t,e,r=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return WN(t,r)}calculateOutputSize(t){const e=this.valuesShape;h.backend_util.validateDefaultValueShape(this.defaultValueShape,e);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=h.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,s,e);i[0]<0&&(i[0]=t);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(t,e,r){const s=Math.min(t,r),o=[];let i=0;for(let a=0;a<s;++a,i+=e)o.push(i);for(let a=s;a<t;++a)o.push(-1);return h.util.assert(o.length===t,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(t,e,r,s){const o=t.length,i=[];for(let a=0;a<o-1;++a){const l=t[a+1]-t[a];let c=Math.min(s,l),u=e[a];-1===u&&(c=0);for(let d=0;d<c;++d)i.push(u),u+=r;for(let d=0;d<l-c;++d)i.push(-1)}if(o>0&&i.length!==t[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,e,r,s){const o=t.length,i=[];if(0===o)return[];let a=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let c=e[l];i.push(c);for(let u=1;u<o;++u){const d=t[u];if(d===l)c>=0&&(++a,a<s?c+=r:c=-1);else{if(a=0,l=d,d>=e.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);c=e[d]}i.push(c)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,e,r,s){const o=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case zi.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,e,r,s);case zi.ROW_SPLITS:if(o.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(o,e,r,s);default:throw new Error(`Unsupported partition type: ${zi[i]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case zi.FIRST_DIM_SIZE:return t[0];case zi.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case zi.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${zi[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const o=WN(r,!1),i=h.util.getArrayFromDType(this.valuesDType,h.util.sizeFromShape(o));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(e,s[0],r[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,s[c],r[c]);this.setOutput(this.raggedRank,l,i,o)}return[o,i]}setOutput(t,e,r,s){if(0===r.length)return;const o=this.values,i=r;let a=s.slice();a=a.slice(t+1);const l=h.util.sizeFromShape(a),c=e.length;let u=this.defaultValue;if(u.length!==l&&1!==u.length){const y=this.defaultValueShape;(0,h.tidy)(()=>{const _=(0,h.reshape)(u,y);u=(0,h.broadcastTo)(_,a).dataSync()})}let d=0,p=0,m=0;for(let y=0;y<=c;++y){let _=y<c?e[y]:-1;if(_!==m){if(p<m){const C=o.subarray(d*l);HN(i.subarray(p*l),C,(m-p)*l)}if(y>=c&&(_=Math.floor(r.length/l)),_>m)if(1===this.defaultValue.length)i.subarray(m*l,_*l).fill(this.defaultValue[0]),m=_;else for(;_>m;)HN(i.slice(m*l),u,l),++m;_<0?(d=y+1,p=m):(d=y,p=m,m=p+1)}else++m}}}function HN(n,t,e){for(let r=0;r<e;r++)n[r]=t[r]}function WN(n,t){const e=[];for(let r of n){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function jN(n,t,e,r,s,o,i,a,l,c){return new Iy(n,t,e,r,s,o,i,a,l,c).compute()}const gK={kernelName:h.RaggedTensorToTensor,backendName:"cpu",kernelFunc:function mK(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=r,c=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,d=e.data.get(i.dataId).values,p=a.map(C=>e.data.get(C.dataId).values),m=a.map(C=>C.shape),[y,_]=jN(c,s.shape,u,o.shape,o.dtype,d,i.shape,p,m,l);return e.makeTensorInfo(y,o.dtype,_)}};function GN(n,t,e,r){if(n===t||n<t&&e<0||t<n&&e>1)return h.util.makeZerosTypedArray(0,r);const a=Math.abs(Math.ceil((t-n)/e)),l=h.util.makeZerosTypedArray(a,r);t<n&&1===e&&(e=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+e;return l}const bK={kernelName:h.Range,backendName:"cpu",kernelFunc:function yK(n){const{backend:t,attrs:e}=n,{start:r,stop:s,dtype:o,step:i}=e,a=GN(r,s,i,o);return t.makeTensorInfo([a.length],o,a)}},_K=rr(h.Reciprocal,n=>1/n),vK={kernelName:h.Reciprocal,backendName:"cpu",kernelFunc:_K},CK={kernelName:h.ResizeBilinear,backendName:"cpu",kernelFunc:function xK(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r;qt(s,"resizeBilinear");const l=h.util.computeStrides(s.shape),[c,u]=a,[d,p,m,y]=s.shape,_=e.data.get(s.dataId).values,C=new Float32Array(h.util.sizeFromShape([d,c,u,y])),D=[o&&c>1?p-1:p,o&&u>1?m-1:m],N=[o&&c>1?c-1:c,o&&u>1?u-1:u];let W=0;const j=D[0]/N[0],te=D[1]/N[1];for(let _e=0;_e<d;_e++)for(let Ee=0;Ee<c;Ee++){let Ne;Ne=i?j*(Ee+.5)-.5:j*Ee;const je=Math.max(0,Math.floor(Ne)),He=Ne-je,it=Math.min(p-1,Math.ceil(Ne)),at=_e*l[0]+je*l[1],tt=_e*l[0]+it*l[1];for(let lt=0;lt<u;lt++){let st;st=i?te*(lt+.5)-.5:te*lt;const Pe=Math.max(0,Math.floor(st)),We=st-Pe,Ue=Math.min(m-1,Math.ceil(st)),Ye=at+Pe*l[2],pt=tt+Pe*l[2],yt=at+Ue*l[2],Et=tt+Ue*l[2];for(let wt=0;wt<y;wt++){const vt=_[Ye+wt],kt=_[pt+wt],tn=vt+(_[yt+wt]-vt)*We;C[W++]=tn+(kt+(_[Et+wt]-kt)*We-tn)*He}}}return e.makeTensorInfo([d,c,u,y],"float32",C)}},SK={kernelName:h.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function wK(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:i}=r;qt([o,s],"resizeBilinearGrad");const a=h.util.computeStrides(s.shape),[l,c,u,d]=s.shape,[,p,m]=o.shape,y=new Float32Array(l*c*u*d),_=[i&&p>1?c-1:c,i&&m>1?u-1:u],C=[i&&p>1?p-1:p,i&&m>1?m-1:m],D=_[0]/C[0],N=_[1]/C[1],W=e.data.get(o.dataId).values;let j=0;for(let te=0;te<l;te++){const _e=te*a[0];for(let Ee=0;Ee<p;Ee++){const Ne=Ee*D,je=Math.floor(Ne),He=Math.min(Math.ceil(Ne),c-1),it=_e+je*a[1],at=_e+He*a[1],tt=Ne-je,lt=1-tt;for(let st=0;st<m;st++){const Pe=st*N,We=Math.floor(Pe),Ue=Math.min(Math.ceil(Pe),u-1),Ye=Pe-We,pt=1-Ye,yt=it+We*a[2],Et=it+Ue*a[2],wt=at+We*a[2],vt=at+Ue*a[2],kt=lt*pt,jt=lt*Ye,Ut=tt*pt,tn=tt*Ye;for(let Xt=0;Xt<d;Xt++){const Cn=W[j++];y[yt+Xt]+=Cn*kt,y[Et+Xt]+=Cn*jt,y[wt+Xt]+=Cn*Ut,y[vt+Xt]+=Cn*tn}}}}return e.makeTensorInfo([l,u,c,d],"float32",y)}},DK={kernelName:h.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function EK(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r;qt(s,"resizeNearestNeighbor");const l=h.util.computeStrides(s.shape),[c,u]=a,[d,p,m,y]=s.shape,_=e.data.get(s.dataId).values,C=new Float32Array(d*c*u*y),D=[o&&c>1?p-1:p,o&&u>1?m-1:m],N=[o&&c>1?c-1:c,o&&u>1?u-1:u],W=D[0]/N[0],j=D[1]/N[1];let te=0;for(let _e=0;_e<d;_e++){const Ee=_e*l[0];for(let Ne=0;Ne<c;Ne++){const je=i?W*(Ne+.5):W*Ne;let He=Math.min(p-1,o?Math.round(je):Math.floor(je));i&&(He=Math.max(0,He));const it=Ee+He*l[1];for(let at=0;at<u;at++){const tt=i?j*(at+.5):j*at;let lt=Math.min(m-1,o?Math.round(tt):Math.floor(tt));i&&(lt=Math.max(0,lt));const st=it+lt*l[2];for(let Pe=0;Pe<y;Pe++)C[te++]=_[st+Pe]}}}return e.makeTensorInfo([d,c,u,y],s.dtype,C)}},IK={kernelName:h.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function TK(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:i}=r;qt([o,s],"resizeNearestNeighborGrad");const a=h.util.computeStrides(s.shape),l=h.util.computeStrides(o.shape),[c,u,d,p]=s.shape,[,m,y]=o.shape,_=new Float32Array(c*u*d*p),C=e.data.get(o.dataId).values,D=[i&&m>1?u-1:u,i&&y>1?d-1:d],N=[i&&m>1?m-1:m,i&&y>1?y-1:y],W=D[0]/N[0],j=D[1]/N[1],te=1/W,_e=1/j,Ee=2*Math.ceil(te)+2,Ne=2*Math.ceil(_e)+2;for(let je=0;je<c;je++){const He=je*a[0];for(let it=0;it<u;it++){const at=He+it*a[1],tt=Math.floor(it*te),lt=Math.floor(tt-Ee/2);for(let st=0;st<d;st++){const Pe=at+st*a[2],We=Math.floor(st*_e),Ue=Math.floor(We-Ne/2);for(let Ye=0;Ye<p;Ye++){let pt=0;for(let yt=0;yt<Ee;yt++){const Et=yt+lt;if(Et<0||Et>=m)continue;const wt=He+Et*l[1],vt=Et*W;if(it===Math.min(u-1,i?Math.round(vt):Math.floor(vt)))for(let jt=0;jt<Ne;jt++){const Ut=jt+Ue;if(Ut<0||Ut>=y)continue;const tn=wt+Ut*l[2],Xt=Ut*j;st===Math.min(d-1,i?Math.round(Xt):Math.floor(Xt))&&(pt+=C[tn+Ye])}}_[Pe+Ye]=pt}}}}return e.makeTensorInfo(s.shape,s.dtype,_)}},NK={kernelName:h.Reverse,backendName:"cpu",kernelFunc:function AK(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:o}=r;qt(s,"reverse");const i=s.shape.length,a=h.util.parseAxisParam(o,s.shape);if(0===i)return ol({inputs:{x:s},backend:e});const l=new h.TensorBuffer(s.shape,s.dtype),c=e.bufferSync(s);for(let u=0;u<l.size;u++){const d=l.indexToLoc(u),p=d.slice();a.forEach(m=>p[m]=s.shape[m]-1-p[m]),l.set(c.get(...p),...d)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},kK={kernelName:h.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:o,center:i}=t,a=e,l=h.util.getTypedArrayFromDType(r.dtype,h.util.sizeFromShape(r.shape)),[c,u,d,p]=r.shape,[m,y]=h.backend_util.getImageCenter(i,u,d),C=Math.sin(s),D=Math.cos(s),N=a.data.get(r.dataId).values;for(let j=0;j<c;j++){const te=j*d*u*p;for(let _e=0;_e<u;_e++){const Ee=_e*(d*p);for(let Ne=0;Ne<d;Ne++){const je=Ne*p;for(let He=0;He<p;He++){const it=[c,_e,Ne,He],at=it[2],tt=it[1];let lt=(at-m)*D-(tt-y)*C,st=(at-m)*C+(tt-y)*D;lt=Math.round(lt+m),st=Math.round(st+y);let Pe=o;"number"!=typeof o&&(Pe=3===He?255:o[He]),lt>=0&&lt<d&&st>=0&&st<u&&(Pe=N[te+st*(d*p)+lt*p+He]),l[te+Ee+je+He]=Pe}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},MK=rr(h.Round,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),RK={kernelName:h.Round,backendName:"cpu",kernelFunc:MK},KN=sl(n=>1/Math.sqrt(n)),OK=Fc(h.Rsqrt,KN),FK={kernelName:h.Rsqrt,backendName:"cpu",kernelFunc:OK};function Bu(n,t,e,r,s,o,i,a,l,c){const u=[r/s,s],d=n.values,p=t.values;if(0===r)return(0,h.buffer)(e,t.dtype);const m=l instanceof h.TensorBuffer?l:(0,h.buffer)(u,t.dtype);"string"==typeof l||"number"==typeof l?m.values.fill(l):"boolean"==typeof l&&m.values.fill(+l);for(let y=0;y<o;y++){const _=[];let C=0;for(let D=0;D<i;D++){const N=d[y*i+D];_.push(N),C+=N*a[D]}if(C<0||C>=r/s)throw new Error(`Invalid indices: ${_} does not index into ${e}`);for(let D=0;D<s;D++)c?m.values[C*s+D]+=p[y*s+D]:m.values[C*s+D]=0===t.rank?p[0]:p[y*s+D]}return m}const $K={kernelName:h.ScatterNd,backendName:"cpu",kernelFunc:function PK(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:o}=t,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=h.backend_util.calculateShapes(o,s,i),_=Bu(e.bufferSync(s),e.bufferSync(o),i,d,c,l,a,u,0,!0);return e.makeTensorInfo(i,_.dtype,_.values)}};function LK(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<t?e=s+1:r=s;return r}function BK(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<=t?e=s+1:r=s;return r}const zK={kernelName:h.SearchSorted,backendName:"cpu",kernelFunc:function UK(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:o}=t,{side:i}=r,c=function VK(n,t,e,r,s,o){const i=h.util.getArrayFromDType("int32",e*s);for(let a=0;a<e;++a){const l=n.slice(a*r,(a+1)*r),c=a*s;for(let u=0;u<s;++u)i[c+u]="left"===o?LK(l,t[u+c]):BK(l,t[u+c])}return i}(e.data.get(s.dataId).values,e.data.get(o.dataId).values,s.shape[0],s.shape[1],o.shape[1],i);return e.makeTensorInfo(o.shape,"int32",c)}},WK={kernelName:h.Select,backendName:"cpu",kernelFunc:function HK(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:o}=t;qt([r,s,o],"select");const i=r.shape.length,a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,u=(0,h.upcastType)(s.dtype,o.dtype),d=h.util.makeZerosTypedArray(h.util.sizeFromShape(s.shape),u);let p=0;const m=0===i||i>1||1===s.shape.length?1:h.util.sizeFromShape(s.shape.slice(1));for(let y=0;y<a.length;y++)for(let _=0;_<m;_++)d[p++]=1===a[y]?l[y]:c[y];return e.makeTensorInfo(s.shape,u,d)}},jK=h.backend_util.SELU_SCALEALPHA,GK=h.backend_util.SELU_SCALE,KK=rr(h.Selu,n=>n>=0?GK*n:jK*(Math.exp(n)-1)),XK={kernelName:h.Selu,backendName:"cpu",kernelFunc:KK},qK=rr(h.Sign,n=>n<0?-1:n>0?1:0),ZK={kernelName:h.Sign,backendName:"cpu",kernelFunc:qK},YK=rr(h.Sin,n=>Math.sin(n)),QK={kernelName:h.Sin,backendName:"cpu",kernelFunc:YK},JK=rr(h.Sinh,n=>Math.sinh(n)),eX={kernelName:h.Sinh,backendName:"cpu",kernelFunc:JK},XN=Math.log(1.1920928955078125e-7)+2,tX=rr(h.Softplus,n=>{const t=n>-XN,e=n<XN,r=Math.exp(n);let s;return s=e?r:t?n:Math.log(1+r),s}),nX={kernelName:h.Softplus,backendName:"cpu",kernelFunc:tX},sX={kernelName:h.SpaceToBatchND,backendName:"cpu",kernelFunc:function rX(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,paddings:i}=r;qt([s],"spaceToBatchND");const a=h.util.sizeFromShape(o),l=[[0,0]];l.push(...i);for(let _e=1+o.length;_e<s.shape.length;++_e)l.push([0,0]);const c=$N.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),u=h.backend_util.getReshaped(c.shape,o,a,!1),d=h.backend_util.getPermuted(u.length,o.length,!1),p=h.backend_util.getReshapedPermuted(c.shape,o,a,!1),_=gr({inputs:{x:c},backend:e,attrs:{shape:u}}),N=Ro({inputs:{x:_},backend:e,attrs:{perm:d}}),te=gr({inputs:{x:N},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(N),te}};function qN(n,t,e,r,s,o,i){const a=t[0],l=o[0],c=new Array(l),u=new Array(a),d=t[1];if(0===l){if(0!==a)throw new Error(h.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));return[h.util.getArrayFromDType(e,0),[0,d],h.util.getArrayFromDType(s,0),c,u]}let p=!0,m=0;const y=new Array(l).fill(0);for(let C=0;C<a;++C){const D=n[C*d];if(D<0)throw new Error(h.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(C,D));if(D>=l)throw new Error(h.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(C,D,l));++y[D],p=p&&D>=m,m=D}let _=!0;for(let C=0;C<l;++C){const D=0===y[C];c[C]=D,_=_&&!D,y[C]=Math.max(y[C],1),C>0&&(y[C]+=y[C-1])}if(_&&p){const C=n,D=r;for(let N=0;N<a;++N)u[N]=N;return[C,[a,d],D,c,u]}{const C=y[l-1],D=h.util.getArrayFromDType(e,C*d),N=h.util.getArrayFromDType(s,C),W=new Array(l).fill(0);for(let j=0;j<a;++j){const te=n[j*d],Ee=(0===te?0:y[te-1])+W[te];W[te]++;for(let Ne=0;Ne<d;++Ne)D[Ee*d+Ne]=n[j*d+Ne];N[Ee]=r[j],u[j]=Ee}for(let j=0;j<l;++j)if(0===W[j]){const _e=0===j?0:y[j-1];D[_e*d+0]=j;for(let Ee=1;Ee<d;++Ee)D[_e*d+Ee]=0;N[_e]=i}return[D,[C,d],N,c,u]}}const iX={kernelName:h.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function oX(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:o,defaultValue:i}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,u=e.data.get(i.dataId).values[0],[d,p,m,y,_]=qN(a,r.shape,r.dtype,l,s.dtype,c,u);return[e.makeTensorInfo(p,r.dtype,d),e.makeTensorInfo([p[0]],s.dtype,m),e.makeTensorInfo([y.length],"bool",new Uint8Array(y.map(C=>Number(C)))),e.makeTensorInfo([_.length],r.dtype,new Int32Array(_))]}};function ZN(n,t,e,r,s){const o=h.util.sizeFromShape(r),i=t[0],a=s.length,l=[];let c=1,u=-1;for(let C=0;C<a;++C){const D=s[C];if(-1===D){if(-1!==u)throw new Error(h.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(u,C));u=C,l.push(1)}else{if(D<0)throw new Error(h.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(C,D));c*=D,l.push(D)}}if(-1!==u){if(c<=0)throw new Error(h.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const C=Math.trunc(o/c);if(c*C!==o)throw new Error(h.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[u]=C}if(h.util.sizeFromShape(l)!==o)throw new Error(h.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(r,l));const p=r.length,m=[];if(p>0){m[p-1]=1;for(let C=p-2;C>=0;--C)m[C]=m[C+1]*r[C+1]}const y=[];if(a>0){y[a-1]=1;for(let C=a-2;C>=0;--C)y[C]=y[C+1]*l[C+1]}const _=h.util.getArrayFromDType(e,i*a);for(let C=0;C<i;++C){let D=0;for(let N=0;N<p;++N)D+=n[C*p+N]*m[N];for(let N=0;N<a;++N)_[C*a+N]=Math.trunc(D/y[N]),D%=y[N]}return[_,[i,a],l]}const lX={kernelName:h.SparseReshape,backendName:"cpu",kernelFunc:function aX(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:o}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(e.data.get(s.dataId).values),a=e.data.get(r.dataId).values,l=Array.from(e.data.get(o.dataId).values),[c,u,d]=ZN(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(u,r.dtype,c),e.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};function Wx(n,t,e,r,s,o=!1,i=0){const a=r.length,l=[t[0],n.length/t[0]],c=l[1],d=a>0?s[a-1]+1:0;if(d<0)throw new Error(h.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const p=t.slice();p[0]=d;const m=p.reduce((W,j)=>W*j,1),y=h.util.getArrayFromDType(e,m);if(0===a)return d>0&&y.fill(i),[y,p];if(d<=0)throw new Error(h.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let _=0,C=1,D=0,N=s[_];for(;;){let W=0;if(C<a){if(W=s[C],N===W){++C;continue}if(N>=W)throw new Error(h.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(N<0||N>=d)throw new Error(h.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(N,d));N>D&&y.fill(i,D*c,N*c);for(let j=_;j<C;++j){const te=r[j];if(te<0||te>=l[0])throw new Error(h.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(j,r[j],l[0]));for(let _e=0;_e<c;_e++)y[N*c+_e]+=n[te*c+_e]}if(o)for(let j=0;j<c;j++)y[N*c+j]/=C-_;if(_=C,++C,D=N+1,N=W,C>a)break}return D<d&&y.fill(i,D*c,d*c),[y,p]}const uX={kernelName:h.SparseSegmentMean,backendName:"cpu",kernelFunc:function cX(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[c,u]=Wx(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(u,r.dtype,c)}},hX={kernelName:h.SparseSegmentSum,backendName:"cpu",kernelFunc:function dX(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[c,u]=Wx(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(u,r.dtype,c)}},fX={kernelName:h.SparseToDense,backendName:"cpu",kernelFunc:function pX(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:o,defaultValue:i}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:p}=h.backend_util.calculateShapes(o,s,a),m=!1,y=e.bufferSync(s);let _;switch(o.dtype){case"bool":_=Bu(y,e.bufferSync(o),a,p,u,c,l,d,!!e.data.get(i.dataId).values[0],m);break;case"float32":case"int32":_=Bu(y,e.bufferSync(o),a,p,u,c,l,d,e.data.get(i.dataId).values[0],m);break;case"string":_=Bu(y,e.bufferSync(o),a,p,u,c,l,d,h.util.decodeString(e.data.get(i.dataId).values[0]),m);break;default:throw new Error(`Unsupported type ${o.dtype}`)}return e.makeTensorInfo(a,_.dtype,_.values)}},gX={kernelName:h.SplitV,backendName:"cpu",kernelFunc:function mX(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:o,axis:i}=r,a=h.util.parseAxisParam(i,s.shape)[0],l=h.backend_util.prepareSplitSize(s,o,a),c=new Array(s.shape.length).fill(0),u=s.shape.slice();return l.map(d=>{const p=[...u];p[a]=d;const m=Lu({inputs:{x:s},backend:e,attrs:{begin:c,size:p}});return c[a]+=d,m})}},yX=sl(n=>Math.sqrt(n)),bX=rr(h.Sqrt,n=>Math.sqrt(n)),_X={kernelName:h.Sqrt,backendName:"cpu",kernelFunc:bX},vX={kernelName:h.Square,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,r=t;qt(e,"square");const s=r.data.get(e.dataId).values,o=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];o[a]=l*l}return{dataId:r.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},xX=Hr((n,t)=>{const e=n-t;return e*e}),CX=ds(h.SquaredDifference,xX),wX={kernelName:h.SquaredDifference,backendName:"cpu",kernelFunc:CX},YN=sl((n,t)=>{const{pattern:e,replaceGlobal:r,rewrite:s}=t;return n.replace(new RegExp(e,r?"g":""),s)}),SX=Fc(h.StaticRegexReplace,YN),EX={kernelName:h.StaticRegexReplace,backendName:"cpu",kernelFunc:SX},DX=rr(h.Step,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),TX={kernelName:h.Step,backendName:"cpu",kernelFunc:DX};function QN(n,t,e,r){const s=(0,h.buffer)(n,t.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*e[l]+r[l];s.set(t.get(...a),...i)}return s}const AX={kernelName:h.StridedSlice,backendName:"cpu",kernelFunc:function IX(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,end:i,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:p}=r;qt(s,"stridedSlice");const{finalShapeSparse:m,finalShape:y,isIdentity:_,sliceDim0:C,isSimpleSlice:D,begin:N,end:W,strides:j}=h.slice_util.sliceInfo(s.shape,o,i,a,l,c,u,d,p);let te;if(_)te=gr({inputs:{x:s},backend:e,attrs:{shape:y}});else if(C||D){h.util.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const _e=h.slice_util.computeOutShape(N,W,j),Ee=Lu({inputs:{x:s},backend:e,attrs:{begin:N,size:_e}});te=gr({inputs:{x:Ee},backend:e,attrs:{shape:y}}),e.disposeIntermediateTensorInfo(Ee)}else{const Ee=QN(m,e.bufferSync(s),j,N);te=e.makeTensorInfo(y,Ee.dtype,Ee.values)}return te}};class NX{constructor(t,e,r,s,o,i){this.separator=h.util.encodeString(t),this.nGramWidths=e,this.leftPad=h.util.encodeString(r),this.rightPad=h.util.encodeString(s),this.padWidth=o,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const r=this.getPadWidth(e);return Math.max(0,t+2*r-e+1)}createNGrams(t,e,r,s,o,i){for(let a=0;a<o;++a){const l=this.getPadWidth(i),c=Math.max(0,l-a),u=Math.max(0,l-(o-(a+1))),d=i-(c+u),p=e+(c>0?0:a-l);let m=0;m+=c*this.leftPad.length;for(let N=0;N<d;++N)m+=t[p+N].length;m+=u*this.rightPad.length,m+=(c+u+d-1)*this.separator.length,r[s+a]=new Uint8Array(m);const _=r[s+a];let C=0;const D=N=>N.forEach(W=>_[C++]=W);for(let N=0;N<c;++N)D(this.leftPad),D(this.separator);for(let N=0;N<d-1;++N)D(t[p+N]),D(this.separator);if(d>0){D(t[p+d-1]);for(let N=0;N<u;++N)D(this.separator),D(this.rightPad)}else{for(let N=0;N<u-1;++N)D(this.rightPad),D(this.separator);D(this.rightPad)}}}compute(t,e){const r=t.length,s=e.length;if(s>0){let l=e[0];if(0!==l)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<s;++c){let u=e[c]>=l;if(u=u&&e[c]<=r,!u)throw new Error(`Invalid split value ${e[c]}, must be in [${l}, ${r}]`);l=e[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const o=s-1,i=h.util.getArrayFromDType("int32",s);if(0===r||0===s){const l=new Array(r);for(let c=0;c<=o;++c)i[c]=0;return[l,i]}i[0]=0;for(let l=1;l<=o;++l){const c=e[l]-e[l-1];let u=0;this.nGramWidths.forEach(d=>{u+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&0===u&&(u=1),i[l]=i[l-1]+u}const a=new Array(i[o]);for(let l=0;l<o;++l){const c=e[l];let u=i[l];if(this.nGramWidths.forEach(d=>{const m=this.getNumNGrams(e[l+1]-e[l],d);this.createNGrams(t,c,a,u,m,d),u+=m}),this.preserveShort&&u===i[l]){const d=e[l+1]-e[l];if(0===d)continue;this.createNGrams(t,c,a,u,1,d+2*this.padWidth)}}return[a,i]}}function JN(n,t,e,r,s,o,i,a){return new NX(e,r,s,o,i,a).compute(n,t)}const MX={kernelName:h.StringNGrams,backendName:"cpu",kernelFunc:function kX(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:d}=t,p=e.data.get(u.dataId).values,m=e.data.get(d.dataId).values,[y,_]=JN(p,m,s,o,i,a,l,c);return[e.makeTensorInfo([y.length],"string",y),e.makeTensorInfo(d.shape,"int32",_)]}};function RX(n,t,e,r){if(!n.length)return;if(0===t.length){for(let o=0;o<n.length;++o)r.push(n.subarray(o,o+1));return}if(1===t.length){const o=t[0];let i=n.indexOf(o);for(;-1!==i;){const a=n.subarray(0,i);(!e||0!==a.length)&&r.push(a),i=(n=n.subarray(i+1)).indexOf(o)}return void((!e||0!==n.length)&&r.push(n))}let s=0;for(let o=0;o<n.length+1;o++)if(o===n.length||-1!==t.indexOf(n[o])){const i=n.subarray(s,o);(!e||0!==i.length)&&r.push(i),s=o+1}}function ek(n,t,e){const r=n.length,s=[];let o=0,i=0;const a=new Array(r);for(let p=0;p<r;++p){const m=s.length;RX(n[p],t,e,s);const y=s.length-m;a[p]=y,o+=y,i=Math.max(i,y)}const l=h.util.getArrayFromDType("int32",2*o),c=new Array(o),u=[r,i];let d=0;for(let p=0;p<r;++p)for(let m=0;m<a[p];++m)l[2*d]=p,l[2*d+1]=m,c[d]=s[d],++d;return[l,c,u]}const FX={kernelName:h.StringSplit,backendName:"cpu",kernelFunc:function OX(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:o,delimiter:i}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=e.data.get(o.dataId).values,l=e.data.get(i.dataId).values[0],[c,u,d]=ek(a,l,s),p=u.length;return[e.makeTensorInfo([p,2],"int32",c),e.makeTensorInfo([p],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(d))]}};function tk(n,t){const e=h.util.getArrayFromDType("int32",n.length);for(let r=0;r<n.length;++r)e[r]=h.util.fingerPrint64(n[r]).modulo(t).getLowBitsUnsigned();return e}const $X={kernelName:h.StringToHashBucketFast,backendName:"cpu",kernelFunc:function PX(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=tk(e.data.get(o.dataId).values,s);return e.makeTensorInfo(o.shape,"int32",a)}},LX=rr(h.Tan,n=>Math.tan(n)),BX={kernelName:h.Tan,backendName:"cpu",kernelFunc:LX},VX=rr(h.Tanh,n=>Math.tanh(n));function nk(n,t){const e=new Array(n.rank);for(let s=0;s<e.length;s++)e[s]=n.shape[s]*t[s];const r=(0,h.buffer)(e,n.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(n.rank);for(let l=0;l<i.length;l++)i[l]=o[l]%n.shape[l];const a=n.locToIndex(i);r.values[s]=n.values[a]}return r}const yf=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function rk(n,t,e=0,r=n.length-1){for(;r>e;){if(r-e>600){const a=r-e+1,l=t-e+1,c=Math.log(a),u=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2);rk(n,t,Math.max(e,Math.floor(t-l*u/a+d)),Math.min(r,Math.floor(t+(a-l)*u/a+d)))}const s=n[t];let o=e,i=r;for(h.util.swap(n,e,t),yf(n[r],s)>0&&h.util.swap(n,e,r);o<i;){for(h.util.swap(n,o,i),o++,i--;yf(n[o],s)<0;)o+=1;for(;yf(n[i],s)>0;)i-=1}0===yf(n[e],s)?h.util.swap(n,e,i):(i+=1,h.util.swap(n,i,r)),i<=t&&(e=i+1),t<=i&&(r=i-1)}}function sk(n,t,e,r,s){const o=t[t.length-1],[i,a]=[n.length/o,o],l=h.util.getTypedArrayFromDType(e,i*r),c=h.util.getTypedArrayFromDType("int32",i*r);for(let d=0;d<i;d++){const p=d*a,m=n.subarray(p,p+a);let y=new Array(m.length);m.forEach((N,W)=>y[W]={value:N,index:W}),r<y.length&&(rk(y,r),y=y.slice(0,r)),s&&y.sort(yf);const _=d*r,C=l.subarray(_,_+r),D=c.subarray(_,_+r);for(let N=0;N<r;N++)C[N]=y[N].value,D[N]=y[N].index}const u=t.slice();return u[u.length-1]=r,[(0,h.buffer)(u,e,l),(0,h.buffer)(u,"int32",c)]}function ok(n,t,e){switch(e){case"reflect":return function ZX(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const r=2*t;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-t?e+r:-e-1}else if(e>t-1)if(t<=1)e=0;else{const r=2*t;e-=r*Math.trunc(e/r),e>=t&&(e=r-e-1)}return h.util.clamp(0,e,t-1)}(n,t);case"wrap":return function YX(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),h.util.clamp(0,e,t-1)}(n,t);case"nearest":return function JX(n,t){return h.util.clamp(0,n,t-1)}(n,t);default:return function QX(n,t){return n}(n)}}function bf(n,t,e,r,s,o,i,a,l,c,u){return 0<=a&&a<t&&0<=l&&l<e?n[i*r+a*s+l*o+c]:u}function e7(n,t,e,r,s,o,i,a,l,c,u){return bf(n,t,e,r,s,o,i,Math.round(a),Math.round(l),c,u)}function t7(n,t,e,r,s,o,i,a,l,c,u){const d=Math.floor(a),p=Math.floor(l),m=d+1,y=p+1;return(m-a)*((y-l)*bf(n,t,e,r,s,o,i,d,p,c,u)+(l-p)*bf(n,t,e,r,s,o,i,d,y,c,u))+(a-d)*((y-l)*bf(n,t,e,r,s,o,i,m,p,c,u)+(l-p)*bf(n,t,e,r,s,o,i,m,y,c,u))}function ik(n,t,e,r){const s=h.util.parseAxisParam(t,e)[0],o=[1,e[0],1];for(let y=0;y<s;y++)o[0]*=e[y];o[1]=e[s];for(let y=s+1;y<e.length;y++)o[2]*=e[y];const i=new Map,a=new Int32Array(e[s]),l=new h.TensorBuffer(o,r,n),c=[],u=1===o[0]&&1===o[2];for(let y=0;y<e[s];y++){let _;if(u)_=n[y].toString();else{const D=[];for(let N=0;N<o[0];N++)for(let W=0;W<o[2];W++)D.push(l.get(N,y,W));_=D.join(",")}const C=i.get(_);if(null!=C)a[y]=C;else{const D=i.size;i.set(_,D),a[y]=D,c.push(y)}}const d=o.slice();d[1]=i.size;const p=new h.TensorBuffer(d,r);c.forEach((y,_)=>{for(let C=0;C<o[0];C++)for(let D=0;D<o[2];D++)p.set(l.get(C,y,D),C,_,D)});const m=e.slice();return m[s]=d[1],{outputValues:p.values,outputShape:m,indices:a}}const l7=[Yj,Jj,tG,rG,Kj,oG,lG,uG,hG,fG,gG,bG,vG,wG,EG,IG,NG,MG,OG,qj,PG,BG,UG,WG,GG,jj,XG,ZG,Hj,QG,e8,t8,r8,o8,a8,c8,d8,p8,m8,y8,_8,x8,w8,E8,D8,I8,N8,M8,R8,O8,F8,V8,Oj,z8,H8,Y8,Q8,J8,t6,c6,u6,h6,f6,y6,_6,x6,w6,E6,T6,A6,Fj,k6,JG,R6,F6,$6,Pj,B6,U6,H6,j6,K6,Z6,Q6,t5,r5,o5,a5,c5,d5,p5,m5,y5,_5,x5,w5,E5,T5,N5,O5,$8,P5,B5,z5,j5,K5,q5,Y5,Q5,$N,nK,Lj,sK,hK,fK,gK,bK,Wj,Vx,vK,Bj,Vj,Xj,CK,SK,DK,IK,NK,kK,RK,FK,$K,zK,WK,XK,zj,ZK,QK,eX,$G,M5,nX,sX,iX,lX,uX,hX,fX,gX,_X,vX,wX,EX,TX,AX,MX,FX,$X,s6,L8,BX,{kernelName:h.Tanh,backendName:"cpu",kernelFunc:VX},{kernelName:h.TensorScatterUpdate,backendName:"cpu",kernelFunc:function zX(n){const{inputs:t,backend:e}=n,{tensor:r,indices:s,updates:o}=t,{sliceRank:i,numUpdates:a,sliceSize:l,strides:c,outputSize:u}=h.backend_util.calculateShapes(o,s,r.shape),p=e.bufferSync(s),m=e.bufferSync(o),y=e.bufferSync(r),_=Bu(p,m,r.shape,u,l,a,i,c,y,!1);return e.makeTensorInfo(r.shape,_.dtype,_.values)}},{kernelName:h.Tile,backendName:"cpu",kernelFunc:function WX(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:o}=r;qt(s,"tile");const i=nk(e.bufferSync(s),o);return e.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:h.TopK,backendName:"cpu",kernelFunc:function GX(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:o,sorted:i}=r;qt(s,"topk");const a=e.data.get(s.dataId).values,[l,c]=sk(a,s.shape,s.dtype,o,i);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}},{kernelName:h.Transform,backendName:"cpu",kernelFunc:function XX(n){const{inputs:t,attrs:e,backend:r}=n,{image:s,transforms:o}=t,{interpolation:i,fillMode:a,fillValue:l,outputShape:c}=e,[u,d,p,m]=s.shape,[y,_]=c??[d,p],C=[u,y,_,m],D=h.util.computeStrides(s.shape),N=D[0],W=D[1],j=D[2],te=h.util.computeStrides(C),_e=te[0],Ee=te[1],Ne=te[2],je=h.util.getTypedArrayFromDType(s.dtype,h.util.sizeFromShape(C));je.fill(l);const He=r.data.get(s.dataId).values,it=r.data.get(o.dataId).values;for(let tt=0;tt<u;++tt){const lt=1===o.shape[0]?it:it.subarray(8*tt,8*tt+8);for(let st=0;st<y;++st)for(let Pe=0;Pe<_;++Pe)for(let We=0;We<m;++We){let Ue;const Ye=lt[6]*Pe+lt[7]*st+1;if(0===Ye)continue;const yt=(lt[3]*Pe+lt[4]*st+lt[5])/Ye,Et=ok((lt[0]*Pe+lt[1]*st+lt[2])/Ye,p,a),wt=ok(yt,d,a);switch(i){case"nearest":Ue=e7(He,d,p,N,W,j,tt,wt,Et,We,l);break;case"bilinear":Ue=t7(He,d,p,N,W,j,tt,wt,Et,We,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}je[tt*_e+st*Ee+Pe*Ne+We]=Ue}return r.makeTensorInfo(C,s.dtype,je)}return{dataId:r.write(je,C,s.dtype),shape:s.shape,dtype:s.dtype}}},iG,{kernelName:h.Unique,backendName:"cpu",kernelFunc:function n7(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:o}=t;qt(o,"unique");const i=r.data.get(o.dataId).values,{outputValues:a,outputShape:l,indices:c}=ik(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},{kernelName:h.Unpack,backendName:"cpu",kernelFunc:function s7(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s.shape.length,a=s.shape[o],l=new Array(i-1);let c=0;for(let m=0;m<i;m++)m!==o&&(l[c++]=s.shape[m]);const u=new Array(i).fill(0),d=s.shape.slice();d[o]=1;const p=new Array(a);for(let m=0;m<p.length;m++){u[o]=m;const y=Lu({inputs:{x:s},backend:e,attrs:{begin:u,size:d}});p[m]=gr({inputs:{x:y},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(y)}return p}},{kernelName:h.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function i7(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:o}=t,{numSegments:i}=r;qt(s,"unsortedSegmentSum");const c=[],u=[],d=s.shape.length-o.shape.length;let p=o;for(let y=0;y<d;++y){const _=Dy({inputs:{input:p},backend:e,attrs:{dim:y+1}});p=_,u.push(_)}for(let y=0;y<i;++y){const _=h.util.createScalarValue(y,"int32"),C=e.makeTensorInfo([],"int32",_),D=pN({inputs:{a:C,b:p},backend:e}),N=Pc({inputs:{x:D},backend:e,attrs:{dtype:"float32"}}),W=Ey({inputs:{a:N,b:s},backend:e}),j=gf({inputs:{x:W},backend:e,attrs:{axis:0,keepDims:!1}});c.push(j),u.push(C),u.push(D),u.push(N),u.push(W),u.push(j)}const m=PN({inputs:c,backend:e,attrs:{axis:0}});return u.forEach(y=>e.disposeIntermediateTensorInfo(y)),m}},Z5];for(const n of l7)(0,h.registerKernel)(n);const $c={},Ay={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Ca(n,t){if(!(n in $c)||null!=t){const r=function d7(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??function u7(n){if(!(0,h.env)().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===n)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete $c[n]},!1),(0,h.env)().getBool("SOFTWARE_WEBGL_ENABLED")&&(Ay.failIfMajorPerformanceCaveat=!1),1===n?e.getContext("webgl",Ay)||e.getContext("experimental-webgl",Ay):e.getContext("webgl2",Ay)}(n,t);if(null===r)return console.log("Could not get context for WebGL version",n),null;$c[n]=r}const e=$c[n];return null==e||e.isContextLost()?(delete $c[n],Ca(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),$c[n])}var il=(()=>((il=il||{})[il.DENSE=0]="DENSE",il[il.SHARED_BATCH=1]="SHARED_BATCH",il))(),Wr=(()=>((Wr=Wr||{})[Wr.RENDER=0]="RENDER",Wr[Wr.UPLOAD=1]="UPLOAD",Wr[Wr.PIXELS=2]="PIXELS",Wr[Wr.DOWNLOAD=3]="DOWNLOAD",Wr))(),cr=(()=>((cr=cr||{})[cr.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",cr[cr.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",cr[cr.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",cr[cr.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",cr[cr.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",cr))();function _f(n,t){return[t,n]}function Ny(n){const t=h.util.sizeFromShape(n),e=Math.ceil(t/4);return h.util.sizeToSquarishShape(e)}function ph(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function jx(n,t){const e=n;let r,s,o,i,a,l,c,u,d,p;return 2===(0,h.env)().getNumber("WEBGL_VERSION")?(r=e.R32F,s=e.R16F,o=e.RGBA16F,i=e.RGBA32F,a=e.RED,c=4,u=1,d=e.HALF_FLOAT,p=e.FLOAT,l=e.RGBA8):(r=n.RGBA,s=n.RGBA,o=n.RGBA,i=e.RGBA,a=n.RGBA,c=4,u=4,d=null!=t?t.HALF_FLOAT_OES:null,p=n.FLOAT,l=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:p}}function Pt(n,t){const e=t();return(0,h.env)().getBool("DEBUG")&&function f7(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function b7(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}function y7(n){return!!((0,h.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||5.96e-8<Math.abs(n)&&Math.abs(n)<65504)}function ky(n,t){return Hl(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const x7=/ERROR: [0-9]+:([0-9]+):/g;function ak(n,t){const e=x7.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const r=+e[1],s=n.split("\n"),o=s.length.toString().length+2,i=s.map((d,p)=>h.util.rightPad((p+1).toString(),o)+d);let a=0;for(let d=0;d<i.length;d++)a=Math.max(i[d].length,a);const l=i.slice(0,r-1),c=i.slice(r-1,r),u=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${h.util.rightPad(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function Gx(n,t){if(Pt(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function lk(n,t,e,r,s,o,i){const a=n.getAttribLocation(t,e);return-1!==a&&(Pt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),Pt(n,()=>n.vertexAttribPointer(a,s,n.FLOAT,!1,o,i)),Pt(n,()=>n.enableVertexAttribArray(a)),!0)}function M7(n,t,e,r){Pt(n,()=>function A7(n,t,e){(function uk(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(n,e),Pt(n,()=>n.activeTexture(n.TEXTURE0+e)),Pt(n,()=>n.bindTexture(n.TEXTURE_2D,t))}(n,t,r)),Pt(n,()=>n.uniform1i(e,r))}function Kx(n,t,e){Pt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Pt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function ck(n,t){Pt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Pt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function My(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function R7(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function Hl(n,t,e){const r=Pt(n,()=>t());if(null==r)throw new Error(e);return r}function fh(n,t=2){return h.util.sizeFromShape(n.slice(0,n.length-t))}function mh(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Ry(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[fh(n),...mh(n)]),t}function Oy(n){return n%2==0}function Fy(n,t){if(n=n.slice(-2),t=t.slice(-2),h.util.arraysEqual(n,t)||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n[n.length-1],r=t[t.length-1];if(e===r||Oy(e)&&Oy(r)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&Oy(n[0])&&Oy(t[0])}let Py,$y;function Hi(n,t){return null!=n.getExtension(t)}function dk(n){try{if(null!=Ca(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Xx(n){const t=jx(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(o),i}function vf(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&h.util.assert("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const Qt=(0,h.env)();function mo(){let n,t,e,r,s,o,i,a,l,c;return 2===(0,h.env)().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a=(0,h.env)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}function Vu(n,t,e="index"){const r=h.util.computeStrides(t);return r.map((s,o)=>`int ${n[o]} = ${e} / ${s}; ${o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${s}`:`index -= ${n[o]} * ${s}`};`).join("")}function Ly(n,t,e="index"){const r=h.util.computeStrides(t);return r.map((s,o)=>`int ${n[o]} = ${e} / outShapeStrides[${o}]; ${o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`};`).join("")}function qx(n){const t=h.util.computeStrides(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Qt.registerFlag("HAS_WEBGL",()=>Qt.getNumber("WEBGL_VERSION")>0),Qt.registerFlag("WEBGL_VERSION",()=>dk(2)?2:dk(1)?1:0),Qt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Qt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Qt.get("WEBGL_VERSION")),Qt.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Qt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Qt.registerFlag("WEBGL_PACK",()=>Qt.getBool("HAS_WEBGL")),Qt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Qt.getBool("WEBGL_PACK")),Qt.registerFlag("WEBGL_PACK_CLIP",()=>Qt.getBool("WEBGL_PACK")),Qt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Qt.getBool("WEBGL_PACK")),Qt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK")),Qt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK")),Qt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK")),Qt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Qt.getBool("WEBGL_PACK")),Qt.registerFlag("WEBGL_PACK_REDUCE",()=>Qt.getBool("WEBGL_PACK")),Qt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Qt.getBool("WEBGL_PACK")),Qt.registerFlag("WEBGL_CONV_IM2COL",()=>Qt.getBool("WEBGL_PACK")),Qt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function F7(n){if(null==Py){const t=Ca(n);Py=t.getParameter(t.MAX_TEXTURE_SIZE)}return Py}(Qt.getNumber("WEBGL_VERSION"))),Qt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function P7(n){if(null==$y){const t=Ca(n);$y=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,$y)}(Qt.getNumber("WEBGL_VERSION"))),Qt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Qt.getNumber("WEBGL_VERSION");return 0===n?0:function $7(n){if(0===n)return 0;let t;const e=Ca(n);return t=Hi(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:Hi(e,"EXT_disjoint_timer_query")?1:0,t}(n)}),Qt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Qt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!h.device_util.isMobile()),Qt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function L7(n){if(0===n)return!1;const t=Ca(n);if(1===n){if(!Hi(t,"OES_texture_float"))return!1}else if(!Hi(t,"EXT_color_buffer_float"))return!1;return Xx(t)}(Qt.getNumber("WEBGL_VERSION"))),Qt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Qt.getBool("WEBGL_FORCE_F16_TEXTURES")&&Qt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Qt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function B7(n){if(0===n)return!1;const t=Ca(n);if(1!==n){if(Hi(t,"EXT_color_buffer_float"))return Xx(t);const r="EXT_color_buffer_half_float";if(Hi(t,r)){const s=t.getExtension(r);return function V7(n,t){const e=jx(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(i),a}(t,s)}return!1}return!(!Hi(t,"OES_texture_float")||!Hi(t,"WEBGL_color_buffer_float"))&&Xx(t)}(Qt.getNumber("WEBGL_VERSION"))),Qt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function U7(n){return 2===n&&null!=Ca(n).fenceSync}(Qt.getNumber("WEBGL_VERSION"))),Qt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Qt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Qt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),Qt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>h.device_util.isMobile()?1:-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),Qt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Qt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Qt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Qt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Qt.registerFlag("WEBGL_EXP_CONV",()=>!1),Qt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Qt.getBool("IS_TEST")),Qt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Qt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Qt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),Qt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const hk="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:pk}=h.backend_util;function W7(n,t,e){const r=[];if(n.forEach(m=>{const y=h.util.sizeFromShape(m.shapeInfo.logicalShape);if(m.shapeInfo.isUniform?r.push(`uniform float ${m.name}${y>1?`[${y}]`:""};`):(r.push(`uniform sampler2D ${m.name};`),r.push(`uniform int offset${m.name};`)),e.enableShapeUniforms){const{uniformShape:_}=Yx(e.packedInputs,m.shapeInfo.logicalShape,m.shapeInfo.texShape);switch(_.length){case 1:r.push(`uniform int ${m.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${m.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${m.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${m.name}Shape;`)}r.push(`uniform ivec2 ${m.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(m=>{r.push(`uniform ${m.type} ${m.name}${m.arrayIndex?`[${m.arrayIndex}]`:""};`)});const s=r.join("\n"),o=n.map(m=>function j7(n,t,e=!1,r){let s="";s+=e?fk(n,r):gh(n,r);return n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(s+=e?function Sq(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",o=n.shapeInfo.logicalShape.length,i=t.logicalShape.length,a=pk(n.shapeInfo.logicalShape,t.logicalShape),l=ur(i),c=i-o;let u;const d=["x","y","z","w","u","v"];u=0===o?"":i<2&&a.length>=1?"coords = 0;":a.map(N=>`coords.${d[N+c]} = 0;`).join("\n");let p="";p=i<2&&o>0?"coords":n.shapeInfo.logicalShape.map((N,W)=>`coords.${d[W+c]}`).join(", ");let m="return outputValue;";const _=1===h.util.sizeFromShape(n.shapeInfo.logicalShape),D=1===h.util.sizeFromShape(t.logicalShape);if(1!==o||_||D){if(_&&!D)m=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const N=o-2,W=o-1;a.indexOf(N)>-1&&a.indexOf(W)>-1?m="return vec4(outputValue.x);":a.indexOf(N)>-1?m="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(W)>-1&&(m="return vec4(outputValue.xx, outputValue.zz);")}}else m="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${u}\n      vec4 outputValue = get${r}(${p});\n      ${m}\n    }\n  `}(n,t):function Eq(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",a=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&null==n.shapeInfo.flatOffset&&h.util.arraysEqual(n.shapeInfo.texShape,t.texShape))return`\n      float ${s}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const c=ur(l),u=pk(n.shapeInfo.logicalShape,t.logicalShape),d=l-a;let p;const m=["x","y","z","w","u","v"];p=0===a?"":l<2&&u.length>=1?"coords = 0;":u.map(_=>`coords.${m[_+d]} = 0;`).join("\n");let y="";return y=l<2&&a>0?"coords":n.shapeInfo.logicalShape.map((_,C)=>`coords.${m[C+d]}`).join(", "),`\n    float ${s}() {\n      ${c} coords = getOutputCoords();\n      ${p}\n      return get${r}(${y});\n    }\n  `}(n,t)),s}(m,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),i=t.texShape,a=mo(),l=function X7(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let c,u,d=function Y7(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Q7}\n    ${J7}\n    ${eq}\n  `}(a);return t.isPacked?(c=function G7(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function nq(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function uq(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(h.util.arraysEqual(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function sq(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[2]/2),o=s*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function iq(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[n.length-1]/2),o=s*Math.ceil(n[n.length-2]/2);let i=o,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)i*=n[n.length-c-1],a=`\n      int b${c} = index / ${i};\n      index -= b${c} * ${i};\n    `+a,l=`b${c}, `+l;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${n.length}(${l});\n    }\n  `}(n,t,e)}}(t.logicalShape,i,e.enableShapeUniforms),u=function Z7(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(a)):(c=function K7(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function rq(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function dq(n,t,e){return h.util.arraysEqual(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function oq(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Ly(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const r=Vu(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function aq(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Ly(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=Vu(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function lq(n,t){const e=Vu(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function cq(n,t){const e=Vu(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,e.enableShapeUniforms),u=function q7(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(d+=tq),[d,l,u,s,c,o,e.userCode].join("\n")}function gh(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function pq(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[s,o]=n.shapeInfo.texShape;if(1===s&&1===o)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const i=Uu(e);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,l]=n.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${l}, ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function mq(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${yh(n)}\n      }\n    `;const s=n.shapeInfo.texShape,o=s[0],i=s[1];if(1===i&&1===o)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=Uu(e);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===o?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function yq(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape;if(null!=o&&h.util.arraysEqual(e,o))return t?`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${o[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:i,keptDims:a}=h.util.squeezeShape(e);if(i.length<e.length){const m=["row","col"];return`\n      ${gh(bh(n,i),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${_h(m,a)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${yh(n)}\n      }\n    `;const c=o[0],u=o[1],d=Uu(r);return 1===u?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===c?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${c}, ${u}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(n,t);case 3:return function _q(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[1]*e[2],i=e[2],{newShape:a,keptDims:l}=h.util.squeezeShape(e);if(a.length<e.length){const C=["row","col","depth"];return`\n        ${gh(bh(n,a),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${_h(C,l)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${i}, 1)));\n        ${yh(n)}\n      }\n    `;const u=n.shapeInfo.texShape,d=u[0],p=u[1],m=n.shapeInfo.flatOffset;if(p===o&&null==m)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${p}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(p===i&&null==m)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const y=Uu(r);return t?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${y};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${i} + depth + ${y};\n        vec2 uv = uvFromFlat(${d}, ${p}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(n,t);case 4:return function xq(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[3],i=e[2]*o,a=e[1]*i,{newShape:l,keptDims:c}=h.util.squeezeShape(e);if(l.length<e.length){const W=["row","col","depth","depth2"];return`\n      ${gh(bh(n,l),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${_h(W,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${i}, ${o}, 1)));\n        ${yh(n)}\n      }\n    `;const u=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],m=d[1],y=`int stride2 = ${r}Shape[3];`,_=`int stride1 = ${r}Shape[2] * stride2;`,C=`int stride0 = ${r}Shape[1] * stride1;`;if(m===a&&null==u)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${y}\n        ${_}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(m===o&&null==u)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const D=Uu(r);return t?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${y}\n      ${_}\n      ${C}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${D});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${p}, ${m}, index + ${D});\n      return sampleTexture(${r}, uv);\n    }\n  `}(n,t);case 5:return function Cq(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[4],o=t[3]*s,i=t[2]*o,a=t[1]*i,{newShape:l,keptDims:c}=h.util.squeezeShape(t);if(l.length<t.length){const C=["row","col","depth","depth2","depth3"];return`\n      ${gh(bh(n,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${_h(C,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${i}, ${o}, ${s})) +\n          depth3;\n        ${yh(n)}\n      }\n    `;const u=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],m=d[1];if(m===a&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${p}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(m===s&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${p}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} + depth * ${o} +\n          depth2 * ${s} + depth3 + ${Uu(e)};\n      vec2 uv = uvFromFlat(${p}, ${m}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function wq(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:o}=h.util.squeezeShape(t);if(s.length<t.length){const D=["row","col","depth","depth2","depth3","depth4"];return`\n      ${gh(bh(n,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${_h(D,o)});\n      }\n    `}const i=t[5],a=t[4]*i,l=t[3]*a,c=t[2]*l,u=t[1]*c;if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${c}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${yh(n)}\n      }\n    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],y=p[1];if(y===u&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${l}, ${a}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${y}.0, ${m}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(y===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${y}.0, ${m}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${c} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${i} + depth4 + ${Uu(e)};\n      vec2 uv = uvFromFlat(${m}, ${y}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function fk(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function hq(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${mo().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function fq(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n.shapeInfo.texShape,o=mo();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function gq(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,i=o[0],a=o[1],l=mo();if(null!=o&&h.util.arraysEqual(e,o))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(n,t);case 3:return function bq(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){const m=[1,2],_=["b","row","col"];return`\n        ${fk(bh(n,e.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${_h(_,m)});\n        }\n      `}const a=mo();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],c=i[1],u=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${c}, ${u*Math.ceil(e[1]/2)}, ${u}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(n,t);default:return function vq(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=mo();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${e}, uv);\n    }\n  `;const o=n.shapeInfo.logicalShape,i=o.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],d=Math.ceil(o[i-1]/2);let p=d*Math.ceil(o[i-2]/2),m="int b, int row, int col",y=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let _=2;_<i-1;_++)m=`int b${_}, `+m,p*=o[i-_-1],y=`b${_} * ${p} + `+y;return`\n    vec4 ${r}(${m}) {\n      int index = ${y};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const Q7="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",J7="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",eq="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",tq="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Uu(n){return`offset${n}`}function yh(n){const t=n.name,e=h.util.sizeFromShape(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function ur(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Yx(n,t,e){const{newShape:r,keptDims:s}=h.util.squeezeShape(t),o=t.length,i=n&&3===o&&1===t[0],a=i?t.slice(1):r,l=!n&&o>1&&!h.util.arraysEqual(t,e)&&r.length<o||i;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:s}}function bh(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function _h(n,t){return t.map(e=>n[e]).join(", ")}function gk(n,t,e){const r=[],s=[];let o,i,a,l=null,c=null;c=n.getUniformLocation(e,"NAN",!1),1===(0,h.env)().getNumber("WEBGL_VERSION")&&(l=n.getUniformLocation(e,"INFINITY",!1));const u=!1;for(const d of t.variableNames){const p={name:d,uniform:n.getUniformLocation(e,d,u),offset:n.getUniformLocation(e,`offset${d}`,u)};t.enableShapeUniforms&&(p.shape=n.getUniformLocation(e,`${d}Shape`,u),p.texShape=n.getUniformLocation(e,`${d}TexShape`,u)),r.push(p)}if(t.enableShapeUniforms&&(o=n.getUniformLocation(e,"outShape",u),a=n.getUniformLocation(e,"outShapeStrides",u),i=n.getUniformLocation(e,"outTexShape",u)),t.customUniforms)for(const d of t.customUniforms)s.push(n.getUniformLocation(e,d.name,u));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:c,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:i}}function yk(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,r)=>{const s=e.logicalShape,o=t[r],i=o.shape;if(!h.util.arraysEqual(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(e.isUniform&&o.isUniform)return;const a=e.texShape,l=o.isUniform?null:o.texData.texShape;if(!h.util.arraysEqual(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function Xs(n){return(0,h.env)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class Aq{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=il.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=mo();this.outputShape=t,this.enableShapeUniforms=Xs(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Ly(["r","c","d"],t):Vu(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class Nq{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=il.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=mo();this.outputShape=t,this.enableShapeUniforms=Xs(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Ly(["r","c","d"],t):Vu(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class kq{constructor(t){this.variableNames=["A"],this.outTexUsage=Wr.DOWNLOAD;const e=mo();this.outputShape=t,this.userCode=`\n      ${hk}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class Mq{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Wr.DOWNLOAD;const e=mo();this.outputShape=t,this.userCode=`\n      ${hk}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const Rq={R:0,G:1,B:2,A:3};class bk{constructor(t,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=mo();this.outputShape=t,this.enableShapeUniforms=Xs(this.outputShape.length);let o="result";e&&(o="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++)i+=`\n          if(offset == ${a}) {\n            result = values[${Rq[r[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":qx(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${i}\n        }\n        ${s.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class Oq{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=mo();this.outputShape=t,this.enableShapeUniforms=Xs(this.outputShape.length);let s="",o="result";e&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const l=2*i+a;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${i};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${l}] = values[0];\n            } else if (offset == 1) {\n              result[${l}] = values[1];\n            } else if (offset == 2) {\n              result[${l}] = values[2];\n            } else {\n              result[${l}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":qx(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${r.output} = ${o};\n        }\n    `}}function xf(n,t,e,r,s,o){!function T7(n,t){const e=(0,h.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(t,e);const i=function D7(n){return Hl(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}(n),a=n.TEXTURE_2D;return Pt(n,()=>n.bindTexture(a,i)),Pt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Pt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Pt(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),Pt(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===(0,h.env)().getNumber("WEBGL_VERSION")?Pt(n,()=>n.texImage2D(a,0,r,t,e,0,s,o,null)):Pt(n,()=>n.texStorage2D(a,1,r,t,e)),Pt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:i,texShape:[e,t]}}function _k(n){return n.internalFormatFloat}function vk(n){return n.internalFormatHalfFloat}function xk(n){return n.downloadTextureFormat}function Ck(n){return n.internalFormatPackedFloat}function wk(n){return n.internalFormatPackedHalfFloat}class Qx{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=(0,h.env)().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function c7(n,t){$c[n]=t}(e,t)):this.gl=Ca(e),t=this.gl,2===(0,h.env)().getNumber("WEBGL_VERSION")){const o=t;this.createVertexArray=()=>Pt(o,()=>o.createVertexArray()),this.bindVertexArray=i=>Pt(o,()=>o.bindVertexArray(i)),this.deleteVertexArray=i=>Pt(o,()=>o.deleteVertexArray(i)),this.getVertexArray=()=>Pt(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(null!=t){const o=t.getExtension("OES_vertex_array_object");if(null==o)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Pt(t,()=>o.createVertexArrayOES()),this.bindVertexArray=i=>Pt(t,()=>o.bindVertexArrayOES(i)),this.deleteVertexArray=i=>Pt(t,()=>o.deleteVertexArrayOES(i)),this.getVertexArray=()=>Pt(t,()=>t.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,h.env)().getNumber("WEBGL_VERSION")){const i="OES_texture_half_float";if(this.textureFloatExtension=ky(this.gl,"OES_texture_float"),Hi(this.gl,i))this.textureHalfFloatExtension=ky(this.gl,i);else if((0,h.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Hi(this.gl,s))this.colorBufferHalfFloatExtension=ky(this.gl,s);else if((0,h.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Hi(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!Hi(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function Pq(n){return function S7(n,t){const e=Hl(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Pt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),Pt(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function $q(n){return function E7(n,t){const e=Hl(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Pt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),Pt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function I7(n){return Hl(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=jx(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,h.env)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;Pt(t,()=>t.finish()),Pt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Pt(t,()=>t.deleteFramebuffer(this.framebuffer)),Pt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Pt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Pt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function Lq(n,t,e,r){const[s,o]=_f(t,e);return xf(n,s,o,_k(r),r.textureFormatFloat,n.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function Bq(n,t,e,r){const[s,o]=_f(t,e);return xf(n,s,o,vk(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function Vq(n,t,e,r){const[s,o]=_f(t,e);return xf(n,s,o,xk(r),n.RGBA,n.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function jq(n,t,e){Pt(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===(0,h.env)().getNumber("WEBGL_VERSION")?Pt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):Pt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===(0,h.env)().getNumber("WEBGL_VERSION")?Pt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):Pt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),Pt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,r,s){this.throwIfDisposed(),function Wq(n,t,e,r,s,o){let i,a,l;Pt(n,()=>n.bindTexture(n.TEXTURE_2D,t)),s instanceof Uint8Array?(i=new Uint8Array(e*r*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(i=new Float32Array(e*r*4),a=n.FLOAT,l=o.internalFormatPackedFloat),i.set(s),2===(0,h.env)().getNumber("WEBGL_VERSION")?Pt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,r,n.RGBA,a,i)):Pt(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,r,0,n.RGBA,a,i)),Pt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function zq(n,t,e,r){const[s,o]=ph(t,e);return xf(n,s,o,wk(r),n.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function Uq(n,t,e,r){const[s,o]=ph(t,e);return xf(n,s,o,Ck(r),n.RGBA,n.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(ck(this.gl,this.framebuffer),this.outputTexture=null),Pt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function Xq(n,t,e,r){const[s,o]=_f(t,e),a=new Uint8Array(function h7(n,t){return n*t}(t*e,4));return Pt(n,()=>n.readPixels(0,0,s,o,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,r,s,o,i){return function qq(n,t,e,r,s,o,i,a){const l=n,c=new Float32Array(function p7(n,t){const[e,r]=ph(n,t);return e*r*4}(o,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}(this.gl,t,0,0,0,o,i)}downloadFloat32MatrixFromBuffer(t,e){return function Kq(n,t,e){const r=n,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,t,e)}createBufferFromTexture(t,e,r){this.bindTextureToFrameBuffer(t);const s=function Gq(n,t,e,r){const s=n.createBuffer();Pt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const a=16*t*e;return Pt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),Pt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),Pt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,r;if((0,h.env)().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},e=o}else(0,h.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,(0,h.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function Zq(n,t,e){const r=new Float32Array(t*e*4);return Pt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,r)),r}(this.gl,e,r))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function Fq(n){const t=mo();return function _7(n,t){const e=Hl(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Pt(n,()=>n.shaderSource(e,t)),Pt(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function C7(n){return Hl(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}(e);Pt(e,()=>e.attachShader(r,this.vertexShader)),Pt(e,()=>e.attachShader(r,t)),function w7(n,t){if(Pt(n,()=>n.linkProgram(t)),!(0,h.env)().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(e,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&Gx(e,s),s}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;Pt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),function Hq(n,t,e){Pt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),lk(n,t,"clipSpacePos",e,3,20,0)&&lk(n,t,"uv",e,2,20,12)}(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(Pt(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&Gx(this.gl,this.program),Pt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,r=!0){return this.throwIfDisposed(),r?function N7(n,t,e){return Hl(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}(this.gl,t,e):function k7(n,t,e){return n.getUniformLocation(t,e)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),Pt(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),M7(this.gl,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();const[s,o]=ph(e,r);this.setOutputMatrixTextureDriver(t,s,o)}setOutputMatrixWriteRegion(t,e,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&Gx(this.gl,this.program),My(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Pt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Pt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=ky(this.gl,2===(0,h.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,h.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===(0,h.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return(0,xa.Z)(function*(){return yield h.util.repeatedTry(()=>e.disposed||e.isQueryAvailable(t,(0,h.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,(0,h.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function Yq(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in(0,h.env)().platform&&(r=(0,h.env)().platform.setTimeoutCustom.bind((0,h.env)().platform)),h.util.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),Kx(this.gl,t,this.framebuffer),this.debug&&My(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Kx(this.gl,this.outputTexture,this.framebuffer),this.debug&&My(this.gl)):ck(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();const s=this.gl;Kx(s,t,this.framebuffer),this.debug&&My(s),this.outputTexture=t,Pt(s,()=>s.viewport(0,0,e,r)),Pt(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,s){this.throwIfDisposed(),Pt(this.gl,()=>this.gl.scissor(t,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:Qq,bincountImpl:Sk,bincountReduceImpl:Jq,castImpl:e9,ceilImpl:t9,concatImpl:n9,equalImpl:r9,expImpl:s9,expm1Impl:o9,floorImpl:i9,gatherNdImpl:a9,gatherV2Impl:l9,greaterImpl:c9,greaterEqualImpl:u9,lessImpl:d9,lessEqualImpl:h9,linSpaceImpl:p9,logImpl:f9,maxImpl:m9,maximumImpl:g9,minimumImpl:y9,multiplyImpl:b9,negImpl:_9,notEqualImpl:v9,prodImpl:x9,raggedGatherImpl:C9,raggedRangeImpl:w9,raggedTensorToTensorImpl:S9,rangeImpl:E9,rsqrtImpl:D9,scatterImpl:T9,sigmoidImpl:I9,simpleAbsImpl:Ek,sliceImpl:A9,sparseFillEmptyRowsImpl:N9,sparseReshapeImpl:k9,sparseSegmentReductionImpl:Dk,sqrtImpl:M9,staticRegexReplaceImpl:R9,stridedSliceImpl:O9,stringNGramsImpl:F9,stringSplitImpl:P9,stringToHashBucketFastImpl:$9,subImpl:L9,tileImpl:B9,topKImpl:V9,transposeImpl:Jx,uniqueImpl:U9}=ue;function Tk(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function go(n,t){return 1===t?[n]:Tk(n,t)}class H9{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Xs(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=go("rc",this.rank),r=ur(this.rank),s=this.getOutOfBoundsCondition(e),o=this.getSetup(e),i=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${t[t.length-1-i]},`+o;e.push(o)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class Ik{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Xs(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2==1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`\n        ${o}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function W9(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function H7(n,t,e="index"){const s=function z7(n,t){const e=n.length,r=n.map(o=>`${t}[${o}]`),s=new Array(e-1);s[e-2]=r[e-1];for(let o=e-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}(n.map((o,i)=>i),t);return s.map((o,i)=>`int ${n[i]} = ${e} / ${s[i]}; ${i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${s[i]}`:`index -= ${n[i]} * ${s[i]}`};`).join("")}(["r","c","d"],"inputShape"):Vu(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":qx(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class j9{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,r){const s=Nk(e,r),o=kk(t,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=Ak(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[o].pop();return this.usedTextures[o].push(l),l}let a;return s===cr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===cr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===cr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===cr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===cr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,e,r,s){if(null==this.freeTextures)return;const o=Nk(r,s),i=kk(e,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=Ak(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=(0,h.env)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[i],u=c&&c.indexOf(t);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[u]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Ak(n,t,e,r,s){const o=function K9(n,t){switch(n){case cr.PACKED_2X2_FLOAT32:return Ck(t);case cr.PACKED_2X2_FLOAT16:return wk(t);case cr.UNPACKED_FLOAT32:return _k(t);case cr.UNPACKED_FLOAT16:return vk(t);case cr.PACKED_4X1_UNSIGNED_BYTE:return xk(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,r);let i;if(s){const[l,c]=ph(n[0],n[1]);i=l*c}else{const[l,c]=_f(n[0],n[1]);i=l*c}const a=function G9(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,o);return i*a}function Nk(n,t){if(n===Wr.UPLOAD)return cr.PACKED_2X2_FLOAT32;if(n===Wr.RENDER||null==n)return function X9(n){return(0,h.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?cr.PACKED_2X2_FLOAT32:cr.UNPACKED_FLOAT32:n?cr.PACKED_2X2_FLOAT16:cr.UNPACKED_FLOAT16}(t);if(n===Wr.DOWNLOAD||n===Wr.PIXELS)return cr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function kk(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class al{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Xs(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const _i="if (isnan(x)) return x;",q9="return x;",Mk="return abs(x);",Z9="return (x >= 0.0) ? x : (exp(x) - 1.0);",Y9=_i+"\n  return (x < 0.0) ? 0.0 : x;\n",Q9=_i+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Lc="return x;",J9="return 1.0 / (1.0 + exp(-1.0 * x));",eZ="return x;",tZ="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",nZ="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",rZ="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",sZ="return 1.0 / (1.0 + exp(-1.0 * x));";class Bc{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Xs(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class oZ{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Xs(this.outputShape.length);const e=t.length,r=go("rc",e),s=ur(e),o=function z9(n,t){if(1===n)return"rc";let e="";for(let r=0;r<n;r++)e+=t[r],r<n-1&&(e+=",");return e}(e,r),i=r.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const iZ=h.kernel_impls.whereImpl,Vy={},uZ=(0,h.env)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let pZ=(()=>{class n extends h.KernelBackend{nextDataId(){return n.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,h.env)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof Qx)r=e;else{const s=Ca((0,h.env)().getNumber("WEBGL_VERSION"),e);r=new Qx(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Ca((0,h.env)().getNumber("WEBGL_VERSION"));r=new Qx(s),this.binaryCache=function cZ(n){return n in Vy||(Vy[n]={}),Vy[n]}((0,h.env)().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new j9(this.gpgpu),this.numMBBeforeWarning=function hZ(){return null==(0,h.env)().global.screen?1024:(0,h.env)().global.screen.height*(0,h.env)().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new h.DataStorage(this,(0,h.engine)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,s,o,i,a){const l=this.makeTensorInfo(r,s),c=this.texData.get(l.dataId);c.isPacked=!1,c.texture={texture:e,texShape:[o,i]},c.texShape=[o,i];const u=Ry(r),d=new bk(u,!1,a),p=this.runWebGLProgram(d,[l],s,[[o,i]]);return p.shape=r,c.texture=null,this.disposeIntermediateTensorInfo(l),p.dataId}write(e,r,s){if(((0,h.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,h.env)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===s&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:r,dtype:s,values:e,usage:Wr.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,s,o,i){if((0,h.env)().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===o)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:o,values:r,usage:Wr.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:s,dtype:o,complexTensorInfos:i,slice:a,shape:l,isPacked:c}=r;if(null!=a){let m;m=c?new Bc(l,Lc):new al(l,Lc);const y=this.runWebGLProgram(m,[{dataId:e,shape:l,dtype:o}],o),_=this.readSync(y.dataId);return this.disposeIntermediateTensorInfo(y),_}if(null!=s)return this.convertAndCacheOnCPU(e);if("string"===o)return s;const u=null!=this.activeTimers;let d,p;if(u&&(d=h.util.now()),"complex64"===o){const m=this.readSync(i.real.dataId),y=this.readSync(i.imag.dataId);p=h.backend_util.mergeRealAndImagArrays(m,y)}else p=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=h.util.now()-d),this.convertAndCacheOnCPU(e,p)}read(e){var r=this;return(0,xa.Z)(function*(){if(r.pendingRead.has(e)){const C=r.pendingRead.get(e);return new Promise(D=>C.push(D))}const s=r.texData.get(e),{values:o,shape:i,slice:a,dtype:l,complexTensorInfos:c,isPacked:u}=s;if(null!=a){let C;C=u?new Bc(i,Lc):new al(i,Lc);const D=r.runWebGLProgram(C,[{dataId:e,shape:i,dtype:l}],l),N=r.read(D.dataId);return r.disposeIntermediateTensorInfo(D),N}if(null!=o)return r.convertAndCacheOnCPU(e);if((0,h.env)().getBool("DEBUG")&&!(0,h.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,h.env)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let p,m,d=null;if("complex64"!==l&&(0,h.env)().get("WEBGL_BUFFER_SUPPORTED")){p=r.decode(e);const C=r.texData.get(p.dataId);d=r.gpgpu.createBufferFromTexture(C.texture.texture,...Ny(i))}if(r.pendingRead.set(e,[]),"complex64"!==l&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===l){const C=yield Promise.all([r.read(c.real.dataId),r.read(c.imag.dataId)]);m=h.backend_util.mergeRealAndImagArrays(C[0],C[1])}else if(null==d)m=r.getValuesFromTexture(e);else{const C=h.util.sizeFromShape(i);m=r.gpgpu.downloadFloat32MatrixFromBuffer(d,C)}if(null!=p&&r.disposeIntermediateTensorInfo(p),null!=d){const C=r.gpgpu.gl;Pt(C,()=>C.deleteBuffer(d))}const y=r.convertAndCacheOnCPU(e,m),_=r.pendingRead.get(e);return r.pendingRead.delete(e),_.forEach(C=>C(y)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&(0,h.engine)().removeDataId(e,r),r.pendingDeletes--),y})()}readToGPU(e,r={}){const s=this.texData.get(e),{values:o,shape:i,slice:a,dtype:l,isPacked:c,texture:u}=s;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let y;y=c?new Bc(i,Lc):new al(i,Lc);const _=this.runWebGLProgram(y,[{dataId:e,shape:i,dtype:l}],l),C=this.readToGPU(_,r);return this.disposeIntermediateTensorInfo(_),C}if(null==u)throw null!=o?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,r.customTexShape),p=(0,h.engine)().makeTensorFromTensorInfo(d),m=this.texData.get(d.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(o=>h.util.decodeString(o));return(0,h.buffer)(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,h.buffer)(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const s=e[r];if(!y7(s))throw(0,h.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:s,isPacked:o}=this.texData.get(e),i=h.util.sizeFromShape(r);if((0,h.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(e),y=this.texData.get(m.dataId),_=this.gpgpu.downloadMatrixFromPackedTexture(y.texture.texture,...Ny(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(m),_}const a=(0,h.env)().getBool("WEBGL_PACK")&&!0===o,l=a?Ry(r):r,c=a?new Mq(l):new kq(l),u=this.runWebGLProgram(c,[{shape:l,dtype:s,dataId:e}],"float32"),d=this.texData.get(u.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(u),p}timerAvailable(){return(0,h.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const s=this.activeTimers,o=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=o,i=!0):this.activeTimers.push(o),this.activeTimers=o,e();const a=h.util.flatten(this.activeTimers.map(u=>u.query)).filter(u=>null!=u),l=h.util.flatten(this.activeTimers.map(u=>u.name)).filter(u=>null!=u);this.activeTimers=s,i&&(this.programTimersStack=null);const c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(0,xa.Z)(function*(){if((0,h.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=yield Promise.all(a);c.kernelMs=h.util.sum(u),c.getExtraProfileInfo=()=>u.map((d,p)=>({name:l[p],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,h.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:h.util.now(),endMs:null}}endTimer(e){return(0,h.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=h.util.now(),e)}getQueryTime(e){var r=this;return(0,xa.Z)(function*(){return(0,h.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:s,texShape:o,usage:i,isPacked:a,slice:l}=this.texData.get(e),c=l&&l.origDataId||e,u=this.dataRefCount.get(c);u>1?this.dataRefCount.set(c,u-1):(this.dataRefCount.delete(c),null!=r&&(this.numBytesInGPU-=this.computeBytes(o,s),this.textureManager.releaseTexture(r,o,i,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=uZ){return(0,h.env)().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>null==this.texData.get(s.dataId).texture&&h.util.sizeFromShape(s.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){h.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return iZ(e.shape,r)}packedUnaryOp(e,r,s){const o=new Bc(e.shape,r),i=this.compileAndRun(o,[e],s);return(0,h.engine)().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const o=Ek(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if((0,h.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Mk,e.dtype);const r=new al(e.shape,Mk),s=this.compileAndRun(r,[e]);return(0,h.engine)().makeTensorFromTensorInfo(s)}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&h.util.isString(s[0])){const i=s.map(a=>h.util.encodeString(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:r}}makeOutput(e,r,s){return(0,h.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,s),this)}unpackTensor(e){const r=new oZ(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new H9(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const s=[fh(e.shape),...mh(e.shape)],o={dtype:e.dtype,shape:s,dataId:e.dataId},i=[fh(r),...mh(r)],a=new Ik(i,s),u=this.runWebGLProgram(a,[o],e.dtype,[s],!0);return{dataId:u.dataId,shape:r,dtype:u.dtype}}decode(e,r){const s=this.texData.get(e),{isPacked:o,shape:i,dtype:a}=s;if(null!=r){const m=h.util.sizeFromShape(i);h.util.assert(m<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const l=Ry(i);let c;c=o?new Nq(l):new Aq(l);const d=[r??Ny(l)];return{dtype:a,shape:i,dataId:this.runWebGLProgram(c,[{shape:l,dtype:a,dataId:e}],a,d,!0,r).dataId}}runWebGLProgram(e,r,s,o,i=!1,a){const l=this.makeTensorInfo(e.outputShape,s),c=this.texData.get(l.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===il.DENSE){const N=a??Ny(e.outputShape);c.texShape=N.map(W=>2*W)}if(null!=e.outTexUsage&&(c.usage=e.outTexUsage),0===h.util.sizeFromShape(l.shape))return c.values=h.util.getTypedArrayFromDType(l.dtype,0),l;const u=[],d=r.map(N=>{if("complex64"===N.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let W=this.texData.get(N.dataId);if(null==W.texture){if(!e.packedInputs&&h.util.sizeFromShape(N.shape)<=(0,h.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:N.shape,texData:null,isUniform:!0,uniformValues:W.values};e.packedInputs&&(W.isPacked=!0,W.shape=N.shape)}if(this.uploadToGPU(N.dataId),!!W.isPacked!=!!e.packedInputs)N=W.isPacked?this.unpackTensor(N):this.packTensor(N),u.push(N),W=this.texData.get(N.dataId);else if(W.isPacked&&!Fy(W.shape,N.shape)){const j=N,te=N.shape;N.shape=W.shape,N=this.packedReshape(N,te),u.push(N),W=this.texData.get(N.dataId),j.shape=te}return{shape:N.shape,texData:W,isUniform:!1}});this.uploadToGPU(l.dataId);const p={shape:l.shape,texData:c,isUniform:!1},m=function Iq(n,t,e){let r="";t.concat(e).forEach(i=>{const a=null!=i.texData&&null!=i.texData.slice&&i.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:d}=Yx(n.packedInputs,i.shape,l);let p="",m="",y="";if(1===u.length&&n.packedInputs){const te=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${te[0]>1}_${te[1]>1}`}else if(2!==u.length||n.packedInputs){if(u.length>2&&!n.packedInputs){const te=h.util.computeStrides(u);y=`${te[0]===l[1]}_${te[te.length-1]===l[1]}`}}else m=`${u[0]>1}_${u[1]>1}`;const _=i.shape.length,C=2===u.length&&h.util.arraysEqual(i.shape,l),D=1===h.util.sizeFromShape(i.shape),N=h.backend_util.getBroadcastDims(i.shape,e.shape),W=!n.packedInputs&&_===e.shape.length&&h.util.arraysEqual(l,e.texData.texShape);r+=`${_}_${W}_${c?d:""}_${u.length}_${D}_${N}_${C}_${p}_${m}_${y}_${n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`}_${a}`}else r+=`${i.shape}_${i.isUniform?"uniform":i.texData.texShape}_${a}`});let o=n.constructor.name;return o+="_"+r+"_"+n.userCode+`${(0,h.env)().getNumber("WEBGL_VERSION")}`,o}(e,d,p),y=this.getAndSaveBinary(m,()=>function Dq(n,t,e,r){const s=e.map((u,d)=>{const p={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:!u.isUniform&&u.texData.isPacked,flatOffset:null};return null!=u.texData&&null!=u.texData.slice&&u.texData.slice.flatOffset>0&&(p.flatOffset=u.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:p}}),o=s.map(u=>u.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=W7(s,i,t),l=function v7(n,t){const e=Hl(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Pt(n,()=>n.shaderSource(e,t)),Pt(n,()=>n.compileShader(e)),(0,h.env)().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw ak(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(n.gl,a),c=n.createProgram(l);return(0,h.env)().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:o,outShapeInfo:i},gk(n,t,c)))}(this.gpgpu,e,d,p)),_=null!=this.activeTimers;let C;_&&(C=this.startTimer()),(0,h.env)().get("ENGINE_COMPILE_ONLY")||function Tq(n,t,e,r,s){t.program.enableShapeUniforms||(yk(t.inShapeInfos,e),yk([t.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):n.setOutputMatrixTexture(o.texture,i[0],i[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),1===(0,h.env)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<e.length;++l){const c=e[l],{uniform:u,offset:d,shape:p,texShape:m}=t.variablesLocations[l];if(p){const{uniformShape:y}=Yx(t.program.packedInputs,c.shape,c.texData.texShape);switch(y.length){case 1:n.gl.uniform1iv(p,new Int32Array(y));break;case 2:n.gl.uniform2iv(p,new Int32Array(y));break;case 3:n.gl.uniform3iv(p,new Int32Array(y));break;case 4:n.gl.uniform4iv(p,new Int32Array(y))}}if(m&&n.gl.uniform2i(m,c.texData.texShape[0],c.texData.texShape[1]),null!=u){if(c.isUniform){if(h.util.sizeFromShape(c.shape)<2)n.gl.uniform1f(u,c.uniformValues[0]);else{let y=c.uniformValues;y instanceof Float32Array||(y=new Float32Array(y)),n.gl.uniform1fv(u,y)}continue}null!=c.texData.slice&&null!=d&&n.gl.uniform1i(d,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,u,l)}}const a=t.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const l=h.util.computeStrides(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l))}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let l=0;l<t.program.customUniforms.length;++l){const c=t.program.customUniforms[l],u=t.customUniformLocations[l],d=s[l];if("float"===c.type)n.gl.uniform1fv(u,d);else if("vec2"===c.type)n.gl.uniform2fv(u,d);else if("vec3"===c.type)n.gl.uniform3fv(u,d);else if("vec4"===c.type)n.gl.uniform4fv(u,d);else if("int"===c.type)n.gl.uniform1iv(u,d);else if("ivec2"===c.type)n.gl.uniform2iv(u,d);else if("ivec3"===c.type)n.gl.uniform3iv(u,d);else{if("ivec4"!==c.type)throw Error(`uniform type ${c.type} is not supported yet.`);n.gl.uniform4iv(u,d)}}n.executeProgram()}(this.gpgpu,y,d,p,o),u.forEach(N=>this.disposeIntermediateTensorInfo(N)),_&&(C=this.endTimer(C),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(C)}));const D=(0,h.env)().get("WEBGL_FLUSH_THRESHOLD");if(D>0){const N=h.util.now();N-this.lastGlFlushTime>D&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=N)}if(!(0,h.env)().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&!1===i){const N=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),N}return l}compileAndRun(e,r,s,o,i=!1){return this.runWebGLProgram(e,r,s=s||r[0].dtype,o,i)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,h.env)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,h.tidy)(()=>{if(!(0,h.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=(0,h.env)().getBool("DEBUG");(0,h.env)().set("DEBUG",!1);const r=this.abs((0,h.scalar)(1e-8)).dataSync()[0];if((0,h.env)().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:s,dtype:o,values:i,texture:a,usage:l,isPacked:c}=r;if(null!=a)return;const u=null!=this.activeTimers;let d;u&&(d=h.util.now());let p=r.texShape;if(null==p&&(p=function O7(n,t=!1){let e=(0,h.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=(0,h.env)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&(0,h.env)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),t&&(e*=2,r*=2,1===(n=n.map((a,l)=>l>=n.length-2?h.util.nearestLargerEven(n[l]):n[l])).length&&(n=[2,n[0]])),2!==n.length&&(n=h.util.squeezeShape(n).newShape);let s=h.util.sizeFromShape(n),o=null;n.length<=1&&s<=e?o=[1,s]:2===n.length&&n[0]<=e&&n[1]<=e?o=n:3===n.length&&n[0]*n[1]<=e&&n[2]<=e?o=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=e&&n[1]*n[2]<=e?o=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e?o=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(o=[n[0],n[1]*n[2]*n[3]]);const i=null!=o&&Math.max(...o)>r&&Math.min(...o)<=(t?2:1)&&Math.min(...o)>0;if(null==o||i)if(t){const a=fh(n);let l=2,c=2;n.length&&([l,c]=mh(n)),s=a*(l/2)*(c/2),o=h.util.sizeToSquarishShape(s).map(u=>2*u)}else o=h.util.sizeToSquarishShape(s);return o}(s,c),r.texShape=p),null!=i){const m=Ry(s);let y,_=p[1],C=p[0];const D=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(c||!D)&&([_,C]=ph(p[0],p[1])),y=c?new Oq(m,D):new bk(m,D);const N=D?[C,_]:p,W=this.makeTensorInfo(N,o),j=this.texData.get(W.dataId);j.usage=D?Wr.PIXELS:Wr.UPLOAD,j.texShape=N,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(W.dataId),_,C,i);const Ee=this.runWebGLProgram(y,[W],o,[[C,_]],!0),Ne=this.texData.get(Ee.dataId);r.texShape=Ne.texShape,r.isPacked=Ne.isPacked,r.usage=Ne.usage,(0,h.env)().get("ENGINE_COMPILE_ONLY")?this.disposeData(Ee.dataId):(r.texture=Ne.texture,r.values=null,this.texData.delete(Ee.dataId)),this.disposeIntermediateTensorInfo(W),u&&(this.uploadWaitMs+=h.util.now()-d)}else{const m=this.acquireTexture(p,l,o,c);r.texture=m}}convertAndCacheOnCPU(e,r){const s=this.texData.get(e),{dtype:o}=s;return null!=r&&(s.values=function fZ(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<e.length;++r)e[r]=Math.round(n[r]);return e}throw new Error(`Unknown dtype ${t}`)}(r,o)),s.values}acquireTexture(e,r,s,o){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,o)}computeBytes(e,r){return e[0]*e[1]*h.util.bytesPerElement(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return(0,xa.Z)(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,s]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(s));return Promise.all(r)}for(const[,s]of Object.entries(e.binaryCache)){const o=new Promise(i=>{try{e.checkCompletion_(s),i(!0)}catch(a){throw a}});r.push(o)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return(0,xa.Z)(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield(0,h.nextFrame)(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(ak(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:r,customUniformLocations:s,infLoc:o,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:c}=gk(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=r,e.customUniformLocations=s,e.infLoc=o,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=l,e.outTexShapeLocation=c}}createTensorFromGPUData(e,r,s){e.channels=e.channels||"RGBA";const{texture:o,height:i,width:a,channels:l}=e,c=(0,h.engine)().backend;if(!c.gpgpu.gl.isTexture(o))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=c.writeTexture(o,r,s,i,a,l);return(0,h.engine)().makeTensorFromDataId(u,r,s,c)}}return n.nextDataId=0,n})();h.device_util.isBrowser()&&(0,h.registerBackend)("webgl",()=>new pZ,2);const eC="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class vh{constructor(t,e,r){this.variableNames=["A","B"],this.outputShape=h.backend_util.assertAndGetBroadcastShape(e,r),this.enableShapeUniforms=Xs(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const zu="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class Cf{constructor(t,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=h.backend_util.assertAndGetBroadcastShape(e,r);const o=this.outputShape.length;this.enableShapeUniforms=Xs(o);let i="";if(s)if(0===o||1===h.util.sizeFromShape(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${ur(o)} coords = getOutputCoords();\n        `,1===o)i+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=go("coords",o);i+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${l[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${l[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function qo(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const gZ={kernelName:h.Identity,backendName:"webgl",kernelFunc:qo};function Vc(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,o=e.makeTensorInfo(r.shape,"complex64"),i=e.texData.get(o.dataId),a=qo({inputs:{x:r},backend:e}),l=qo({inputs:{x:s},backend:e});return i.complexTensorInfos={real:a,imag:l},o}const yZ={kernelName:h.Complex,backendName:"webgl",kernelFunc:Vc},Rk="return (a < 0.) ? b * a : a;",Ok="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",_Z={kernelName:h.LeakyRelu,backendName:"webgl",kernelFunc:function bZ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:o}=r,i=e.makeTensorInfo([],"float32",h.util.createScalarValue(o,"float32")),a=(0,h.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Cf(Ok,s.shape,i.shape):new vh(Rk,s.shape,i.shape),l=e.runWebGLProgram(a,[s,i],"float32");return e.disposeIntermediateTensorInfo(i),l}},Fk="return (a < 0.) ? b * a : a;",Pk="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",xZ={kernelName:h.Prelu,backendName:"webgl",kernelFunc:function vZ(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t,o=(0,h.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Cf(Pk,r.shape,s.shape):new vh(Fk,r.shape,s.shape);return e.runWebGLProgram(o,[r,s],"float32")}},xh="if (isnan(x)) return x;";function Gn({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,l=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&null!=e){const d=a.texData.get(i.dataId),p=e(d.values,l);return a.makeTensorInfo(i.shape,l,p)}let u;return u=(0,h.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Bc(i.shape,t):new al(i.shape,n),a.runWebGLProgram(u,[i],l)}}function Rs({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:l,b:c}=i,u=a;if(r&&"complex64"===l.dtype){const y=u.texData.get(l.dataId),_=u.texData.get(c.dataId),[C,D]=[[y.complexTensorInfos.real,_.complexTensorInfos.real],[y.complexTensorInfos.imag,_.complexTensorInfos.imag]].map(W=>{const[j,te]=W,_e={dataId:j.dataId,dtype:j.dtype,shape:l.shape},Ee={dataId:te.dataId,dtype:te.dtype,shape:c.shape},Ne=new vh(n,l.shape,c.shape);return u.runWebGLProgram(Ne,[_e,Ee],(0,h.upcastType)(j.dtype,te.dtype))}),N=Vc({inputs:{real:C,imag:D},backend:u});return u.disposeIntermediateTensorInfo(C),u.disposeIntermediateTensorInfo(D),N}const d=o||(0,h.upcastType)(l.dtype,c.dtype);if(("string"===l.dtype||"string"===c.dtype||u.shouldExecuteOnCPU([l,c]))&&null!=s){const y=u.texData.get(l.dataId).values,_=u.texData.get(c.dataId).values,C="string"===l.dtype?h.backend_util.fromUint8ToStringArray(y):y,D="string"===l.dtype?h.backend_util.fromUint8ToStringArray(_):_,[N,W]=s(l.shape,c.shape,C,D,d),j=u.makeTensorInfo(W,d);return u.texData.get(j.dataId).values=N,j}let m;return m=(0,h.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new Cf(t,l.shape,c.shape,e):new vh(n,l.shape,c.shape),u.runWebGLProgram(m,[l,c],d)}}function wf(n,t=!1){if("linear"===n)return t?eZ:q9;if("relu"===n)return t?nZ:Y9;if("elu"===n)return t?tZ:Z9;if("relu6"===n)return t?rZ:Q9;if("prelu"===n)return t?Pk:Fk;if("leakyrelu"===n)return t?Ok:Rk;if("sigmoid"===n)return t?sZ:J9;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class $k{constructor(t,e,r,s=!1,o=!1,i=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Xs(this.outputShape.length);const d=Math.ceil((s?t[1]:t[2])/2),p=s?"i * 2, rc.y":"rc.y, i * 2",m=o?"rc.z, i * 2":"i * 2, rc.z",y=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],_=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let C="",D="";a&&(C=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,D="result = activation(result);");const N=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let W="rc.x",j="rc.x";t[0]<e[0]?W=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(j=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${C}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${W};\n        int batchB = ${j};\n        for (int i = 0; i < ${d}; i++) {\n          vec4 a = getMatrixA(batchA, ${p});\n          vec4 b = getMatrixB(batchB, ${m});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${y[0]} * ${_[0]});\n          result += (${y[1]} * ${_[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${N}\n\n        ${D}\n\n        setOutput(result);\n      }\n    `}}const Lk={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Bk{constructor(t,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=h.backend_util.assertAndGetBroadcastShape(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Vk="return a * b;";function tC(n){const{inputs:t,backend:e}=n,{a:r,b:s}=t,o=h.backend_util.upcastType(r.dtype,s.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),c=new Bk(Lk.REAL,r.shape,s.shape),u=new Bk(Lk.IMAG,r.shape,s.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],p=e.runWebGLProgram(c,d,"float32"),m=e.runWebGLProgram(u,d,"float32"),y=Vc({inputs:{real:p,imag:m},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),y}if(e.shouldExecuteOnCPU([r,s])){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),[c,u]=b9(r.shape,s.shape,a.values,l.values,o),d=e.makeTensorInfo(u,o);return e.texData.get(d.dataId).values=c,d}let i;return i=(0,h.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Cf(Vk,r.shape,s.shape):new vh(Vk,r.shape,s.shape),e.runWebGLProgram(i,[r,s],o)}const CZ={kernelName:h.Multiply,backendName:"webgl",kernelFunc:tC};function Ot(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:o}=r,i=e,a=h.util.sizeFromShape(s.shape),l=h.util.inferFromImplicitShape(o,a),c=h.util.sizeFromShape(l);h.util.assert(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=i.texData.get(s.dataId);return!u.isPacked||Fy(s.shape,l)||null!==u.texture&&Fy(u.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function wZ(n,t,e){const r=[fh(n.shape),...mh(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},o=[fh(t),...mh(t)],i=new Ik(o,r),c=e.runWebGLProgram(i,[s],n.dtype,[r],!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(s,l,i)}const SZ={kernelName:h.Reshape,backendName:"webgl",kernelFunc:Ot};class Uk{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=t;this.outputShape=[s,i];const a=4*Math.floor(r/4),l=r%4;let c="sumValue += dot(values, ones);";if(null!=e){const d=1/e;c=`sumValue += dot(values * ${h.util.isInt(d)?d.toPrecision(2):d}, ones);`}let u="";o%r>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}class EZ{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=t;this.outputShape=[s,i];let a="0.0",l="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",l="min"):"max"===e&&(a="-1.0 / 1e-20",l="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?c="sumValue":"prod"===e?c="prodValue":"all"===e?c="allValue":"any"===e&&(c="anyValue");const u=4*Math.floor(r/4),d=r%4;let p=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${l}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,m="vec4";"all"===e?(a="1.0",p="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",m="bvec4"):"any"===e&&(a="0.0",p="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",m="bvec4");let y="";o%r>0&&(y=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${y}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${m} values = ${m}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${p}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===d}) {\n          ${m} values = ${m}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${p}\n        } else if (${2===d}) {\n          ${m} values = ${m}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${p}\n        } else if (${3===d}) {\n          ${m} values = ${m}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${p}\n        }\n        setOutput(${c});\n      }\n    `}}function Hu(n,t,e,r){const s=function DZ(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],r=h.backend_util.computeOptimalWindowSize(e);t.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return t}(n.shape);let o=n;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:l,outSize:c}=s[i];let u,d;u="mean"===e?0===i?new Uk({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new Uk({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):new EZ({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},e),d=o,o=r.runWebGLProgram(u,[o],t),d.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(d)}return o}class TZ{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[e[i]];this.outputShape=r,this.rank=r.length;const s=ur(this.rank),o=function IZ(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<n.length;s++)r[n[s]]=e[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class AZ{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let u=0;u<r.length;u++)r[u]=t[e[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=ur(this.rank),o=Tk("rc",this.rank),i=new Array(this.rank);for(let u=0;u<e.length;u++)i[e[u]]=o[u];const a=`vec2(${i.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${l}) {\n        result[1] = ${c};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${c};\n        if(${l}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Uy(n,t,e){const r=(0,h.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new AZ(n.shape,t):new TZ(n.shape,t);return e.runWebGLProgram(r,[n],n.dtype)}function zy(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;return function NZ(n,t,e,r){const o=n.shape.length,i=h.util.parseAxisParam(t,n.shape);let a=i;const l=h.backend_util.getAxesPermutation(a,o),c=null!=l;let u=n;c&&(u=Uy(n,l,r),a=h.backend_util.getInnerMostAxes(a.length,o)),h.backend_util.assertAxesAreInnerMostDims("sum",a,o);const[d,p]=h.backend_util.computeOutAndReduceShapes(u.shape,a);let m=d;e&&(m=h.backend_util.expandShapeToKeepDim(d,i));const y=h.util.sizeFromShape(p),D=Ot({inputs:{x:u},attrs:{shape:[h.util.sizeFromShape(n.shape)/y,y]},backend:r}),W=Hu(D,(0,h.sumOutType)(n.dtype),"sum",r),j=Ot({inputs:{x:W},attrs:{shape:m},backend:r});return r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(W),c&&r.disposeIntermediateTensorInfo(u),j}(s,o,i,e)}const kZ={kernelName:h.Sum,backendName:"webgl",kernelFunc:zy};function yo(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{perm:o}=r,i=e,l=new Array(s.shape.length);for(let u=0;u<l.length;u++)l[u]=s.shape[o[u]];let c;if(i.shouldExecuteOnCPU([s])){const d=i.texData.get(s.dataId).values,p=Jx(d,s.shape,s.dtype,o,l);c=i.makeTensorInfo(l,s.dtype),i.texData.get(c.dataId).values=p}else c=Uy(s,o,i);return c}const MZ={kernelName:h.Transpose,backendName:"webgl",kernelFunc:yo},zk=1e3;function Hy({a:n,b:t,transposeA:e,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=t.shape.length,d=e?n.shape[c-2]:n.shape[c-1],p=r?t.shape[u-1]:t.shape[u-2],m=e?n.shape[c-1]:n.shape[c-2],y=r?t.shape[u-2]:t.shape[u-1],_=n.shape.slice(0,-2),C=t.shape.slice(0,-2),D=h.util.sizeFromShape(_),N=h.util.sizeFromShape(C),j=h.broadcast_util.assertAndGetBroadcastShape(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([m,y]);h.util.assert(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${r} must match.`);const te=e?[D,d,m]:[D,m,d],_e=r?[N,y,p]:[N,p,y],Ee=Ot({inputs:{x:n},backend:s,attrs:{shape:te}}),Ne=Ot({inputs:{x:t},backend:s,attrs:{shape:_e}}),je=[Ee,Ne],He=Math.max(D,N),it=e?Ee.shape[1]:Ee.shape[2],at=null!=o,tt=null!=i,lt="leakyrelu"===l,st=null!=l?wf(l,!0):null;let We;if((1===m||1===y)&&it>zk&&!1===(at||tt||lt||null!=st)){let Ye=Ee,pt=Ne;e&&(Ye=yo({inputs:{x:Ee},backend:s,attrs:{perm:[0,2,1]}}),je.push(Ye)),r&&(pt=yo({inputs:{x:Ne},backend:s,attrs:{perm:[0,2,1]}}),je.push(pt));const Et=1===y;let wt=Ye;1!==y&&(wt=Ot({inputs:{x:Ye},backend:s,attrs:{shape:[He,it,1]}}),je.push(wt));const vt=1===y?2:1;let kt=pt;Et&&(kt=Ot({inputs:{x:pt},backend:s,attrs:{shape:[He,1,it]}}),je.push(kt));const jt=tC({inputs:{a:wt,b:kt},backend:s});We=zy({inputs:{x:jt},backend:s,attrs:{axis:vt,keepDims:!0}}),je.push(jt)}else{const Ye=(0,h.upcastType)(n.dtype,t.dtype),pt=new $k(te,_e,[He,m,y],e,r,at,st,tt,lt),yt=[Ee,Ne];if(null!=o&&yt.push(o),tt&&yt.push(i),lt){const Et=s.makeTensorInfo([],"float32",h.util.createScalarValue(a,"float32"));yt.push(Et),je.push(Et)}We=s.runWebGLProgram(pt,yt,Ye)}const Ue=Ot({inputs:{x:We},backend:s,attrs:{shape:j}});je.push(We);for(const Ye of je)s.disposeIntermediateTensorInfo(Ye);return Ue}const OZ={kernelName:h._FusedMatMul,backendName:"webgl",kernelFunc:function RZ(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o,bias:i,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=r;return Hy({a:s,b:o,transposeA:l,transposeB:c,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:d,activation:u})}},Hk="return abs(x);",PZ={kernelName:h.Abs,backendName:"webgl",kernelFunc:function FZ(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const o=e.texData.get(r.dataId),i=Ek(o.values);return e.makeTensorInfo(r.shape,r.dtype,i)}let s;return s=(0,h.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Bc(r.shape,Hk):new al(r.shape,Hk),e.runWebGLProgram(s,[r],r.dtype)}},LZ=Gn({opSnippet:_i+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),BZ={kernelName:h.Acos,backendName:"webgl",kernelFunc:LZ},UZ=Gn({opSnippet:_i+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),zZ={kernelName:h.Acosh,backendName:"webgl",kernelFunc:UZ},Wk="return a + b;",HZ=Rs({opSnippet:Wk,packedOpSnippet:Wk,supportsComplex:!0,cpuKernelImpl:Qq}),WZ={kernelName:h.Add,backendName:"webgl",kernelFunc:HZ};class jZ{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class GZ{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const KZ={kernelName:h.AddN,backendName:"webgl",kernelFunc:function Wy(n){const{inputs:t,backend:e}=n,r=t;if(1===r.length)return qo({inputs:{x:r[0]},backend:e});if(r.length>(0,h.env)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=Wy({inputs:r.slice(0,l),backend:e}),u=Wy({inputs:r.slice(l),backend:e});return Wy({inputs:[c,u],backend:e})}const s=r.map(l=>l.dtype).reduce((l,c)=>(0,h.upcastType)(l,c)),o=r.map(l=>l.shape),a=(0,h.env)().getBool("WEBGL_PACK")?new GZ(r[0].shape,o):new jZ(r[0].shape,o);return e.runWebGLProgram(a,r,s)}},qZ={kernelName:h.All,backendName:"webgl",kernelFunc:function XZ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,l=h.util.parseAxisParam(o,s.shape);let c=l;const u=h.backend_util.getAxesPermutation(c,a);let d=s;null!=u&&(d=yo({inputs:{x:s},backend:e,attrs:{perm:u}}),c=h.backend_util.getInnerMostAxes(c.length,a)),h.backend_util.assertAxesAreInnerMostDims("all",c,a);const[p,m]=h.backend_util.computeOutAndReduceShapes(d.shape,c),_=Ot({inputs:{x:d},backend:e,attrs:{shape:[-1,h.util.sizeFromShape(m)]}}),C=Hu(_,_.dtype,"all",e);let D;return D=Ot(i?{inputs:{x:C},backend:e,attrs:{shape:h.backend_util.expandShapeToKeepDim(p,l)}}:{inputs:{x:C},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(C),null!=u&&e.disposeIntermediateTensorInfo(d),D}},YZ={kernelName:h.Any,backendName:"webgl",kernelFunc:function ZZ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,l=h.util.parseAxisParam(o,s.shape);let c=l;const u=h.backend_util.getAxesPermutation(c,a);let d=s;null!=u&&(d=yo({inputs:{x:s},backend:e,attrs:{perm:u}}),c=h.backend_util.getInnerMostAxes(c.length,a)),h.backend_util.assertAxesAreInnerMostDims("any",c,a);const[p,m]=h.backend_util.computeOutAndReduceShapes(d.shape,c),_=Ot({inputs:{x:d},backend:e,attrs:{shape:[-1,h.util.sizeFromShape(m)]}}),C=Hu(_,_.dtype,"any",e);let D;return D=Ot(i?{inputs:{x:C},backend:e,attrs:{shape:h.backend_util.expandShapeToKeepDim(p,l)}}:{inputs:{x:C},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(C),null!=u&&e.disposeIntermediateTensorInfo(d),D}};class QZ{constructor(t,e,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class JZ{constructor(t,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,h.util.assert(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=ur(l),u=go("coords",l);let d,p;if(1===i){p=l+1;const Ne=ur(p);d=`\n        ${Ne} sourceLocR = ${Ne}(${u.join()}, 0);\n        ++${u[l-1]};\n        ${Ne} sourceLocG = ${Ne}(${u.join()}, 0);\n        ++${u[l-2]};\n        ${Ne} sourceLocA = ${Ne}(${u.join()}, 0);\n        --${u[l-1]};\n        ${Ne} sourceLocB = ${Ne}(${u.join()}, 0);\n        --${u[l-2]};`}else p=l,d=`\n        ${c} sourceLocR = coords;\n        ++${u[l-1]};\n        ${c} sourceLocG = coords;\n        ++${u[l-2]};\n        ${c} sourceLocA = coords;\n        --${u[l-1]};\n        ${c} sourceLocB = coords;\n        --${u[l-2]};`;const m=["x","y","z","w","u","v"].slice(0,p),y="."+m[p-1],_=m.map(Ne=>"int "+Ne),C=go("sourceLocR",p-1).concat("inIdx.r"),D=go("sourceLocG",p-1).concat("inIdx.g"),N=go("sourceLocB",p-1).concat("inIdx.b"),W=go("sourceLocA",p-1).concat("inIdx.a"),j="max"===r?"greaterThan":"lessThan",te=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${C.join()}),\n                             getBestIndicesAChannel(${D.join()}),\n                             getBestIndicesAChannel(${N.join()}),\n                             getBestIndicesAChannel(${W.join()})));`,_e=`vec4(\n            getAChannel(${C.join()}),\n            hasNextCol ? getAChannel(${D.join()}) : 0.,\n            hasNextRow ? getAChannel(${N.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${W.join()}) : 0.)`,Ee=s?"":`\n      float getBestIndicesAChannel(${_.join()}) {\n        return getChannel(getBestIndicesA(${m.join()}),\n                                          vec2(${m.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${_.join()}) {\n        return getChannel(getA(${m.join()}),\n                               vec2(${m.slice(-2).join()}));\n      }\n      ${Ee}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};\n        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${y}, sourceLocG${y},\n          sourceLocB${y}, sourceLocA${y}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${_e};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${te}\n          vec4 candidate = ${_e};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${j}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function jk(n,t,e,r=null){let s=t.shape[0],o=t.shape[1];null!=r&&(s=r.shape[0],o=r.shape[1]);const i=h.backend_util.computeOptimalWindowSize(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},l=new QZ(a,e,null==r),c=[t];null!=r&&c.push(r);const u=n.runWebGLProgram(l,c,"int32");if(1===u.shape[1])return u;const d=jk(n,t,e,u);return n.disposeIntermediateTensorInfo(u),d}function Gk(n,t,e,r=null){const s=null!=r?r.shape:t.shape,i=h.backend_util.computeOptimalWindowSize(s[s.length-1]),a=new JZ(s,i,e,null==r),c=n.runWebGLProgram(a,null==r?[t]:[t,r],"int32");if(c.shape.length===t.shape.length){const u=Gk(n,t,e,c);return n.disposeIntermediateTensorInfo(c),u}return c}function Kk(n,t,e,r){const s=[e];if(h.backend_util.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!(0,h.env)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const o=[],i=n.texData.get(t.dataId);let l=t;null!==i&&i.isPacked&&(l=n.unpackTensor(t),o.push(l));const[c,u]=h.backend_util.computeOutAndReduceShapes(l.shape,s),d=h.util.sizeFromShape(u),p=Ot({inputs:{x:l},backend:n,attrs:{shape:[-1,d]}});o.push(p);const m=jk(n,p,r);o.push(m);const y=Ot({inputs:{x:m},backend:n,attrs:{shape:c}});return o.forEach(_=>n.disposeIntermediateTensorInfo(_)),y}return Gk(n,t,r)}const tY={kernelName:h.ArgMax,backendName:"webgl",kernelFunc:function eY(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;let i=h.util.parseAxisParam(o,s.shape);const a=h.backend_util.getAxesPermutation(i,s.shape.length);let l=s;const c=[];null!=a&&(l=yo({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),i=h.backend_util.getInnerMostAxes(i.length,l.shape.length)),h.backend_util.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);const u=Kk(e,l,i[0],"max");return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),u}},rY={kernelName:h.ArgMin,backendName:"webgl",kernelFunc:function nY(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;let i=h.util.parseAxisParam(o,s.shape);const a=h.backend_util.getAxesPermutation(i,s.shape.length);let l=s;const c=[];null!=a&&(l=yo({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),i=h.backend_util.getInnerMostAxes(i.length,l.shape.length)),h.backend_util.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);const u=Kk(e,l,i[0],"min");return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),u}},oY=Gn({opSnippet:_i+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),iY={kernelName:h.Asin,backendName:"webgl",kernelFunc:oY},lY=Gn({opSnippet:_i+"return log(x + sqrt(x * x + 1.0));"}),cY={kernelName:h.Asinh,backendName:"webgl",kernelFunc:lY},dY=Gn({opSnippet:_i+"\n  return atan(x);\n"}),hY={kernelName:h.Atan,backendName:"webgl",kernelFunc:dY},mY=Rs({opSnippet:eC+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+zu+"\n  return result;\n"}),gY={kernelName:h.Atan2,backendName:"webgl",kernelFunc:mY},bY=Gn({opSnippet:_i+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),_Y={kernelName:h.Atanh,backendName:"webgl",kernelFunc:bY};class Sf{constructor(t,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,a=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,u=t.dilationWidth,d=t.effectiveFilterHeight,p=t.effectiveFilterWidth,m=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;const _="avg"===e;let N="0.0";if(_||(N="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${l});\n        const ivec2 pads = ivec2(${m}, ${y});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?o?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${p} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let j=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(j="avgValue / max(count, 1.0)");const te=4*Math.floor(i/4),_e=i%4,Ee=`\n      if (${_}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${m}, ${y});\n      const float initializationValue = ${N};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${N});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${te}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${Ee}\n          }\n\n          int xC = xCCorner + ${te};\n          if (${1===_e}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${Ee}\n          } else if (${2===_e}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${Ee}\n          } else if (${3===_e}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${Ee}\n          }\n        }\n        setOutput(${j});\n      }\n    `}}class nC{constructor(t,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,a=t.strideDepth,l=t.strideHeight,c=t.strideWidth,u=t.dilationDepth,d=t.dilationHeight,p=t.dilationWidth,m=t.effectiveFilterDepth,y=t.effectiveFilterHeight,_=t.effectiveFilterWidth,C=t.padInfo.front,D=t.padInfo.top,N=t.padInfo.left;this.outputShape=t.outShape;const W="avg"===e;let j="0.0";if(W||(j="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${l}, ${c});\n        const ivec3 pads = ivec3(${C}, ${D}, ${N});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${m};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${y};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${_};\n                  wC += ${p}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?o?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${y} * ${_} +\n                      wR * ${_} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let _e=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(_e="avgValue / max(count, 1.0)");const Ee=4*Math.floor(i/4),Ne=i%4,je=`\n      if (${W}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${l}, ${c});\n      const ivec3 pads = ivec3(${C}, ${D}, ${N});\n      const float initializationValue = ${j};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${j});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${m};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${y};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${Ee}; wC += 4) {\n              int xC = xCCorner + wC * ${p};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${p}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${p}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${p}, ch)\n              );\n\n              ${je}\n            }\n\n            int xC = xCCorner + ${Ee};\n            if (${1===Ne}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${je}\n            } else if (${2===Ne}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${p}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${je}\n            } else if (${3===Ne}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${p}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${p}, ch),\n                initializationValue\n              );\n\n              ${je}\n            }\n          }\n        }\n        setOutput(${_e});\n      }\n    `}}const xY={kernelName:h.AvgPool,backendName:"webgl",kernelFunc:function vY(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;vf(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;h.util.assert(h.backend_util.eitherStridesOrDilationsAreOne(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const u=h.backend_util.computePool2DInfo(s.shape,o,i,1,a,l);if(1===u.filterWidth&&1===u.filterHeight&&h.util.arraysEqual(u.inShape,u.outShape))return qo({inputs:{x:s},backend:e});const d=new Sf(u,"avg",!1);return e.runWebGLProgram(d,[s],"float32")}},wY={kernelName:h.AvgPool3D,backendName:"webgl",kernelFunc:function CY(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:c}=r,d=h.backend_util.computePool3DInfo(s.shape,o,i,[1,1,1],a,l,c),p=new nC(d,"avg",!1);return e.runWebGLProgram(p,[s],"float32")}};class SY{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const l=t.effectiveFilterHeight,c=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-t.padInfo.top}, ${c-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class EY{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-t.padInfo.front}, ${p-1-t.padInfo.top}, ${m-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${p};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${m};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const TY={kernelName:h.AvgPool3DGrad,backendName:"webgl",kernelFunc:function DY(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,i=o,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,p=h.backend_util.computePool3DInfo(i.shape,a,l,[1,1,1],c,u),m=new EY(p);return e.runWebGLProgram(m,[s],i.dtype)}},AY={kernelName:h.AvgPoolGrad,backendName:"webgl",kernelFunc:function IY(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,i=o;vf([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=h.backend_util.computePool2DInfo(i.shape,a,l,1,c),d=new SY(u);return e.runWebGLProgram(d,[s],i.dtype)}},kY={kernelName:h.BatchMatMul,backendName:"webgl",kernelFunc:function NY(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o}=t,{transposeA:i,transposeB:a}=r;return Hy({a:s,b:o,transposeA:i,transposeB:a,backend:e})}};class MY{constructor(t,e,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],h.backend_util.assertAndGetBroadcastShape(t,e),h.backend_util.assertAndGetBroadcastShape(t,r);let a="0.0";null!=s&&(h.backend_util.assertAndGetBroadcastShape(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";null!=o&&(h.backend_util.assertAndGetBroadcastShape(t,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class RY{constructor(t,e,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],h.backend_util.assertAndGetBroadcastShape(t,e),h.backend_util.assertAndGetBroadcastShape(t,r);let a="vec4(0.0)";null!=s&&(h.backend_util.assertAndGetBroadcastShape(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=o&&(h.backend_util.assertAndGetBroadcastShape(t,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const FY={kernelName:h.FusedBatchNorm,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=n;h.util.assert(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),h.util.assert(null==i||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),h.util.assert(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const c=[r,s,o];let u=null;null!=i&&(u=i.shape,c.push(i));let d=null;null!=a&&(d=a.shape,c.push(a));const p=(0,h.env)().getBool("WEBGL_PACK_NORMALIZATION")?new RY(r.shape,s.shape,o.shape,u,d,l):new MY(r.shape,s.shape,o.shape,u,d,l);return t.runWebGLProgram(p,c,c[0].dtype)}};class PY{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=ur(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function $Y(n){if(1===n)return"sourceLoc";if(n<=6)return rC.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((i,a)=>`sourceLoc.${rC[a]} = start[${a}] + coords.${rC[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}}const rC=["x","y","z","w","u","v"];class LY{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=ur(this.rank),r=go("coords",this.rank),s=go("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`\n      result.x = ${i};\n      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${i};\n        --${s[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${i};\n        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,c=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((u,d)=>`start[${d}]`).join()});`:t.map((u,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${c}\n        vec4 result = vec4(0.);\n        ${a}\n        ${l}\n        setOutput(result);\n      }\n    `}}function Ch(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,size:i}=r,[a,l]=h.slice_util.parseSliceParams(s,o,i);if(h.slice_util.assertParamsValid(s,a,l),0===h.util.sizeFromShape(l))return e.makeTensorInfo(l,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||"string"===s.dtype){const d=e.texData.get(s.dataId),p=A9(d.values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,p)}const{isPacked:c}=e.texData.get(s.dataId),u=h.slice_util.isSliceContinous(s.shape,a,l);if(c||!u){const d=(0,h.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new LY(l):new PY(l);return e.runWebGLProgram(d,[s],s.dtype,[a])}return e.uploadToGPU(s.dataId),function BY(n,t,e,r){const s=r.texData.get(n.dataId),o=r.makeTensorInfo(e,n.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=e,i.dtype=n.dtype;let a=h.slice_util.computeFlatOffset(t,h.util.computeStrides(n.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||n.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),o}(s,a,l,e)}const VY={kernelName:h.Slice,backendName:"webgl",kernelFunc:Ch},zY={kernelName:h.BatchToSpaceND,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,crops:i}=r;h.util.assert(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((N,W)=>N*W),l=h.backend_util.getReshaped(s.shape,o,a),c=h.backend_util.getPermuted(l.length,o.length),u=h.backend_util.getReshapedPermuted(s.shape,o,a),d=h.backend_util.getSliceBeginCoords(i,o.length),p=h.backend_util.getSliceSize(u,i,o.length),m=[],y=Ot({inputs:{x:s},backend:e,attrs:{shape:l}}),_=yo({inputs:{x:y},backend:e,attrs:{perm:c}}),C=Ot({inputs:{x:_},backend:e,attrs:{shape:u}}),D=Ch({inputs:{x:C},backend:e,attrs:{begin:d,size:p}});return m.push(y),m.push(_),m.push(C),m.forEach(N=>e.disposeIntermediateTensorInfo(N)),D}},WY={kernelName:h.Bincount,backendName:"webgl",kernelFunc:function HY(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:i}=r,a=e.readSync(s.dataId),l=e.readSync(o.dataId),c=Sk(a,l,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}},GY={kernelName:h.BroadcastArgs,backendName:"webgl",kernelFunc:function jY(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,o=e.readSync(r.dataId),i=e.readSync(s.dataId),a=h.backend_util.assertAndGetBroadcastShape(Array.from(o),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},Xk=Rs({opSnippet:"return float(a != b);",cpuKernelImpl:v9,dtype:"bool"}),KY={kernelName:h.NotEqual,backendName:"webgl",kernelFunc:Xk};function Ef(n){const{inputs:t,backend:e}=n,{input:r}=t;return qo({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const XY={kernelName:h.Real,backendName:"webgl",kernelFunc:Ef},YY={kernelName:h.Cast,backendName:"webgl",kernelFunc:function sC(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return qo({inputs:{x:s},backend:e});const i=h.zeros(s.shape),a=sC({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),l=Vc({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const i=Ef({inputs:{input:s},backend:e}),a=sC({inputs:{x:i},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(i),a}if(!h.util.hasEncodingLoss(s.dtype,o)){const i=qo({inputs:{x:s},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(e.shouldExecuteOnCPU([s])){const i=e.texData.get(s.dataId).values,[a,l,c]=e9(i,s.shape,s.dtype,o);return e.makeTensorInfo(a,l,c)}if("int32"===o)return function ZY(n,t){const e=new al(n.shape,"return float(int(x));"),r=t.runWebGLProgram(e,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,e);if("bool"===o){const i=e.makeTensorInfo([],"bool",h.util.getTypedArrayFromDType("bool",1)),l=Xk({inputs:{a:s,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},qk="return ceil(x);",QY=Gn({opSnippet:qk,packedOpSnippet:qk,cpuKernelImpl:t9}),JY={kernelName:h.Ceil,backendName:"webgl",kernelFunc:QY};class eQ{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class tQ{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const rQ={kernelName:h.ClipByValue,backendName:"webgl",kernelFunc:function nQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{clipValueMin:o,clipValueMax:i}=r;let a;return a=(0,h.env)().getBool("WEBGL_PACK_CLIP")?new tQ(s.shape):new eQ(s.shape),e.runWebGLProgram(a,[s],s.dtype,[[o],[i]])}};class sQ{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Zk(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const iQ={kernelName:h.ComplexAbs,backendName:"webgl",kernelFunc:function oQ(n){const{inputs:t,backend:e}=n,{x:r}=t,s=e.texData.get(r.dataId),o=new sQ(r.shape),i=[Zk(r,s.complexTensorInfos.real),Zk(r,s.complexTensorInfos.imag)];return e.runWebGLProgram(o,i,i[0].dtype)}};class aQ{constructor(t){this.outputShape=[],this.outputShape=h.backend_util.computeOutShape(t,1),this.variableNames=t.map((i,a)=>`T${a}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+t[i][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++)r.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${e[i-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class lQ{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=h.backend_util.computeOutShape(t,e);const r=this.outputShape,s=r.length,o=ur(s),i=go("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((_,C)=>`T${C}`);const l=new Array(t.length-1);l[0]=t[0][e];for(let _=1;_<l.length;_++)l[_]=l[_-1]+t[_][e];const c=a[e],u=a.slice(-2),d=a.join();let p=`if (${c} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${u.join()}));\n        }`;for(let _=1;_<l.length;_++){const C=l[_-1];p+=`\n        if (${c} < ${l[_]}  && ${c} >= ${l[_-1]}) {\n          return getChannel(\n            getT${_}(${jy(a,c,C)}),\n            vec2(${jy(u,c,C)}));\n        }`}const y=l[l.length-1];p+=`\n        return getChannel(\n          getT${l.length}(${jy(a,c,y)}),\n          vec2(${jy(u,c,y)}));`,this.userCode=`\n      float getValue(${a.map(_=>"int "+_)}) {\n        ${p}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[s-1]} = ${i[s-1]} + 1;\n        if (${i[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[s-2]} = ${i[s-2]} + 1;\n        if (${i[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[s-1]} = ${i[s-1]} - 1;\n        if (${i[s-2]} < ${r[s-2]} &&\n            ${i[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function jy(n,t,e){const r=n.indexOf(t);return n.map((o,i)=>i===r?`${o} - ${e}`:o).join()}function Gy(n){const{inputs:t,backend:e}=n,{input:r}=t;return qo({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const cQ={kernelName:h.Imag,backendName:"webgl",kernelFunc:Gy};function Df(n,t,e){const r=n[0].dtype;if("complex64"===r){const m=n.map(N=>Ef({inputs:{input:N},backend:e})),y=n.map(N=>Gy({inputs:{input:N},backend:e})),_=Df(m,t,e),C=Df(y,t,e),D=Vc({inputs:{real:_,imag:C},backend:e});return m.forEach(N=>e.disposeIntermediateTensorInfo(N)),y.forEach(N=>e.disposeIntermediateTensorInfo(N)),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(C),D}let s=e.shouldExecuteOnCPU(n);if("string"===r&&(s=!0),s){const m=n.map(j=>{const _e=[-1,h.util.sizeFromShape(j.shape.slice(t))];return Ot({inputs:{x:j},backend:e,attrs:{shape:_e}})}),y=m.map(j=>({vals:e.readSync(j.dataId),shape:j.shape})),_=h.backend_util.computeOutShape(m.map(j=>j.shape),1),D=n9(y,_,r,1===m[0].shape[0]),N=h.backend_util.computeOutShape(n.map(j=>j.shape),t),W=e.makeTensorInfo(N,r,D);return m.forEach(j=>e.disposeIntermediateTensorInfo(j)),W}const o=n.filter(m=>h.util.sizeFromShape(m.shape)>0),i=(0,h.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const m=i?new al(n[0].shape,Lc):new Bc(n[0].shape,Lc);return e.runWebGLProgram(m,n,r)}const a=(0,h.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const m=[];for(let _=0;_<o.length;_+=a){const C=o.slice(_,_+a);m.push(Df(C,t,e))}const y=Df(m,t,e);for(const _ of m)e.disposeIntermediateTensorInfo(_);return y}if(i){const m=new lQ(o.map(y=>y.shape),t);return e.runWebGLProgram(m,o,r)}const{tensors2D:l,outShape:c}=function uQ(n,t,e){const r=h.backend_util.computeOutShape(n.map(o=>o.shape),t);return{tensors2D:n.map(o=>Ot({inputs:{x:o},attrs:{shape:[-1,h.util.sizeFromShape(o.shape.slice(t))]},backend:e})),outShape:r}}(o,t,e),u=new aQ(l.map(m=>m.shape)),d=e.runWebGLProgram(u,l,r);l.forEach(m=>e.disposeIntermediateTensorInfo(m));const p=Ot({inputs:{x:d},attrs:{shape:c},backend:e});return e.disposeIntermediateTensorInfo(d),p}function Yk(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,o=h.util.parseAxisParam(s,t[0].shape)[0],i=t.map(c=>c.shape);h.backend_util.assertParamsConsistent(i,o);const a=h.backend_util.computeOutShape(t.map(c=>c.shape),o);if(0===h.util.sizeFromShape(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(c=>h.util.sizeFromShape(c.shape)>0);return 1===l.length?qo({inputs:{x:l[0]},backend:e}):Df(l,o,e)}const dQ={kernelName:h.Concat,backendName:"webgl",kernelFunc:Yk};class Qk{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,c=t.strideWidth,u=t.dilationHeight,d=t.dilationWidth,p=t.filterHeight,m=t.filterWidth,y=4*Math.floor(t.inChannels/4),_=t.inChannels%4,C="channelsLast"===t.dataFormat,D=C?1:2,N=C?2:3,W=C?3:1;let j="",te="";r&&(j=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,te="result = activation(result);");const _e=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${j}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${W}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${D}], coords[${N}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${m}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${y}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${C}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===_}) {\n\n              if (${C}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${y}) *\n                    getW(wR, wC, ${y}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${y}, xR, xC) *\n                    getW(wR, wC, ${y}, d2);\n              }\n\n            } else if (${2===_}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${y}, d2),\n                getW(wR, wC, ${y} + 1, d2)\n              );\n\n              if (${C}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${y}),\n                  getX(batch, xR, xC, ${y} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${y}, xR, xC),\n                  getX(batch, ${y} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===_}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${y}, d2),\n                getW(wR, wC, ${y} + 1, d2),\n                getW(wR, wC, ${y} + 2, d2)\n              );\n\n              if (${C}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${y}),\n                  getX(batch, xR, xC, ${y} + 1),\n                  getX(batch, xR, xC, ${y} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${y}, xR, xC),\n                  getX(batch, ${y} + 1, xR, xC),\n                  getX(batch, ${y} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${_e}\n        ${te}\n        setOutput(result);\n      }\n    `}}class hQ{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,o=t.strideDepth,i=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,u=t.dilationWidth,d=t.filterDepth,p=t.filterHeight,m=t.filterWidth,y=4*Math.floor(t.inChannels/4),_=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${i}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p}; wR++) {\n            int xR = xRCorner + wR * ${c};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${m}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${y}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===_}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${y}) *\n                  getW(wF, wR, wC, ${y}, d2);\n              } else if (${2===_}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${y}),\n                  getX(batch, xF, xR, xC, ${y} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${y}, d2),\n                  getW(wF, wR, wC, ${y} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===_}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${y}),\n                  getX(batch, xF, xR, xC, ${y} + 1),\n                  getX(batch, xF, xR, xC, ${y} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${y}, d2),\n                  getW(wF, wR, wC, ${y} + 1, d2),\n                  getW(wF, wR, wC, ${y} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Jk{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Xs(this.outputShape.length);const i=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,u=t.filterWidth,d=u;let p="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let C=0;C<u;C++)p+=`\n           vec4 xTexelC${2*C};\n           int xTexelC${2*C}Ready;\n           vec4 xTexelC${2*C+1};\n           int xTexelC${2*C+1}Ready;\n           vec4 xC${C};`;p+=`\n     for (int r = 0; r < ${c}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let C=0;C<u;C++)p+=`\n           xTexelC${2*C} = vec4(0.0);\n           xTexelC${2*C}Ready = 0;\n           xTexelC${2*C+1} = vec4(0.0);\n           xTexelC${2*C+1}Ready = 0;\n           xC${C} = vec4(0.0);`;p+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let C=0;C<(d+1)/2;C++){const D=2*C;if(p+=`\n           xC = xCCorner + ${D*l};\n           `,1===a){if(D<u&&(i%2==1?(p+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${D}Ready == 0) {\n                   xTexelC${D} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${D}.zw = vec2(0.0);\n                   }\n                   xTexelC${D}Ready = 1;\n                 }\n               `,p+=1===l&&D>0?`\n                 xC${D} = vec4(xTexelC${D-2}.zw, xTexelC${D}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${D} = vec4(previous.zw, xTexelC${D}.xy);\n                   } else {\n                     xC${D} = vec4(0.0, 0.0, xTexelC${D}.xy);\n                   }\n                   `):p+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${D}Ready == 0) {\n                   xTexelC${D} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${D}.zw = vec2(0.0);\n                   }\n                   xTexelC${D}Ready = 1;\n                 }\n\n                 xC${D} = xTexelC${D};\n                 `,D+1<u)){const N=i%2==0?h.util.nearestLargerEven(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(p+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${N};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${D+1}Ready == 0) {\n                     xTexelC${D+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${D+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${D+1}Ready = 1;\n                   }\n                   `,p+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${D+1} = vec4(previous.zw, xTexelC${D+1}.xy);\n                     } else {\n                      xC${D+1} = vec4(0.0, 0.0, xTexelC${D+1}.xy);\n                     }\n                     `:`\n                     xC${D+1} = vec4(xTexelC${D}.zw, xTexelC${D+1}.xy);\n                     `):p+=1===N?`\n                     xC${D+1} = xTexelC${D};\n                     `:`\n                     xCOffset = xC + ${N};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${D+1}Ready == 0) {\n                       xTexelC${D+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${D+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${D+1}Ready = 1;\n                     }\n\n                     xC${D+1} = xTexelC${D+1};\n                     `}}else D<u&&(i%2==1?(p+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${D}Ready == 0) {\n                   xTexelC${D} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${D}.zw = vec2(0.0);\n                   }\n                   xTexelC${D}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${D+1}Ready == 0) {\n                   xTexelC${D+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${D+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${D+1}Ready = 1;\n                 }\n\n                 xC${D} = vec4(xTexelC${D}.zw, xTexelC${D+1}.zw);\n               `,D+1<u&&(p+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${D+1} = vec4(xTexelC${D+1}.xy, final.xy);\n                 `)):(p+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${D}Ready == 0) {\n                   xTexelC${D} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${D}.zw = vec2(0.0);\n                   }\n                   xTexelC${D}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${D+1}Ready == 0) {\n                   xTexelC${D+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${D+1}.zw = vec2(0.);\n                   }\n                   xTexelC${D+1}Ready = 1;\n                 }\n\n                 xC${D} = vec4(\n                   xTexelC${D}.xy, xTexelC${D+1}.xy);\n               `,D+1<u&&(p+=`\n                   xC${D+1} = vec4(xTexelC${D}.zw, xTexelC${D+1}.zw);\n                 `)));D<u&&(p+=`\n             wTexel = getW(r, ${D}, d1, d2);\n             dotProd += xC${D}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${D}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,D+1<u&&(p+=`\n               wTexel = getW(r, ${D+1}, d1, d2);\n               dotProd += xC${D+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${D+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}p+="\n     }\n   ",p+="\n     }\n   ",p+="\n     }\n   ";let m="",y="";r&&(m=s?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:o?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,y="result = activation(result);");const _=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${m}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${p}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${_}\n         ${y}\n         setOutput(result);\n       }\n     `}}class pQ{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Xs(this.outputShape.length);const{dataFormat:r}=e,s=mo(),o="channelsLast"===r,i=o?1:2,a=o?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let c="";for(let u=0;u<=1;u++)for(let d=0;d<=1;d++)c+=`\n          blockIndex = rc.z + ${d};\n          pos = rc.y + ${u};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${o}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+d}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+d}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${c}\n\n        ${s.output} = result;\n      }\n    `}}function Ky(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&1===e&&n[0]>1?[n[0],1]:null}function eM({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=n.shape,c=r.texData.get(n.dataId),u=e.inChannels,d=l[0]*l[1]*l[2],p=e.outChannels,m="channelsLast"===e.dataFormat;let C;const D=[];if(null!=o){const j=Ky(o.shape,m);null!=j&&(o=Ot({inputs:{x:o},backend:r,attrs:{shape:j}}),D.push(o))}if(null!=s){const j=Ky(s.shape,m);null!=j&&(s=Ot({inputs:{x:s},backend:r,attrs:{shape:j}}),D.push(s))}if((1!==d&&1!==p||!(u>zk))&&c.isPacked&&m&&null!=c.texture&&l[2]%2!=0&&h.util.arraysEqual(c.shape.slice(-3),l.slice(-3))){const te={dataId:n.dataId,shape:[1,l[0]*l[1]*(l[2]+1),e.inChannels],dtype:n.dtype},_e=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,h.util.assert(Fy(c.shape,te.shape),()=>`packed reshape ${c.shape} to ${te.shape} isn't free`);const Ee=Ot({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});D.push(Ee);const Ne=Hy({a:te,b:Ee,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),je=r.texData.get(Ne.dataId);h.util.assert(je.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=_e,je.shape=e.outShape,C=qo({inputs:{x:Ne},backend:r}),C.shape=e.outShape,D.push(Ne)}else{const j=e.outHeight*e.outWidth,te=Ot({inputs:{x:n},backend:r,attrs:{shape:m?[e.batchSize,j,e.inChannels]:[e.batchSize,e.inChannels,j]}}),_e=Ot({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),Ee=Hy({a:m?te:_e,b:m?_e:te,transposeA:!m,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});C=Ot({inputs:{x:Ee},backend:r,attrs:{shape:e.outShape}}),D.push(te),D.push(_e),D.push(Ee)}for(const j of D)r.disposeIntermediateTensorInfo(j);return C}function tM({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:d,outHeight:p,dataFormat:m}=e,y="channelsLast"===m,_=l*c*u,C=p*d,D=[e.batchSize,_,C],j=[];if(null!=o){const Ue=Ky(o.shape,y);null!=Ue&&(o=Ot({inputs:{x:o},backend:r,attrs:{shape:Ue}}),j.push(o))}if(null!=s){const Ue=Ky(s.shape,y);null!=Ue&&(s=Ot({inputs:{x:s},backend:r,attrs:{shape:Ue}}),j.push(s))}const te=Ot({inputs:{x:t},backend:r,attrs:{shape:[1,_,h.util.sizeFromShape(t.shape)/_]}});j.push(te);const _e=new pQ(D,e),Ne=r.runWebGLProgram(_e,[n],"float32",[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),je=Ot({inputs:{x:Ne},backend:r,attrs:{shape:D}});j.push(Ne),j.push(je);const He=null!=s,it=null!=o,at="leakyrelu"===a,tt=a?wf(a,!0):null,lt=new $k(y?je.shape:te.shape,y?te.shape:je.shape,y?[e.batchSize,C,e.outChannels]:[e.batchSize,e.outChannels,C],!0,!1,He,tt,it,at),st=y?[je,te]:[te,je];if(s&&st.push(s),it&&st.push(o),at){const Ue=r.makeTensorInfo([],"float32",h.util.createScalarValue(i,"float32"));st.push(Ue),j.push(Ue)}const Pe=r.runWebGLProgram(lt,st,"float32"),We=Ot({inputs:{x:Pe},backend:r,attrs:{shape:e.outShape}});j.push(Pe);for(const Ue of j)r.disposeIntermediateTensorInfo(Ue);return We}const mQ={kernelName:h.Conv2D,backendName:"webgl",kernelFunc:function fQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,d=h.backend_util.convertConv2DDataFormat(l),p=h.backend_util.computeConv2DInfo(s.shape,o.shape,i,c,a,u,!1,d);let m;if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(p.strideWidth<=2&&"channelsLast"===d&&(0,h.env)().getBool("WEBGL_EXP_CONV")){const _=new Jk(p);m=e.runWebGLProgram(_,[s,o],"float32",[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]])}else if((0,h.env)().getBool("WEBGL_CONV_IM2COL"))m=tM({x:s,filter:o,convInfo:p,backend:e});else{const _=new Qk(p);m=e.runWebGLProgram(_,[s,o],"float32")}else m=eM({x:s,filter:o,convInfo:p,backend:e});const y=Ot({inputs:{x:m},backend:e,attrs:{shape:p.outShape}});return e.disposeIntermediateTensorInfo(m),y}};class gQ{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===t.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class yQ{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,i="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${i?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${i?1:2}], coords[${i?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class bQ{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class _Q{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,r=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${r-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const xQ={kernelName:h.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:function vQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,d=h.backend_util.convertConv2DDataFormat(l),p=h.backend_util.computeConv2DInfo(s.shape,u,i,1,a,c,!1,d),m=new gQ(p);return e.runWebGLProgram(m,[s,o],"float32")}};class CQ{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=Xs(this.outputShape.length);const e=t.filterHeight,r=t.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int wCPerm = ${r} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const SQ={kernelName:h.Conv2DBackpropInput,backendName:"webgl",kernelFunc:function wQ(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{inputShape:i,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,d=h.backend_util.convertConv2DDataFormat(c),p=h.backend_util.computeConv2DInfo(i,o.shape,a,1,l,u,!1,d);if((0,h.env)().getBool("WEBGL_PACK")&&"channelsLast"===d){const m=[[p.strideHeight,p.strideWidth]],y=new CQ(p);return e.runWebGLProgram(y,[s,o],"float32",m)}{const m=new yQ(p);return e.runWebGLProgram(m,[s,o],"float32")}}},DQ={kernelName:h.Conv3D,backendName:"webgl",kernelFunc:function EQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l}=r,c=h.backend_util.computeConv3DInfo(s.shape,o.shape,i,l,a),u=new hQ(c);return e.runWebGLProgram(u,[s,o],"float32")}},IQ={kernelName:h.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:function TQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,pad:a,filterShape:l}=r,c=h.backend_util.computeConv3DInfo(s.shape,l,i,1,a),u=new bQ(c);return e.runWebGLProgram(u,[s,o],"float32")}},NQ={kernelName:h.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:function AQ(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{pad:i,strides:a,inputShape:l}=r,c=h.backend_util.computeConv3DInfo(l,o.shape,a,1,i),u=new _Q(c);return e.runWebGLProgram(u,[s,o],"float32")}},RQ=Gn({opSnippet:xh+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${zu}\n  return result;\n`}),OQ={kernelName:h.Cos,backendName:"webgl",kernelFunc:RQ},FQ=Gn({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),PQ={kernelName:h.Cosh,backendName:"webgl",kernelFunc:FQ};class $Q{constructor(t,e,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,l,c]=t,[u]=e,[d,p]=r;this.outputShape=[u,d,p,c];const m="bilinear"===s?1:0,[y,_]=[a-1+".0",l-1+".0"],[C,D,N]=d>1?[""+(a-1)/(d-1),"(y2-y1) * height_ratio",`y1*${y} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${y}`],[W,j,te]=p>1?[""+(l-1)/(p-1),"(x2-x1) * width_ratio",`x1*${_} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${_}`];this.userCode=`\n      const float height_ratio = float(${C});\n      const float width_ratio = float(${W});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${D};\n        float width_scale = ${j};\n\n        float in_y = ${N};\n        if( in_y < 0.0 || in_y > ${y} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${te};\n        if( in_x < 0.0 || in_x > ${_} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${m} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const BQ={kernelName:h.CropAndResize,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:o,boxInd:i}=t,{cropSize:a,method:l,extrapolationValue:c}=r,u=new $Q(s.shape,o.shape,a,l,c);return e.runWebGLProgram(u,[s,o,i],"float32")}};var Uc=(()=>((Uc=Uc||{}).Prod="*",Uc.Sum="+",Uc))();class nM{constructor(t,e,r,s){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,a=r?this.op===Uc.Prod?"1.0":"0.0":`getX(${rM(o,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";r?(c=s?"end != "+(l-1):"end != 0",u=s?"end + 1":"end - 1"):(c=s?`end + pow2 < ${l}`:"end >= pow2",u=s?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${ur(o)} coords = getOutputCoords();\n        int end = ${sM(o,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${c}) {\n          int idx = ${u};\n          ${sM(o,"coords",this.op)} = idx;\n          val ${this.op}= getX(${rM(o,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function rM(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function sM(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function oM(n,t,e,r,s,o){const i=t.shape.length,a=h.backend_util.getAxesPermutation([r],i);let l=t;null!=a&&(l=yo({inputs:{x:t},backend:e,attrs:{perm:a}}));const c=h.backend_util.getInnerMostAxes(1,i)[0];if(c!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const u=l.shape[c];let d=qo({inputs:{x:l},backend:e});for(let p=0;p<=Math.ceil(Math.log2(u))-1;p++){const m=new nM(n,l.shape,!1,o),_=d;d=e.runWebGLProgram(m,[d],d.dtype,[[p]]),e.disposeIntermediateTensorInfo(_)}if(s){const p=new nM(n,l.shape,s,o),m=d;d=e.runWebGLProgram(p,[d],d.dtype),e.disposeIntermediateTensorInfo(m)}if(null!=a){const m=yo({inputs:{x:d},backend:e,attrs:{perm:h.backend_util.getUndoAxesPermutation(a)}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(l),m}return d}const UQ={kernelName:h.Cumprod,backendName:"webgl",kernelFunc:function VQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:i,reverse:a}=r;return oM(Uc.Prod,s,e,o,i,a)}},HQ={kernelName:h.Cumsum,backendName:"webgl",kernelFunc:function zQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:i,reverse:a}=r;return oM(Uc.Sum,s,e,o,i,a)}},jQ={kernelName:h.DenseBincount,backendName:"webgl",kernelFunc:function WQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const l=e.readSync(s.dataId),c=e.readSync(o.dataId),u=Sk(l,c,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,u)}if(2===s.shape.length){const l=e.bufferSync(s),c=e.bufferSync(o),u=Jq(l,c,i,a);return e.makeTensorInfo(u.shape,o.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class GQ{constructor(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const XQ={kernelName:h.DepthToSpace,backendName:"webgl",kernelFunc:function KQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:o,dataFormat:i}=r,a=s.shape[0],d=("NHWC"===i?s.shape[1]:s.shape[2])*o,p=("NHWC"===i?s.shape[2]:s.shape[3])*o,m=("NHWC"===i?s.shape[3]:s.shape[1])/(o*o),_=new GQ("NHWC"===i?[a,d,p,m]:[a,m,d,p],o,i);return e.runWebGLProgram(_,[s],s.dtype)}};class iM{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Xs(this.outputShape.length);const i=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels;let c="",u="";r&&(c=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,u="result = activation(result);");const d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${c}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${u}\n        setOutput(result);\n      }\n    `}}class aM{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Xs(this.outputShape.length);const i=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,u=t.filterHeight,d=t.filterWidth,p=d;let m="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let D=0;D<d;D++)m+=`\n          vec4 xTexelC${2*D};\n          int xTexelC${2*D}Ready;\n          vec4 xTexelC${2*D+1};\n          int xTexelC${2*D+1}Ready;\n          vec4 xC${D};`;m+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let D=0;D<d;D++)m+=`\n          xTexelC${2*D} = vec4(0.0);\n          xTexelC${2*D}Ready = 0;\n          xTexelC${2*D+1} = vec4(0.0);\n          xTexelC${2*D+1}Ready = 0;\n          xC${D} = vec4(0.0);`;m+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let D=0;D<(p+1)/2;D++){const N=2*D;if(m+=`\n          xC = xCCorner + ${N*c};\n          `,1===l){if(N<d&&(a%2==1?(m+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N}Ready == 0) {\n                  xTexelC${N} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${N}.zw = vec2(0.0);\n                  }\n                  xTexelC${N}Ready = 1;\n                }\n              `,m+=1===c&&N>0?`\n                xC${N} = vec4(xTexelC${N-2}.zw, xTexelC${N}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${N} = vec4(previous.zw, xTexelC${N}.xy);\n                  } else {\n                    xC${N} = vec4(0.0, 0.0, xTexelC${N}.xy);\n                  }\n                  `):m+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${N}Ready == 0) {\n                  xTexelC${N} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${N}.zw = vec2(0.0);\n                  }\n                  xTexelC${N}Ready = 1;\n                }\n\n                xC${N} = xTexelC${N};\n                `,N+1<d)){const W=a%2==0?h.util.nearestLargerEven(c):c;c%2==0&&a%2==1||c%2!=0&&a%2!=1?(m+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${W};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {\n                    xTexelC${N+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${N+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${N+1}Ready = 1;\n                  }\n                  `,m+=c>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${N+1} = vec4(previous.zw, xTexelC${N+1}.xy);\n                    } else {\n                     xC${N+1} = vec4(0.0, 0.0, xTexelC${N+1}.xy);\n                    }\n                    `:`\n                    xC${N+1} = vec4(xTexelC${N}.zw, xTexelC${N+1}.xy);\n                    `):m+=1===W?`\n                    xC${N+1} = xTexelC${N};\n                    `:`\n                    xCOffset = xC + ${W};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {\n                      xTexelC${N+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${N+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${N+1}Ready = 1;\n                    }\n\n                    xC${N+1} = xTexelC${N+1};\n                    `}}else N<d&&(a%2==1?(m+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N}Ready == 0) {\n                  xTexelC${N} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${N}.zw = vec2(0.0);\n                  }\n                  xTexelC${N}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${N+1}Ready == 0) {\n                  xTexelC${N+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${N+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${N+1}Ready = 1;\n                }\n\n                xC${N} = vec4(xTexelC${N}.zw, xTexelC${N+1}.zw);\n              `,N+1<d&&(m+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${N+1} = vec4(xTexelC${N+1}.xy, final.xy);\n                `)):(m+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${N}Ready == 0) {\n                  xTexelC${N} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${N}.zw = vec2(0.0);\n                  }\n                  xTexelC${N}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {\n                  xTexelC${N+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${N+1}.zw = vec2(0.);\n                  }\n                  xTexelC${N+1}Ready = 1;\n                }\n\n                xC${N} = vec4(\n                  xTexelC${N}.xy, xTexelC${N+1}.xy);\n              `,N+1<d&&(m+=`\n                  xC${N+1} = vec4(xTexelC${N}.zw, xTexelC${N+1}.zw);\n                `)));N<d&&(m+=`\n            wTexel = getW(r, ${N}, d1, q);\n            dotProd += xC${N} * vec4(wTexel.xz, wTexel.xz);\n          `,N+1<d&&(m+=`\n              wTexel = getW(r, ${N+1}, d1, q);\n              dotProd += xC${N+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}m+="\n    }\n  ",m+="\n      }\n    ";let y="",_="";r&&(y=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,_="result = activation(result);");const C=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${y}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${m}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${C}\n        ${_}\n        setOutput(result);\n      }\n    `}}const ZQ={kernelName:h.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:function qQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l,dimRoundingMode:c}=r;let u=l;null==u&&(u=[1,1]),h.util.assert(h.backend_util.eitherStridesOrDilationsAreOne(i,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const d=h.backend_util.computeConv2DInfo(s.shape,o.shape,i,u,a,c,!0);let p;return p=(0,h.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new aM(d):new iM(d),e.runWebGLProgram(p,[s,o],"float32",[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]])}};class YQ{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class QQ{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,l=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const eJ={kernelName:h.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:function JQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,d=h.backend_util.computeConv2DInfo(s.shape,u,i,a,l,c,!0),p=new YQ(d);return e.runWebGLProgram(p,[s,o],"float32")}},nJ={kernelName:h.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:function tJ(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,d=h.backend_util.computeConv2DInfo(u,o.shape,i,a,l,c,!0),p=new QQ(d);return e.runWebGLProgram(p,[s,o],"float32")}};class rJ{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const oJ={kernelName:h.Diag,backendName:"webgl",kernelFunc:function sJ(n){const{inputs:t,backend:e}=n,{x:r}=t,s=[...r.shape,...r.shape],o=h.util.sizeFromShape(r.shape),i=Ot({inputs:{x:r},backend:e,attrs:{shape:[o]}}),a=new rJ(o),l=e.runWebGLProgram(a,[i],i.dtype),c=Ot({inputs:{x:l},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),c}};class iJ{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=t,{top:d,left:p}=s;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${c};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const lJ={kernelName:h.Dilation2D,backendName:"webgl",kernelFunc:function aJ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l}=r,c=h.backend_util.computeDilation2DInfo(s.shape,o.shape,i,a,"NHWC",l);let u;const d=new iJ(c);u=e.runWebGLProgram(d,[s,o],"float32");const p=Ot({inputs:{x:u},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(u),p}},uJ={kernelName:h.Einsum,backendName:"webgl",kernelFunc:function cJ(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,o=t,{allDims:i,summedDims:a,idDims:l}=h.backend_util.decodeEinsumEquation(s,o.length);h.backend_util.checkEinsumDimSizes(i.length,l,o);const{path:c,steps:u}=h.backend_util.getEinsumComputePath(a,l),d=u.length;let p=null,m=i.length;const y=[];for(let _=0;_<d;++_){for(const C of u[_]){const{permutationIndices:D,expandDims:N}=h.backend_util.getEinsumPermutation(m,l[C]);let W;h.backend_util.isIdentityPermutation(D)?W=o[C]:(W=yo({inputs:{x:o[C]},backend:e,attrs:{perm:D}}),y.push(W));const j=W.shape.slice();for(let te=0;te<N.length;++te)j.splice(N[te],0,1);h.util.arraysEqual(W.shape,j)||(W=Ot({inputs:{x:W},backend:e,attrs:{shape:j}}),y.push(W)),null===p?p=W:(p=tC({inputs:{a:W,b:p},backend:e}),y.push(p))}_<d-1&&(c[_]>=0&&(p=zy({inputs:{x:p},backend:e,attrs:{axis:c[_]-(i.length-m),keepDims:!1}}),y.push(p)),m--)}for(const _ of y)_!==p&&e.disposeIntermediateTensorInfo(_);return p}},dJ=Gn({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),hJ={kernelName:h.Elu,backendName:"webgl",kernelFunc:dJ},gJ={kernelName:h.EluGrad,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:r,y:s}=t,o=(0,h.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Cf("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new vh("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return e.runWebGLProgram(o,[r,s],r.dtype)}},yJ=Rs({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:r9}),bJ={kernelName:h.Equal,backendName:"webgl",kernelFunc:yJ},vJ=Gn({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${h.backend_util.ERF_P};\n  float a1 = ${h.backend_util.ERF_A1};\n  float a2 = ${h.backend_util.ERF_A2};\n  float a3 = ${h.backend_util.ERF_A3};\n  float a4 = ${h.backend_util.ERF_A4};\n  float a5 = ${h.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),xJ={kernelName:h.Erf,backendName:"webgl",kernelFunc:vJ},lM=Gn({opSnippet:xh+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:s9,dtype:"float32"}),wJ={kernelName:h.Exp,backendName:"webgl",kernelFunc:lM};function oC(n){const{inputs:t,attrs:e,backend:r}=n,{dim:s}=e,{input:o}=t,i=o.shape.length,a=o.shape.slice();let l=s;return s<0&&(h.util.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),Ot({inputs:{x:o},backend:r,attrs:{shape:a}})}const SJ={kernelName:h.ExpandDims,backendName:"webgl",kernelFunc:oC},cM="return exp(x) - 1.0;",EJ=Gn({opSnippet:cM,packedOpSnippet:cM,cpuKernelImpl:o9}),DJ={kernelName:h.Expm1,backendName:"webgl",kernelFunc:EJ};class uM{constructor(t,e,r){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function dM(n,t,e){const r=e.texData.get(n.dataId),s=h.util.sizeFromShape(n.shape),o=n.shape[n.shape.length-1],a=Ot({inputs:{x:n},backend:e,attrs:{shape:[s/o,o]}}),l=a.shape,c=new uM("real",l,t),u=new uM("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],p=e.runWebGLProgram(c,d,"float32"),m=e.runWebGLProgram(u,d,"float32"),y=Vc({inputs:{real:p,imag:m},backend:e});e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m);const _=Ot({inputs:{x:y},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(y),_}const IJ={kernelName:h.FFT,backendName:"webgl",kernelFunc:function TJ(n){const{inputs:t,backend:e}=n,{input:r}=t;return dM(r,!1,e)}};class AJ{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Tf(n){const{backend:t,attrs:e}=n,{shape:r,value:s}=e;let{dtype:o}=e;if(o=o||h.util.inferDtype(s),"string"===o){const i=h.util.getArrayFromDType(o,h.util.sizeFromShape(r));return i.fill(s),t.makeTensorInfo(r,o,i)}{const i=new AJ(r,s);return t.runWebGLProgram(i,[],o,[[s]])}}const NJ={kernelName:h.Fill,backendName:"webgl",kernelFunc:Tf};class kJ{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const MJ={kernelName:h.FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,r=t,s=new kJ(e.shape);return r.runWebGLProgram(s,[e],e.dtype)}},hM="return floor(x);",RJ=Gn({opSnippet:hM,packedOpSnippet:hM,cpuKernelImpl:i9}),OJ={kernelName:h.Floor,backendName:"webgl",kernelFunc:RJ},FJ=Rs({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),PJ={kernelName:h.FloorDiv,backendName:"webgl",kernelFunc:FJ};class $J{constructor(t){this.variableNames=["A"];const e=mo(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class LJ{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=mo(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const BJ={kernelName:h.FromPixels,backendName:"webgl",kernelFunc:function VJ(n){const{inputs:t,backend:e,attrs:r}=n;let{pixels:s}=t;const{numChannels:o}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,c]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],u=[c,l],d=[c,l,o];if(a||i){const _=(0,h.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==wh||_!==iC)&&(iC=_,wh=document.createElement("canvas").getContext("2d",{willReadFrequently:iC})),wh.canvas.width=l,wh.canvas.height=c,wh.drawImage(s,0,0,l,c),s=wh.canvas}const p=e.makeTensorInfo(u,"int32");e.texData.get(p.dataId).usage=Wr.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(p.dataId),s);const m=(0,h.env)().getBool("WEBGL_PACK")?new LJ(d):new $J(d),y=e.runWebGLProgram(m,[p],"int32");return e.disposeData(p.dataId),y}};let wh,iC=(0,h.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const zJ={kernelName:h.FusedConv2D,backendName:"webgl",kernelFunc:function UJ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:y}=r,_=h.backend_util.convertConv2DDataFormat(u),C=h.backend_util.computeConv2DInfo(s.shape,o.shape,l,d,c,p,!1,_);let D;const N=[],W=null!=i,j=null!=a,te="leakyrelu"===m,_e=()=>{const Ne=[s,o],je=(He,it)=>{if("NCHW"===it&&1===He.shape.length&&1!==He.shape[0]){const at=Ot({inputs:{x:He},backend:e,attrs:{shape:[He.shape[0],1,1]}});return N.push(at),at}return He};if(W&&Ne.push(je(i,u)),j&&Ne.push(je(a,u)),te){const He=e.makeTensorInfo([],"float32",h.util.createScalarValue(y,"float32"));Ne.push(He),N.push(He)}return Ne};if(1!==C.filterHeight||1!==C.filterWidth||1!==C.dilationHeight||1!==C.dilationWidth||1!==C.strideHeight||1!==C.strideWidth||"SAME"!==C.padInfo.type&&"VALID"!==C.padInfo.type)if(C.strideWidth<=2&&"channelsLast"===_&&(0,h.env)().getBool("WEBGL_EXP_CONV")){const Ne=m?wf(m,!0):null,je=new Jk(C,W,Ne,j,te),He=[[C.padInfo.top,C.padInfo.left],[C.strideHeight,C.strideWidth],[C.dilationHeight,C.dilationWidth],[C.inHeight,C.inWidth]],it=_e();D=e.runWebGLProgram(je,it,"float32",He)}else if((0,h.env)().getBool("WEBGL_CONV_IM2COL"))D=tM({x:s,filter:o,convInfo:C,backend:e,bias:i,activation:m,preluActivationWeights:a,leakyreluAlpha:y});else{const Ne=m?wf(m,!1):null,je=new Qk(C,W,Ne,j,te),He=_e();D=e.runWebGLProgram(je,He,"float32")}else D=eM({x:s,filter:o,convInfo:C,backend:e,bias:i,activation:m,preluActivationWeights:a,leakyreluAlpha:y});const Ee=Ot({inputs:{x:D},backend:e,attrs:{shape:C.outShape}});return N.push(D),N.forEach(Ne=>e.disposeIntermediateTensorInfo(Ne)),Ee}},WJ={kernelName:h.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:function HJ(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:l,pad:c,dilations:u,dimRoundingMode:d,activation:p,leakyreluAlpha:m}=r,y=[];let _=u;null==_&&(_=[1,1]),h.util.assert(h.backend_util.eitherStridesOrDilationsAreOne(l,_),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${_}'`);const C=h.backend_util.computeConv2DInfo(s.shape,o.shape,l,_,c,d,!0),D=(0,h.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&C.strideWidth<=2&&C.outChannels/C.inChannels==1,N=p?wf(p,D):null,W=[s,o],j=null!=i,te=null!=a,_e="leakyrelu"===p;if(j&&W.push(i),te&&W.push(a),_e){const He=e.makeTensorInfo([],"float32",h.util.createScalarValue(m,"float32"));W.push(He),y.push(He)}let Ee;Ee=D?new aM(C,j,N,te,_e):new iM(C,j,N,te,_e);const je=e.runWebGLProgram(Ee,W,"float32",[[C.padInfo.top,C.padInfo.left],[C.strideHeight,C.strideWidth],[C.dilationHeight,C.dilationWidth],[C.inHeight,C.inWidth]]);return y.forEach(He=>e.disposeIntermediateTensorInfo(He)),je}};class jJ{constructor(t,e,r,s){this.sliceDim=t,this.strides=e,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const o=ur(r.length);let i="\n    int index;";for(let a=0;a<this.sliceDim;a++)i+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${i}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const KJ={kernelName:h.GatherNd,backendName:"webgl",kernelFunc:function GJ(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,o=s.shape,i=o[o.length-1],a=h.util.sizeFromShape(r.shape),[l,c,u,d]=h.backend_util.prepareAndValidate(r,s),p=Ot({inputs:{x:s},backend:e,attrs:{shape:[c,i]}}),m=Ot({inputs:{x:r},backend:e,attrs:{shape:[h.util.sizeFromShape(r.shape)/u,u]}});if(e.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const D=e.readSync(s.dataId),N=e.bufferSync(r),W=a9(D,N,r.dtype,c,i,u,d,r.shape,a);return e.makeTensorInfo(l,r.dtype,W.values)}const y=new jJ(i,d,[c,u],r.shape),_=e.runWebGLProgram(y,[m,p],m.dtype),C=Ot({inputs:{x:_},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(_),C}};class XJ{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=ur(this.rank),s=function qJ(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)r.push(2===s?"index":`${e[s]}`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function pM(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:o}=t,{axis:i,batchDims:a}=r,l=h.util.parseAxisParam(i,s.shape)[0];if((0,h.env)().get("DEBUG")){const N=e.readSync(o.dataId),W=s.shape[l];for(let j=0;j<N.length;++j){const te=N[j];h.util.assert(te<=W-1&&te>=0,()=>`GatherV2: the index value ${te} is not in [0, ${W-1}]`)}}const c=h.backend_util.segment_util.collectGatherOpShapeInfo(s,o,l,a),u=h.util.sizeFromShape(o.shape),d=[],p=Ot({inputs:{x:s},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),m=Ot({inputs:{x:o},backend:e,attrs:{shape:[c.batchSize,u/c.batchSize]}});d.push(p),d.push(m);const y=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([s,o])||"string"===s.dtype){const N=e.bufferSync(m),W=e.bufferSync(p),j=l9(W,N,y);return d.forEach(te=>e.disposeIntermediateTensorInfo(te)),e.makeTensorInfo(c.outputShape,j.dtype,j.values)}const _=new XJ(p.shape,y),C=e.runWebGLProgram(_,[p,m],p.dtype);d.push(C);const D=Ot({inputs:{x:C},backend:e,attrs:{shape:c.outputShape}});return d.forEach(N=>e.disposeIntermediateTensorInfo(N)),D}const ZJ={kernelName:h.GatherV2,backendName:"webgl",kernelFunc:pM},YJ=Rs({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:c9,dtype:"bool"}),QJ={kernelName:h.Greater,backendName:"webgl",kernelFunc:YJ},JJ=Rs({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:u9}),eee={kernelName:h.GreaterEqual,backendName:"webgl",kernelFunc:JJ},nee={kernelName:h.IFFT,backendName:"webgl",kernelFunc:function tee(n){const{inputs:t,backend:e}=n,{input:r}=t;return dM(r,!0,e)}},ree=Gn({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),see={kernelName:h.IsFinite,backendName:"webgl",kernelFunc:ree},oee=Gn({opSnippet:"return float(isinf(x));",dtype:"bool"}),iee={kernelName:h.IsInf,backendName:"webgl",kernelFunc:oee},aee=Gn({opSnippet:"return float(isnan(x));",dtype:"bool"}),lee={kernelName:h.IsNan,backendName:"webgl",kernelFunc:aee},cee=Rs({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:d9,dtype:"bool"}),uee={kernelName:h.Less,backendName:"webgl",kernelFunc:cee},dee=Rs({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:h9,dtype:"bool"}),hee={kernelName:h.LessEqual,backendName:"webgl",kernelFunc:dee},fee={kernelName:h.LinSpace,backendName:"webgl",kernelFunc:function pee(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:o}=e,i=p9(r,s,o);return t.makeTensorInfo([i.length],"float32",i)}},gee=Gn({opSnippet:xh+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:f9}),yee={kernelName:h.Log,backendName:"webgl",kernelFunc:gee},_ee=Gn({opSnippet:xh+"\n  return log(1.0 + x);\n"}),vee={kernelName:h.Log1p,backendName:"webgl",kernelFunc:_ee},xee=Rs({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Cee={kernelName:h.LogicalAnd,backendName:"webgl",kernelFunc:xee},wee=Gn({opSnippet:"return float(!(x >= 1.0));"}),See={kernelName:h.LogicalNot,backendName:"webgl",kernelFunc:wee},Eee=Rs({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Dee={kernelName:h.LogicalOr,backendName:"webgl",kernelFunc:Eee};class Tee{constructor(t,e,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=e,a=t[3]-1;let l;this.outputShape=t;const c=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${c})`:1===o?`1.0/(${c})`:`exp(log(${c}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class Iee{constructor(t,e,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,a=t[3]-1;let l;this.outputShape=t;const c=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${c})`:1===o?`1.0/(${c})`:`exp(log(${c}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const Nee={kernelName:h.LRN,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:o,bias:i,alpha:a,beta:l}=r,c=(0,h.env)().getBool("WEBGL_PACK_NORMALIZATION")?new Iee(s.shape,o,i,a,l):new Tee(s.shape,o,i,a,l);return e.runWebGLProgram(c,[s],s.dtype)}};class kee{constructor(t,e,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${o})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const Ree={kernelName:h.LRNGrad,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s,y:o,dy:i}=t,{depthRadius:a,bias:l,alpha:c,beta:u}=r,d=new kee(s.shape,a,l,c,u);return e.runWebGLProgram(d,[s,o,i],s.dtype)}};function fM(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,l=h.util.parseAxisParam(o,s.shape);let c=l;const u=h.backend_util.getAxesPermutation(c,a),d=null!=u,p=e.shouldExecuteOnCPU([s]);let m=s;if(d){if(p){const W=e.texData.get(m.dataId).values,j=new Array(a);for(let Ee=0;Ee<j.length;Ee++)j[Ee]=s.shape[u[Ee]];const te=Jx(W,s.shape,s.dtype,u,j);m=e.makeTensorInfo(j,s.dtype),e.texData.get(m.dataId).values=te}else m=Uy(s,u,e);c=h.backend_util.getInnerMostAxes(c.length,a)}h.backend_util.assertAxesAreInnerMostDims("max",c,a);const[y,_]=h.backend_util.computeOutAndReduceShapes(m.shape,c);let D,C=y;if(i&&(C=h.backend_util.expandShapeToKeepDim(y,l)),p){const W=e.texData.get(m.dataId).values,j=m9(W,h.util.sizeFromShape(_),C,s.dtype);D=e.makeTensorInfo(C,s.dtype),e.texData.get(D.dataId).values=j}else D=function Oee(n,t,e,r){const s=h.util.sizeFromShape(t),a=Ot({inputs:{x:n},attrs:{shape:[h.util.sizeFromShape(n.shape)/s,s]},backend:r}),l=Hu(a,n.dtype,"max",r),c=Ot({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}(m,_,C,e);return d&&e.disposeIntermediateTensorInfo(m),D}const Fee={kernelName:h.Max,backendName:"webgl",kernelFunc:fM},Lee=Rs({opSnippet:eC+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+zu+"\n  return result;\n",cpuKernelImpl:g9}),Bee={kernelName:h.Maximum,backendName:"webgl",kernelFunc:Lee},Uee={kernelName:h.MaxPool,backendName:"webgl",kernelFunc:function Vee(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;vf(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;h.util.assert(h.backend_util.eitherStridesOrDilationsAreOne(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const u=h.backend_util.computePool2DInfo(s.shape,o,i,1,a,l);if(1===u.filterWidth&&1===u.filterHeight&&h.util.arraysEqual(u.inShape,u.outShape))return qo({inputs:{x:s},backend:e});const d=new Sf(u,"max",!1);return e.runWebGLProgram(d,[s],s.dtype)}},Hee={kernelName:h.MaxPool3D,backendName:"webgl",kernelFunc:function zee(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:c}=r,d=h.backend_util.computePool3DInfo(s.shape,o,i,[1,1,1],a,c,l),p=new nC(d,"max",!1);return e.runWebGLProgram(p,[s],s.dtype)}};class Wee{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const o=t.effectiveFilterHeight,i=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${o-1-t.padInfo.top}, ${i-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${o*i-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class jee{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,u=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-t.padInfo.front}, ${c-1-t.padInfo.top}, ${u-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*c*u-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${c} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Kee={kernelName:h.MaxPool3DGrad,backendName:"webgl",kernelFunc:function Gee(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,i=o,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,p=h.backend_util.computePool3DInfo(i.shape,a,l,[1,1,1],c,u),m=new nC(p,"max",!0),y=e.runWebGLProgram(m,[i],i.dtype),_=new jee(p),C=e.runWebGLProgram(_,[s,y],i.dtype);return e.disposeIntermediateTensorInfo(y),C}},qee={kernelName:h.MaxPoolGrad,backendName:"webgl",kernelFunc:function Xee(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o,output:i}=t,a=o;vf([o,i],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=r,p=h.backend_util.computePool2DInfo(a.shape,l,c,1,u,d),y=new Sf(p,"max",!0),_=e.runWebGLProgram(y,[a],a.dtype),C=new Wee(p),D=e.runWebGLProgram(C,[s,_],a.dtype);return e.disposeIntermediateTensorInfo(_),D}},Yee={kernelName:h.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=t,l=e;h.util.assert(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];h.util.assert(h.backend_util.eitherStridesOrDilationsAreOne(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=h.backend_util.computePool2DInfo(r.shape,s,o,c,i),[d,p]=function Zee(n,t,e,r){let s=new Sf(e,"max",!1);const o=r.runWebGLProgram(s,[n],"float32");return s=new Sf(e,"max",!0,!0,t),[o,r.runWebGLProgram(s,[n],"float32")]}(r,a,u,l);return[d,p]}},Jee={kernelName:h.Mean,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{keepDims:s,axis:o}=t,i=e,a=r.shape.length,l=h.util.parseAxisParam(o,r.shape);let c=l;const u=h.backend_util.getAxesPermutation(c,a),d=null!=u,p=i.shouldExecuteOnCPU([r]),m=[];let y=r;if(d){if(p){const j=i.texData.get(y.dataId).values,te=new Array(a);for(let Ne=0;Ne<te.length;Ne++)te[Ne]=r.shape[u[Ne]];const _e=Jx(j,r.shape,r.dtype,u,te);y=i.makeTensorInfo(te,r.dtype),i.texData.get(y.dataId).values=_e}else y=Uy(r,u,i);m.push(y),c=h.backend_util.getInnerMostAxes(c.length,a)}h.backend_util.assertAxesAreInnerMostDims("sum",c,a);const[_,C]=h.backend_util.computeOutAndReduceShapes(y.shape,c);let D=_;s&&(D=h.backend_util.expandShapeToKeepDim(_,l));const N=function Qee(n,t,e,r){const s=h.util.sizeFromShape(t),a=Ot({inputs:{x:n},attrs:{shape:[h.util.sizeFromShape(n.shape)/s,s]},backend:r}),l=Hu(a,"float32","mean",r),c=Ot({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}(y,C,D,i);for(const W of m)i.disposeIntermediateTensorInfo(W);return N}},tte={kernelName:h.Min,backendName:"webgl",kernelFunc:function ete(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,l=h.util.parseAxisParam(o,s.shape);let c=l;const u=h.backend_util.getAxesPermutation(c,a);let d=s;null!=u&&(d=yo({inputs:{x:s},backend:e,attrs:{perm:u}}),c=h.backend_util.getInnerMostAxes(c.length,s.shape.length)),h.backend_util.assertAxesAreInnerMostDims("min",c,a);const[p,m]=h.backend_util.computeOutAndReduceShapes(d.shape,c),_=Ot({inputs:{x:d},backend:e,attrs:{shape:[-1,h.util.sizeFromShape(m)]}}),C=Hu(_,_.dtype,"min",e);let D;return D=Ot(i?{inputs:{x:C},backend:e,attrs:{shape:h.backend_util.expandShapeToKeepDim(p,l)}}:{inputs:{x:C},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(C),null!=u&&e.disposeIntermediateTensorInfo(d),D}},ste=Rs({opSnippet:eC+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+zu+"\n  return result;\n",cpuKernelImpl:y9}),ote={kernelName:h.Minimum,backendName:"webgl",kernelFunc:ste};class ite{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((u,d)=>u[0]+t[d]+u[1]);const s=t.length,o=ur(s),i=e.map(u=>u[0]).join(","),a=e.map((u,d)=>u[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c="reflect"===r?0:1;this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class ate{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((y,_)=>y[0]+t[_]+y[1]);const s=t.length,o=ur(s),i=e.map(y=>y[0]).join(","),a=e.map((y,_)=>y[0]+t[_]).join(","),l=go("rc",s),c=go("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${c.slice(-2).join()})`,p="reflect"===r?0:1;let m="";if(1===s){const y=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${p};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${p};\n        }\n        source -= start;\n      `;m=`\n        ${o} rc = outputLoc;\n        ${y}\n        result[0] = getChannel(getX(${c.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${u}) {\n          ${y}\n          result[1] = getChannel(getX(${c.join()}), ${d});\n        }\n      `}else{const y=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${p}) +\n                gte * ((end - 1) * 2 - source + ${p});\n        source -= start;\n      `;m=`\n        ${o} rc = outputLoc;\n        ${y}\n        result[0] = getChannel(getX(${c.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${u}) {\n          ${y}\n          result[1] = getChannel(getX(${c.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${l[s-2]} += 1;\n        if(${l[s-2]} < ${this.outputShape[s-2]}) {\n          ${y}\n          result[2] = getChannel(getX(${c.join()}), ${d});\n          ${l[s-1]} += 1;\n          if(${u}) {\n            ${y}\n            result[3] = getChannel(getX(${c.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${m}\n        setOutput(result);\n      }\n    `}}const cte={kernelName:h.MirrorPad,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r}=n,{paddings:s,mode:o}=e,i=(0,h.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ate(r.shape,s,o):new ite(r.shape,s,o);return t.runWebGLProgram(i,[r],r.dtype)}},hte=Rs({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+zu+"\n  return result;\n"}),pte={kernelName:h.Mod,backendName:"webgl",kernelFunc:hte};class fte{constructor(t,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const mM=Rs({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),mte={kernelName:h.RealDiv,backendName:"webgl",kernelFunc:mM},gM="return a - b;",yM=Rs({opSnippet:gM,packedOpSnippet:gM,supportsComplex:!0,cpuKernelImpl:L9}),gte={kernelName:h.Sub,backendName:"webgl",kernelFunc:yM};function bM(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:o}=r,i=h.util.parseAxisParam([o],s.shape),a=fM({inputs:{x:s},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),l=h.backend_util.expandShapeToKeepDim(a.shape,i),c=Ot({inputs:{x:a},backend:e,attrs:{shape:l}}),u=yM({inputs:{a:s,b:c},backend:e}),d=lM({inputs:{x:u},backend:e}),p=zy({inputs:{x:d},backend:e,attrs:{axis:i,keepDims:!1}}),m=Ot({inputs:{x:p},backend:e,attrs:{shape:l}}),y=mM({inputs:{a:d,b:m},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),y}const yte={kernelName:h.Softmax,backendName:"webgl",kernelFunc:bM},_te={kernelName:h.Multinomial,backendName:"webgl",kernelFunc:function bte(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:o,seed:i,normalized:a}=r,l=a?s:bM({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),d=new fte(l.shape[0],l.shape[1],o),m=e.runWebGLProgram(d,[l],"int32",[[i]]);return a||e.disposeIntermediateTensorInfo(l),m}},vte=_i+"\n  return -x;\n",wte={kernelName:h.Neg,backendName:"webgl",kernelFunc:function Cte(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId),[i,a]=_9(o.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,i)}let s;return s=(0,h.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Bc(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new al(r.shape,vte),e.runWebGLProgram(s,[r],r.dtype)}},Ste=h.kernel_impls.nonMaxSuppressionV3Impl,Dte={kernelName:h.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function Ete(n){h.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,c=e.readSync(s.dataId),u=e.readSync(o.dataId),{selectedIndices:d}=Ste(c,u,i,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Tte=h.kernel_impls.nonMaxSuppressionV4Impl,Ate={kernelName:h.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function Ite(n){h.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r,u=e.readSync(s.dataId),d=e.readSync(o.dataId),{selectedIndices:p,validOutputs:m}=Tte(u,d,i,a,l,c);return[e.makeTensorInfo([p.length],"int32",new Int32Array(p)),e.makeTensorInfo([],"int32",new Int32Array([m]))]}},Nte=h.kernel_impls.nonMaxSuppressionV5Impl,Mte={kernelName:h.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function kte(n){h.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=e.readSync(s.dataId),d=e.readSync(o.dataId),p=i,m=a,y=l,_=c,{selectedIndices:C,selectedScores:D}=Nte(u,d,p,m,y,_);return[e.makeTensorInfo([C.length],"int32",new Int32Array(C)),e.makeTensorInfo([D.length],"float32",new Float32Array(D))]}};class Rte{constructor(t,e,r,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const Fte={kernelName:h.OneHot,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:o,depth:i,onValue:a,offValue:l}=r,c=h.util.sizeFromShape(s.shape),u=new Rte(c,i,a,l),d=Ot({inputs:{x:s},backend:e,attrs:{shape:[c]}}),p=e.runWebGLProgram(u,[d],o);e.disposeIntermediateTensorInfo(d);const y=Ot({inputs:{x:p},backend:e,attrs:{shape:[...s.shape,i]}});return e.disposeIntermediateTensorInfo(p),y}};function Xy(n){const{inputs:t,backend:e}=n,{x:r}=t;if("complex64"===r.dtype){const s=Ef({inputs:{input:r},backend:e}),o=Xy({inputs:{x:s},backend:e}),i=Gy({inputs:{input:r},backend:e}),a=Xy({inputs:{x:i},backend:e}),l=Vc({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return Tf({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const Pte={kernelName:h.ZerosLike,backendName:"webgl",kernelFunc:Xy},$te={kernelName:h.OnesLike,backendName:"webgl",kernelFunc:function _M(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=Ef({inputs:{input:r},backend:e}),o=_M({inputs:{x:s},backend:e}),i=Gy({inputs:{input:r},backend:e}),a=Xy({inputs:{x:i},backend:e}),l=Vc({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return Tf({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},Bte={kernelName:h.Pack,backendName:"webgl",kernelFunc:function Lte(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return oC({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const o=t[0].shape,i=t[0].dtype;t.forEach(u=>{h.util.assertShapesMatch(o,u.shape,"All tensors passed to stack must have matching shapes"),h.util.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=Yk({inputs:t.map(u=>{const d=oC({inputs:{input:u},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}};class Vte{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,u)=>c[0]+t[u]+c[1]);const s=t.length,o=ur(s),i=e.map(c=>c[0]).join(","),a=e.map((c,u)=>c[0]+t[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class Ute{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((_,C)=>_[0]+t[C]+_[1]);const s=t.length,o=ur(s),i=e.map(_=>_[0]).join(","),a=e.map((_,C)=>_[0]+t[C]).join(","),l=go("rc",s),c=go("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${c.slice(-2).join()})`,p=[`${o} rc = outputLoc;`,`${l[s-1]} += 1;\n       if(${u}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${l[s-2]} += 1;\n       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${l[s-1]} += 1;\n         if(${u}) {`],m=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let y="";for(let _=0,C=1===s?2:4;_<C;_++)y+=`\n        ${p[_]}\n        if (${m}) {\n          result[${_}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${_}] = getChannel(getX(${c.join()}), ${d});\n        }\n      `;y+=1===s?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${y}\n        setOutput(result);\n      }\n    `}}const vM=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:o,constantValue:i}=r;if(0===h.util.sizeFromShape(s.shape))return Tf({backend:e,attrs:{shape:o.map((u,d)=>u[0]+s.shape[d]+u[1]),value:i,dtype:s.dtype}});const a=(0,h.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ute(s.shape,o,i):new Vte(s.shape,o,i);return e.runWebGLProgram(a,[s],s.dtype,[[i]])},zte={kernelName:h.PadV2,backendName:"webgl",kernelFunc:vM},jte=Rs({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+zu+"\n  return result;\n"}),Gte={kernelName:h.Pow,backendName:"webgl",kernelFunc:jte},Xte={kernelName:h.Prod,backendName:"webgl",kernelFunc:function Kte(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,l=[],c=h.util.parseAxisParam(o,s.shape);let u=c;const d=h.backend_util.getAxesPermutation(u,a);let m,p=s;if(null!=d&&(p=yo({inputs:{x:s},backend:e,attrs:{perm:d}}),u=h.backend_util.getInnerMostAxes(u.length,a),l.push(p)),h.backend_util.assertAxesAreInnerMostDims("prod",u,a),e.shouldExecuteOnCPU([p])){const y=e.texData.get(p.dataId).values,{outVals:_,outShape:C,outDtype:D}=x9(p.shape,p.dtype,y,u);m=e.makeTensorInfo(C,D,_)}else{const[y,_]=h.backend_util.computeOutAndReduceShapes(p.shape,u),C=h.util.sizeFromShape(_),D=Ot({inputs:{x:p},backend:e,attrs:{shape:[-1,C]}}),W=Hu(D,(0,h.sumOutType)(s.dtype),"prod",e);m=Ot({inputs:{x:W},backend:e,attrs:{shape:y}}),l.push(D),l.push(W)}if(i){l.push(m);const y=h.backend_util.expandShapeToKeepDim(m.shape,c);m=Ot({inputs:{x:m},backend:e,attrs:{shape:y}})}return l.forEach(y=>e.disposeIntermediateTensorInfo(y)),m}},Zte={kernelName:h.RaggedGather,backendName:"webgl",kernelFunc:function qte(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=t,{outputRaggedRank:a}=r,l=s.map(D=>e.readSync(D.dataId)),c=s.map(D=>D.shape),u=e.readSync(o.dataId),d=e.readSync(i.dataId),[p,m,y]=C9(l,c,u,o.shape,o.dtype,d,i.shape,a),_=p.map(D=>e.makeTensorInfo([D.length],"int32",D)),C=e.makeTensorInfo(y,o.dtype,m);return _.concat([C])}},Qte={kernelName:h.RaggedRange,backendName:"webgl",kernelFunc:function Yte(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:o}=t,i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[c,u]=w9(i,r.shape,r.dtype,a,s.shape,l,o.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([u.length],r.dtype,u)]}},ene={kernelName:h.RaggedTensorToTensor,backendName:"webgl",kernelFunc:function Jte(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=r,c=e.readSync(s.dataId),u=e.readSync(o.dataId),d=e.readSync(i.dataId),p=a.map(C=>e.readSync(C.dataId)),m=a.map(C=>C.shape),[y,_]=S9(c,s.shape,u,o.shape,o.dtype,d,i.shape,p,m,l);return e.makeTensorInfo(y,o.dtype,_)}},xM=n=>{const{backend:t,attrs:e}=n,{start:r,stop:s,step:o,dtype:i}=e,a=E9(r,s,o,i);return t.makeTensorInfo([a.length],i,a)},tne={kernelName:h.Range,backendName:"webgl",kernelFunc:xM},nne=Gn({opSnippet:"return 1.0 / x;"}),rne={kernelName:h.Reciprocal,backendName:"webgl",kernelFunc:nne},one=Gn({opSnippet:_i+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),ine={kernelName:h.Relu,backendName:"webgl",kernelFunc:one},lne=Gn({opSnippet:_i+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),cne={kernelName:h.Relu6,backendName:"webgl",kernelFunc:lne};class une{constructor(t,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,c]=t;this.outputShape=[i,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let p;p=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class dne{constructor(t,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,c]=t;this.outputShape=[i,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let p;p=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]},\n          ${u[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const pne={kernelName:h.ResizeBilinear,backendName:"webgl",kernelFunc:function hne(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,c]=a,u=(0,h.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new dne(s.shape,l,c,o,i):new une(s.shape,l,c,o,i);return e.runWebGLProgram(u,[s],"float32")}};class fne{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=t,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],c=[r&&i>1?i-1:i,r&&a>1?a-1:a],u=l[0]/c[0],d=l[1]/c[1],p=1/u,m=1/d,y=2*Math.ceil(p)+2,_=2*Math.ceil(m)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${p});\n        const float invWidthScale = float(${m});\n\n        const int winHeight = int(${y});\n        const int winWidth = int(${_});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const gne={kernelName:h.ResizeBilinearGrad,backendName:"webgl",kernelFunc:function mne(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:i}=r,a=new fne(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class yne{constructor(t,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,c]=t;this.outputShape=[i,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let m;m=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${m};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class bne{constructor(t,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,c]=t;this.outputShape=[i,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let m;m=o?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]},\n          ${u[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${m};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const vne={kernelName:h.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function _ne(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,c]=a,u=(0,h.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new bne(s.shape,l,c,o,i):new yne(s.shape,l,c,o,i);return e.runWebGLProgram(u,[s],s.dtype)}};class xne{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=t,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],c=[r&&i>1?i-1:i,r&&a>1?a-1:a],u=l[0]/c[0],d=l[1]/c[1],p=1/u,m=1/d,y=2*Math.ceil(p)+2,_=2*Math.ceil(m)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${p});\n        const float invWidthScale = float(${m});\n\n        const int winHeight = int(${y});\n        const int winWidth = int(${_});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${c[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${c[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const wne={kernelName:h.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:function Cne(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:i}=r,a=new xne(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class Sne{constructor(t,e){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const o=t.map((a,l)=>(a=>-1!==e.indexOf(a)&&1!==t[a]?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`)(l)).join(","),i=ur(r);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class Ene{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const s=go("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=ur(r);function p(y){const _=t.map((N,W)=>function m(y,_){return-1!==e.indexOf(y)&&1!==t[y]?`${t[y]} - ${_[y]} - 1`:`${_[y]}`}(W,y));return`getChannel(getX(${_.join(",")}), vec2(${_.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(y){return p(y)}(s.slice())};\n          if(${o}){\n            result.g = ${function c(y){return y[r-1]="("+y[r-1]+" + 1)",p(y)}(s.slice())};\n          }\n          if(${i}) {\n            result.b = ${function u(y){return y[r-2]="("+y[r-2]+" + 1)",p(y)}(s.slice())};\n            if(${o}) {\n              result.a = ${function d(y){return y[r-1]="("+y[r-1]+" + 1)",y[r-2]="("+y[r-2]+" + 1)",p(y)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const Tne={kernelName:h.Reverse,backendName:"webgl",kernelFunc:function Dne(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:o}=r,i=s.shape.length,a=h.util.parseAxisParam(o,s.shape);if(0===i)return qo({inputs:{x:s},backend:e});const l=(0,h.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ene(s.shape,a):new Sne(s.shape,a);return e.runWebGLProgram(l,[s],s.dtype)}};class Ine{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],s=t[2];this.outputShape=t;let o="";o="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Ane={kernelName:h.RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:o,center:i}=t,a=e,l=new Ine(r.shape,o),[c,u]=h.backend_util.getImageCenter(i,r.shape[1],r.shape[2]),d=[[c,u,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,d)}},Nne=Gn({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),kne={kernelName:h.Round,backendName:"webgl",kernelFunc:Nne},Mne=Gn({opSnippet:"return inversesqrt(x);",cpuKernelImpl:D9}),Rne={kernelName:h.Rsqrt,backendName:"webgl",kernelFunc:Mne};class aC{constructor(t,e,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const c=ur(o.length),u=ur(i.length);let d="";1===r?d="i":2===r&&(d="i, j");let m="";1===s?m="i":2===s&&(m="i, coords[1]");let _="";l&&(_="coords[0], coords[1]"),this.userCode=`\n        ${c} strides = ${c}(${o});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${d}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${m});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${_}), sum, float(found)));\n        }\n      `}}class One{constructor(t,e,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const c=ur(o.length),u=ur(i.length);let d="";1===r?d="i":2===r&&(d="i, j");let m="";1===s?m="i":2===s&&(m="i, coords[1]");let _="";l&&(_="coords[0], coords[1]"),this.userCode=`\n        ${c} strides = ${c}(${o});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${t}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(getIndices(${d}));\n              flattenedIndex += index.xz * ${e>1?"strides[j]":"strides"};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${e>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${m});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${_}), sum, found));\n        }\n      `}}const Pne={kernelName:h.ScatterNd,backendName:"webgl",kernelFunc:function Fne(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:o}=t,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=h.backend_util.calculateShapes(o,s,i),p=[d/c,c];if(0===d)return e.makeTensorInfo(i,s.dtype);const m=Ot({inputs:{x:s},backend:e,attrs:{shape:[l,a]}}),y=Ot({inputs:{x:o},backend:e,attrs:{shape:[l,c]}}),_=e.makeTensorInfo([],"float32",new Float32Array([0]));let C;C=(0,h.env)().getBool("WEBGL_PACK")?new One(l,a,m.shape.length,y.shape.length,u,p):new aC(l,a,m.shape.length,y.shape.length,u,p);const D=e.runWebGLProgram(C,[y,m,_],y.dtype),N=Ot({inputs:{x:D},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(D),e.disposeIntermediateTensorInfo(_),N}};class $ne{constructor(t,e,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===(0,h.env)().getNumber("WEBGL_VERSION")?"while (left < right) {":i;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===s?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const Bne={kernelName:h.SearchSorted,backendName:"webgl",kernelFunc:function Lne(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:o}=t,{side:i}=r,a=new $ne(s.shape[0],s.shape[1],o.shape[1],i);return e.runWebGLProgram(a,[s,o],"int32",[[s.shape[1]]])}};class Vne{constructor(t,e,r){let s,o;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<e.length;u++)c.push(`${a[u]}`),u<t&&l.push(`${a[u]}`);s=l.join(),o=c.join()}const i=ur(r);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}const zne={kernelName:h.Select,backendName:"webgl",kernelFunc:function Une(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:o}=t,i=new Vne(r.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(i,[r,s,o],(0,h.upcastType)(s.dtype,o.dtype))}},Wne=Gn({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${h.backend_util.SELU_SCALEALPHA};\n  float scale = ${h.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),jne={kernelName:h.Selu,backendName:"webgl",kernelFunc:Wne},Kne=Gn({opSnippet:xh+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:I9}),Xne={kernelName:h.Sigmoid,backendName:"webgl",kernelFunc:Kne},qne=Gn({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Zne={kernelName:h.Sign,backendName:"webgl",kernelFunc:qne},Jne=Gn({opSnippet:xh+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${zu}\n  return result;\n`}),ere={kernelName:h.Sin,backendName:"webgl",kernelFunc:Jne},tre=Gn({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),nre={kernelName:h.Sinh,backendName:"webgl",kernelFunc:tre},rre=Gn({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),sre={kernelName:h.Softplus,backendName:"webgl",kernelFunc:rre},ire={kernelName:h.SpaceToBatchND,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,paddings:i}=r;h.util.assert(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((D,N)=>D*N),l=[[0,0]];l.push(...i);for(let D=1+o.length;D<s.shape.length;++D)l.push([0,0]);const c=[],u=vM({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),d=h.backend_util.getReshaped(u.shape,o,a,!1),p=h.backend_util.getPermuted(d.length,o.length,!1),m=h.backend_util.getReshapedPermuted(u.shape,o,a,!1),y=Ot({inputs:{x:u},backend:e,attrs:{shape:d}}),_=yo({inputs:{x:y},backend:e,attrs:{perm:p}}),C=Ot({inputs:{x:_},backend:e,attrs:{shape:m}});return c.push(u),c.push(y),c.push(_),c.forEach(D=>e.disposeIntermediateTensorInfo(D)),C}},lre={kernelName:h.SparseFillEmptyRows,backendName:"webgl",kernelFunc:function are(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:o,defaultValue:i}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=e.readSync(r.dataId),l=e.readSync(s.dataId),c=e.readSync(o.dataId),u=e.readSync(i.dataId)[0],[d,p,m,y,_]=N9(a,r.shape,r.dtype,l,s.dtype,c,u);return[e.makeTensorInfo(p,r.dtype,d),e.makeTensorInfo([p[0]],s.dtype,m),e.makeTensorInfo([y.length],"bool",new Uint8Array(y.map(C=>Number(C)))),e.makeTensorInfo([_.length],r.dtype,new Int32Array(_))]}},ure={kernelName:h.SparseReshape,backendName:"webgl",kernelFunc:function cre(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:o}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(e.readSync(s.dataId)),a=e.readSync(r.dataId),l=Array.from(e.readSync(o.dataId)),[c,u,d]=k9(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(u,r.dtype,c),e.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}},hre={kernelName:h.SparseSegmentMean,backendName:"webgl",kernelFunc:function dre(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[c,u]=Dk(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(u,r.dtype,c)}},fre={kernelName:h.SparseSegmentSum,backendName:"webgl",kernelFunc:function pre(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[c,u]=Dk(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(u,r.dtype,c)}},gre={kernelName:h.SparseToDense,backendName:"webgl",kernelFunc:function mre(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:o,defaultValue:i}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:p}=h.backend_util.calculateShapes(o,s,a);if("string"===o.dtype){const D=e.bufferSync(s),N=e.bufferSync(o),W=h.util.decodeString(e.readSync(i.dataId)[0]),j=T9(D,N,a,p,u,c,l,d,W,!1);return e.makeTensorInfo(a,j.dtype,j.values)}const y=new aC(c,l,s.shape.length,o.shape.length,d,[p,1],!1),_=e.runWebGLProgram(y,[o,s,i],o.dtype),C=Ot({inputs:{x:_},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(_),C}},bre={kernelName:h.SplitV,backendName:"webgl",kernelFunc:function yre(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:o,axis:i}=r,a=h.util.parseAxisParam(i,s.shape)[0],l=h.backend_util.prepareSplitSize(s,o,a),u=new Array(s.shape.length).fill(0),d=s.shape.slice();return l.map(p=>{const m=[...d];m[a]=p;const y=Ch({inputs:{x:s},backend:e,attrs:{begin:u,size:m}});return u[a]+=p,y})}},CM="return sqrt(x);",_re=Gn({opSnippet:CM,packedOpSnippet:CM,cpuKernelImpl:M9}),vre={kernelName:h.Sqrt,backendName:"webgl",kernelFunc:_re},xre=Gn({opSnippet:"return x * x;"}),Cre={kernelName:h.Square,backendName:"webgl",kernelFunc:xre},wM="return (a - b) * (a - b);",wre=Rs({opSnippet:wM,packedOpSnippet:wM}),Sre={kernelName:h.SquaredDifference,backendName:"webgl",kernelFunc:wre},Dre={kernelName:h.StaticRegexReplace,backendName:"webgl",kernelFunc:function Ere(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const o=e.readSync(s.dataId),i=h.backend_util.fromUint8ToStringArray(o),a=R9(i,"string",r);return e.makeTensorInfo(s.shape,"string",a)}},Ire={kernelName:h.Step,backendName:"webgl",kernelFunc:function Tre({inputs:n,attrs:t,backend:e}){const{x:r}=n,o=new al(r.shape,_i+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(o,[r],r.dtype)}};class Are{constructor(t,e,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=ur(r.length),i=ur(r.length);let a="";if(1===s)a="coords * strides + begin";else{let l=0;a=r.map((c,u)=>(l++,1===r.length?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`\n      ${o} begin = ${o}(${t});\n      ${o} strides = ${o}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const kre={kernelName:h.StridedSlice,backendName:"webgl",kernelFunc:function Nre(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,end:i,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:p}=r,{finalShapeSparse:m,finalShape:y,isIdentity:_,sliceDim0:C,isSimpleSlice:D,begin:N,end:W,strides:j}=h.slice_util.sliceInfo(s.shape,o,i,a,l,c,u,d,p);let te;if(_)te=Ot({inputs:{x:s},backend:e,attrs:{shape:y}});else if(C||D){h.util.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const Ee=h.slice_util.computeOutShape(N,W,j),Ne=Ch({inputs:{x:s},backend:e,attrs:{begin:N,size:Ee}});te=Ot({inputs:{x:Ne},backend:e,attrs:{shape:y}}),e.disposeIntermediateTensorInfo(Ne)}else if(e.shouldExecuteOnCPU([s])){const Ne=e.readSync(s.dataId),je=(0,h.buffer)(s.shape,s.dtype,Ne),He=O9(m,je,j,N);te=e.makeTensorInfo(y,s.dtype,He.values)}else{const Ne=new Are(N,j,m);te=e.runWebGLProgram(Ne,[s],s.dtype)}const _e=Ot({inputs:{x:te},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(te),_e}},Rre={kernelName:h.StringNGrams,backendName:"webgl",kernelFunc:function Mre(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:d}=t,p=e.readSync(u.dataId),m=e.readSync(d.dataId),[y,_]=F9(p,m,s,o,i,a,l,c);return[e.makeTensorInfo([y.length],"string",y),e.makeTensorInfo(d.shape,"int32",_)]}},Fre={kernelName:h.StringSplit,backendName:"webgl",kernelFunc:function Ore(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:o,delimiter:i}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=e.readSync(o.dataId),l=e.readSync(i.dataId)[0],[c,u,d]=P9(a,l,s),p=u.length;return[e.makeTensorInfo([p,2],"int32",c),e.makeTensorInfo([p],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(d))]}},$re={kernelName:h.StringToHashBucketFast,backendName:"webgl",kernelFunc:function Pre(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=e.readSync(o.dataId),a=$9(i,s);return e.makeTensorInfo(o.shape,"int32",a)}},Lre=Gn({opSnippet:"return tan(x);"}),Bre={kernelName:h.Tan,backendName:"webgl",kernelFunc:Lre},Vre=Gn({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Ure={kernelName:h.Tanh,backendName:"webgl",kernelFunc:Vre},Hre={kernelName:h.TensorScatterUpdate,backendName:"webgl",kernelFunc:function zre(n){const{inputs:t,backend:e}=n,{tensor:s,indices:o,updates:i}=t,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=h.backend_util.calculateShapes(i,o,s.shape),p=[d/c,c];if(0===d)return e.makeTensorInfo(s.shape,o.dtype);const m=Ot({inputs:{x:o},backend:e,attrs:{shape:[l,a]}}),y=Ot({inputs:{x:i},backend:e,attrs:{shape:[l,c]}}),_=Ot({inputs:{x:s},backend:e,attrs:{shape:p}}),C=new aC(l,a,m.shape.length,y.shape.length,u,p,!1,!0),D=e.runWebGLProgram(C,[y,m,_],_.dtype),N=Ot({inputs:{x:D},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(D),N}};class Wre{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[i]*e[i];this.outputShape=r,this.rank=r.length;const s=ur(this.rank),o=function jre(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${e[s]}, ${n[s]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function SM(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:o}=r;if("string"===s.dtype||s.shape.length>5){const l=e.readSync(s.dataId),c="string"===s.dtype?l.map(p=>h.util.decodeString(p)):l,u=(0,h.buffer)(s.shape,s.dtype,c),d=B9(u,o);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new Wre(s.shape,o);return e.runWebGLProgram(i,[s],s.dtype)}const Gre={kernelName:h.Tile,backendName:"webgl",kernelFunc:SM};class Kre{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Xre{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Wu(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function EM(n){let t=1;for(;t<n;)t*=2;return t}const Zre={kernelName:h.TopK,backendName:"webgl",kernelFunc:function qre(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:o,sorted:i}=r,a=(0,h.env)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=(0,h.env)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,u=c[c.length-1];if(e.shouldExecuteOnCPU([s])||u<a||o>l){const He=e.readSync(s.dataId),[it,at]=V9(He,c,s.dtype,o,i);return[e.makeTensorInfo(it.shape,it.dtype,it.values),e.makeTensorInfo(at.shape,at.dtype,at.values)]}if(0===o)return c[c.length-1]=0,[e.makeTensorInfo(c,s.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(1===u)return[s,Tf({attrs:{shape:c,dtype:"int32",value:0},backend:e})];const d=e.texData.get(s.dataId),p=null!==d&&d.isPacked,m=p?e.unpackTensor(s):s,_=h.util.sizeFromShape(c)/u,C=Ot({inputs:{x:m},attrs:{shape:[_,u]},backend:e});p&&Wu(e,m);const D=EM(o),N=EM(u);let W=null;const j=()=>null===W?[C,C]:[C,W],te=(He,it,at)=>{const tt=j(),lt=new Kre(at),We=W;W=e.runWebGLProgram(lt,tt,"int32",[[u],[null===W?1:0],[Number.NEGATIVE_INFINITY],[He],[it]]),Wu(e,We)};for(let He=1;He<D;He*=2){const it=2*He;for(let at=He;at>=1;at/=2)te(it,at,[_,N])}for(let He=N;He>D;He/=2){const it=j(),at=new Xre([_,He/2]),st=W;W=e.runWebGLProgram(at,it,"int32",[[u],[null===W?1:0],[D]]),Wu(e,st);const Pe=D/2,We=2*Pe;for(let Ue=Pe;Ue>=1;Ue/=2)te(We,Ue,W.shape)}let _e=W;W=Ch({inputs:{x:W},backend:e,attrs:{begin:0,size:[_,o]}}),Wu(e,_e);let Ee=pM({inputs:{x:C,indices:W},backend:e,attrs:{axis:1,batchDims:1}});Wu(e,C);const Ne=c.slice(0,-1);Ne.push(o),_e=W,W=Ot({inputs:{x:W},attrs:{shape:Ne},backend:e}),Wu(e,_e);const je=Ee;return Ee=Ot({inputs:{x:Ee},attrs:{shape:Ne},backend:e}),Wu(e,je),[Ee,W]}};class Yre{constructor(t,e,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===r?1:2;let l;switch(s){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const Jre={kernelName:h.Transform,backendName:"webgl",kernelFunc:function Qre(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,transforms:o}=t,{interpolation:i,fillMode:a,fillValue:l,outputShape:c}=r,[u,d,p,m]=s.shape,[y,_]=c??[d,p],D=new Yre(d,p,i,a,l,[u,y,_,m]);return e.runWebGLProgram(D,[s,o],"float32")}},tse={kernelName:h.Unique,backendName:"webgl",kernelFunc:function ese(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:o}=t;vf(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:l,indices:c}=U9(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},rse={kernelName:h.Unpack,backendName:"webgl",kernelFunc:function nse(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,l=s.shape[o],c=new Array(a-1);let u=0;for(let _=0;_<a;_++)_!==o&&(c[u++]=i.shape[_]);const d=[],p=new Array(a).fill(0),m=i.shape.slice();m[o]=1;const y=new Array(l);for(let _=0;_<y.length;_++){p[o]=_;const C=Ch({inputs:{x:i},backend:e,attrs:{begin:p,size:m}}),D=Ot({inputs:{x:C},backend:e,attrs:{shape:c}});y[_]=D,d.push(C)}return d.forEach(_=>e.disposeIntermediateTensorInfo(_)),y}};class sse{constructor(t,e){this.variableNames=["x","segmentIds"];const r=t.windowSize,s=t.batchSize,o=t.inSize,i=t.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const u=4*Math.floor(r/4),d=r%4,p="\n        sumValue += dot(values, segFilter);\n    ";let m="";o%r>0&&(m=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let y="";o%r>0&&(y=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${m}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${y}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${p}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${p}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${p}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${p}\n        }\n        setOutput(sumValue);\n      }\n    `}}const ase=[OZ,PZ,BZ,zZ,WZ,KZ,qZ,YZ,tY,rY,iY,cY,hY,gY,_Y,xY,wY,TY,AY,kY,FY,zY,WY,GY,YY,JY,rQ,yZ,iQ,dQ,mQ,xQ,SQ,DQ,IQ,NQ,OQ,PQ,BQ,UQ,HQ,jQ,XQ,ZQ,eJ,nJ,oJ,lJ,uJ,hJ,gJ,bJ,xJ,wJ,SJ,DJ,IJ,NJ,MJ,OJ,PJ,BJ,zJ,WJ,KJ,ZJ,QJ,eee,gZ,nee,cQ,see,iee,lee,_Z,uee,hee,fee,yee,vee,Cee,See,Dee,Nee,Ree,Fee,Bee,Uee,Hee,Kee,qee,Yee,Jee,tte,ote,cte,pte,_te,CZ,wte,Dte,Ate,Mte,KY,Fte,$te,Bte,zte,Gte,xZ,Xte,Zte,Qte,ene,tne,XY,mte,rne,ine,cne,SZ,pne,gne,vne,wne,Tne,Ane,kne,Rne,Pne,Bne,zne,jne,Xne,Zne,ere,nre,VY,yte,sre,ire,lre,ure,hre,fre,gre,bre,vre,Cre,Sre,Dre,Ire,kre,Rre,Fre,$re,gte,kZ,Bre,Ure,Hre,Gre,Zre,Jre,MZ,tse,rse,{kernelName:h.UnsortedSegmentSum,backendName:"webgl",kernelFunc:function ose(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:o}=t,{numSegments:i}=r,a=s.shape.length,l=[];let c=0;const u=h.backend_util.getAxesPermutation([c],a);let d=s;null!=u&&(d=yo({inputs:{x:s},backend:e,attrs:{perm:u}}),l.push(d),c=h.backend_util.getInnerMostAxes(1,a)[0]);const p=h.backend_util.segment_util.computeOutShape(d.shape,c,i),m=h.util.sizeFromShape([d.shape[c]]),y=Ot({inputs:{x:d},backend:e,attrs:{shape:[-1,m]}});l.push(y);const _=(0,h.sumOutType)(s.dtype),C=(j,te,_e,Ee,Ne)=>{const je=j.shape[0],He=j.shape[1],it=h.backend_util.segment_util.segOpComputeOptimalWindowSize(He,Ne),tt=new sse({windowSize:it,inSize:He,batchSize:je,numSegments:Ne},te),lt=e.compileAndRun(tt,[j,_e],Ee);if(l.push(lt),lt.shape[1]===Ne)return lt;const st=xM({backend:e,attrs:{start:0,stop:Ne,step:1,dtype:"float32"}}),Pe=SM({inputs:{x:st},backend:e,attrs:{reps:[He/it]}});return l.push(st),l.push(Pe),C(lt,te,Pe,Ee,Ne)},N=Ot({inputs:{x:C(y,"unsortedSegmentSum",o,_,i)},backend:e,attrs:{shape:p}});let W=N;if(null!=u){l.push(N);const j=h.backend_util.getUndoAxesPermutation(u);W=yo({inputs:{x:W},backend:e,attrs:{perm:j}})}return l.forEach(j=>e.disposeIntermediateTensorInfo(j)),W}},Pte];for(const n of ase)(0,h.registerKernel)(n);function Oo(n){return null!=n&&"false"!=`${n}`}function DM(n,t=0){return function lse(n){return!isNaN(parseFloat(n))&&!isNaN(Number(n))}(n)?Number(n):t}function qy(n){return Array.isArray(n)?n:[n]}function hs(n){return null==n?"":"string"==typeof n?n:`${n}px`}function Sh(n){return n instanceof tr?n.nativeElement:n}const cse=["addListener","removeListener"],use=["addEventListener","removeEventListener"],dse=["on","off"];function ju(n,t,e,r){if(xe(e)&&(r=e,e=void 0),r)return ju(n,t,e).pipe(cx(r));const[s,o]=function fse(n){return xe(n.addEventListener)&&xe(n.removeEventListener)}(n)?use.map(i=>a=>n[i](t,a,e)):function hse(n){return xe(n.addListener)&&xe(n.removeListener)}(n)?cse.map(TM(n,t)):function pse(n){return xe(n.on)&&xe(n.off)}(n)?dse.map(TM(n,t)):[];if(!s&&Zi(n))return hr(i=>ju(i,t,e))(Dr(n));if(!s)throw new TypeError("Invalid event target");return new Me(i=>{const a=(...l)=>i.next(1<l.length?l:l[0]);return s(a),()=>o(a)})}function TM(n,t){return e=>r=>n[e](t,r)}class mse extends U{constructor(t,e){super()}schedule(t,e=0){return this}}const Zy={setInterval(n,t,...e){const{delegate:r}=Zy;return r?.setInterval?r.setInterval(n,t,...e):setInterval(n,t,...e)},clearInterval(n){const{delegate:t}=Zy;return(t?.clearInterval||clearInterval)(n)},delegate:void 0};class lC extends mse{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){var r;if(this.closed)return this;this.state=t;const s=this.id,o=this.scheduler;return null!=s&&(this.id=this.recycleAsyncId(o,s,e)),this.pending=!0,this.delay=e,this.id=null!==(r=this.id)&&void 0!==r?r:this.requestAsyncId(o,this.id,e),this}requestAsyncId(t,e,r=0){return Zy.setInterval(t.flush.bind(t,this),r)}recycleAsyncId(t,e,r=0){if(null!=r&&this.delay===r&&!1===this.pending)return e;null!=e&&Zy.clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const r=this._execute(t,e);if(r)return r;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let s,r=!1;try{this.work(t)}catch(o){r=!0,s=o||new Error("Scheduled action threw falsy error")}if(r)return this.unsubscribe(),s}unsubscribe(){if(!this.closed){const{id:t,scheduler:e}=this,{actions:r}=e;this.work=this.state=this.scheduler=null,this.pending=!1,P(r,this),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null,super.unsubscribe()}}}const If={schedule(n){let t=requestAnimationFrame,e=cancelAnimationFrame;const{delegate:r}=If;r&&(t=r.requestAnimationFrame,e=r.cancelAnimationFrame);const s=t(o=>{e=void 0,n(o)});return new U(()=>e?.(s))},requestAnimationFrame(...n){const{delegate:t}=If;return(t?.requestAnimationFrame||requestAnimationFrame)(...n)},cancelAnimationFrame(...n){const{delegate:t}=If;return(t?.cancelAnimationFrame||cancelAnimationFrame)(...n)},delegate:void 0},IM={now:()=>(IM.delegate||Date).now(),delegate:void 0};class Af{constructor(t,e=Af.now){this.schedulerActionCtor=t,this.now=e}schedule(t,e=0,r){return new this.schedulerActionCtor(this,t).schedule(r,e)}}Af.now=IM.now;class cC extends Af{constructor(t,e=Af.now){super(t,e),this.actions=[],this._active=!1}flush(t){const{actions:e}=this;if(this._active)return void e.push(t);let r;this._active=!0;do{if(r=t.execute(t.state,t.delay))break}while(t=e.shift());if(this._active=!1,r){for(;t=e.shift();)t.unsubscribe();throw r}}}new class yse extends cC{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class gse extends lC{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=If.requestAnimationFrame(()=>t.flush(void 0))))}recycleAsyncId(t,e,r=0){var s;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:o}=t;null!=e&&(null===(s=o[o.length-1])||void 0===s?void 0:s.id)!==e&&(If.cancelAnimationFrame(e),t._scheduled=void 0)}});let uC,_se=1;const Yy={};function AM(n){return n in Yy&&(delete Yy[n],!0)}const vse={setImmediate(n){const t=_se++;return Yy[t]=!0,uC||(uC=Promise.resolve()),uC.then(()=>AM(t)&&n()),t},clearImmediate(n){AM(n)}},{setImmediate:xse,clearImmediate:Cse}=vse,Qy={setImmediate(...n){const{delegate:t}=Qy;return(t?.setImmediate||xse)(...n)},clearImmediate(n){const{delegate:t}=Qy;return(t?.clearImmediate||Cse)(n)},delegate:void 0},Jy=(new class Sse extends cC{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class wse extends lC{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=Qy.setImmediate(t.flush.bind(t,void 0))))}recycleAsyncId(t,e,r=0){var s;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:o}=t;null!=e&&(null===(s=o[o.length-1])||void 0===s?void 0:s.id)!==e&&(Qy.clearImmediate(e),t._scheduled===e&&(t._scheduled=void 0))}}),new cC(lC)),Dse=Jy;function NM(n=0,t,e=Dse){let r=-1;return null!=t&&(Lo(t)?e=t:r=t),new Me(s=>{let o=function Ise(n){return n instanceof Date&&!isNaN(n)}(n)?+n-e.now():n;o<0&&(o=0);let i=0;return e.schedule(function(){s.closed||(s.next(i++),0<=r?this.schedule(void 0,r):s.complete())},o)})}function kM(n,t=Jy){return function Tse(n){return nn((t,e)=>{let r=!1,s=null,o=null,i=!1;const a=()=>{if(o?.unsubscribe(),o=null,r){r=!1;const c=s;s=null,e.next(c)}i&&e.complete()},l=()=>{o=null,i&&e.complete()};t.subscribe(Vt(e,c=>{r=!0,s=c,o||Dr(n(c)).subscribe(o=Vt(e,a,l))},()=>{i=!0,(!r||!o||o.closed)&&e.complete()}))})}(()=>NM(n,t))}function es(n){return nn((t,e)=>{Dr(n).subscribe(Vt(e,()=>e.complete(),se)),!e.closed&&t.subscribe(e)})}let dC;try{dC=typeof Intl<"u"&&Intl.v8BreakIterator}catch{dC=!1}let Nf,eb,Gu,hC,qs=(()=>{class n{constructor(e){this._platformId=e,this.isBrowser=this._platformId?Z0(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!dC)&&typeof CSS<"u"&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return n.\u0275fac=function(e){return new(e||n)(Ke(Ml))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function kf(n){return function Ase(){if(null==Nf&&typeof window<"u")try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>Nf=!0}))}finally{Nf=Nf||!1}return Nf}()?n:!!n.capture}function RM(){if(null==Gu){if("object"!=typeof document||!document||"function"!=typeof Element||!Element)return Gu=!1,Gu;if("scrollBehavior"in document.documentElement.style)Gu=!0;else{const n=Element.prototype.scrollTo;Gu=!!n&&!/\{\s*\[native code\]\s*\}/.test(n.toString())}}return Gu}function Mf(){if("object"!=typeof document||!document)return 0;if(null==eb){const n=document.createElement("div"),t=n.style;n.dir="rtl",t.width="1px",t.overflow="auto",t.visibility="hidden",t.pointerEvents="none",t.position="absolute";const e=document.createElement("div"),r=e.style;r.width="2px",r.height="1px",n.appendChild(e),document.body.appendChild(n),eb=0,0===n.scrollLeft&&(n.scrollLeft=1,eb=0===n.scrollLeft?1:2),n.remove()}return eb}function pC(){let n=typeof document<"u"&&document?document.activeElement:null;for(;n&&n.shadowRoot;){const t=n.shadowRoot.activeElement;if(t===n)break;n=t}return n}function zc(n){return n.composedPath?n.composedPath()[0]:n.target}function fC(){return typeof __karma__<"u"&&!!__karma__||typeof jasmine<"u"&&!!jasmine||typeof jest<"u"&&!!jest||typeof Mocha<"u"&&!!Mocha}const Mse=new Ct("cdk-dir-doc",{providedIn:"root",factory:function Rse(){return Ft(kn)}}),Ose=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;let Dh=(()=>{class n{constructor(e){this.value="ltr",this.change=new nr,e&&(this.value=function Fse(n){const t=n?.toLowerCase()||"";return"auto"===t&&typeof navigator<"u"&&navigator?.language?Ose.test(navigator.language)?"rtl":"ltr":"rtl"===t?"rtl":"ltr"}((e.body?e.body.dir:null)||(e.documentElement?e.documentElement.dir:null)||"ltr"))}ngOnDestroy(){this.change.complete()}}return n.\u0275fac=function(e){return new(e||n)(Ke(Mse,8))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Rf=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({}),n})(),tb=(()=>{class n{constructor(e,r,s){this._ngZone=e,this._platform=r,this._scrolled=new et,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=s}register(e){this.scrollContainers.has(e)||this.scrollContainers.set(e,e.elementScrolled().subscribe(()=>this._scrolled.next(e)))}deregister(e){const r=this.scrollContainers.get(e);r&&(r.unsubscribe(),this.scrollContainers.delete(e))}scrolled(e=20){return this._platform.isBrowser?new Me(r=>{this._globalSubscription||this._addGlobalListener();const s=e>0?this._scrolled.pipe(kM(e)).subscribe(r):this._scrolled.subscribe(r);return this._scrolledCount++,()=>{s.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):sn()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((e,r)=>this.deregister(r)),this._scrolled.complete()}ancestorScrolled(e,r){const s=this.getAncestorScrollContainers(e);return this.scrolled(r).pipe(Or(o=>!o||s.indexOf(o)>-1))}getAncestorScrollContainers(e){const r=[];return this.scrollContainers.forEach((s,o)=>{this._scrollableContainsElement(o,e)&&r.push(o)}),r}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(e,r){let s=Sh(r),o=e.getElementRef().nativeElement;do{if(s==o)return!0}while(s=s.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>ju(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return n.\u0275fac=function(e){return new(e||n)(Ke(wn),Ke(qs),Ke(kn,8))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),mC=(()=>{class n{constructor(e,r,s,o){this.elementRef=e,this.scrollDispatcher=r,this.ngZone=s,this.dir=o,this._destroyed=new et,this._elementScrolled=new Me(i=>this.ngZone.runOutsideAngular(()=>ju(this.elementRef.nativeElement,"scroll").pipe(es(this._destroyed)).subscribe(i)))}ngOnInit(){this.scrollDispatcher.register(this)}ngOnDestroy(){this.scrollDispatcher.deregister(this),this._destroyed.next(),this._destroyed.complete()}elementScrolled(){return this._elementScrolled}getElementRef(){return this.elementRef}scrollTo(e){const r=this.elementRef.nativeElement,s=this.dir&&"rtl"==this.dir.value;null==e.left&&(e.left=s?e.end:e.start),null==e.right&&(e.right=s?e.start:e.end),null!=e.bottom&&(e.top=r.scrollHeight-r.clientHeight-e.bottom),s&&0!=Mf()?(null!=e.left&&(e.right=r.scrollWidth-r.clientWidth-e.left),2==Mf()?e.left=e.right:1==Mf()&&(e.left=e.right?-e.right:e.right)):null!=e.right&&(e.left=r.scrollWidth-r.clientWidth-e.right),this._applyScrollToOptions(e)}_applyScrollToOptions(e){const r=this.elementRef.nativeElement;RM()?r.scrollTo(e):(null!=e.top&&(r.scrollTop=e.top),null!=e.left&&(r.scrollLeft=e.left))}measureScrollOffset(e){const r="left",s="right",o=this.elementRef.nativeElement;if("top"==e)return o.scrollTop;if("bottom"==e)return o.scrollHeight-o.clientHeight-o.scrollTop;const i=this.dir&&"rtl"==this.dir.value;return"start"==e?e=i?s:r:"end"==e&&(e=i?r:s),i&&2==Mf()?e==r?o.scrollWidth-o.clientWidth-o.scrollLeft:o.scrollLeft:i&&1==Mf()?e==r?o.scrollLeft+o.scrollWidth-o.clientWidth:-o.scrollLeft:e==r?o.scrollLeft:o.scrollWidth-o.clientWidth-o.scrollLeft}}return n.\u0275fac=function(e){return new(e||n)(Ve(tr),Ve(tb),Ve(wn),Ve(Dh,8))},n.\u0275dir=It({type:n,selectors:[["","cdk-scrollable",""],["","cdkScrollable",""]],standalone:!0}),n})(),gC=(()=>{class n{constructor(e,r,s){this._platform=e,this._change=new et,this._changeListener=o=>{this._change.next(o)},this._document=s,r.runOutsideAngular(()=>{if(e.isBrowser){const o=this._getWindow();o.addEventListener("resize",this._changeListener),o.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._viewportSize=null)})}ngOnDestroy(){if(this._platform.isBrowser){const e=this._getWindow();e.removeEventListener("resize",this._changeListener),e.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const e={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),e}getViewportRect(){const e=this.getViewportScrollPosition(),{width:r,height:s}=this.getViewportSize();return{top:e.top,left:e.left,bottom:e.top+s,right:e.left+r,height:s,width:r}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const e=this._document,r=this._getWindow(),s=e.documentElement,o=s.getBoundingClientRect();return{top:-o.top||e.body.scrollTop||r.scrollY||s.scrollTop||0,left:-o.left||e.body.scrollLeft||r.scrollX||s.scrollLeft||0}}change(e=20){return e>0?this._change.pipe(kM(e)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const e=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:e.innerWidth,height:e.innerHeight}:{width:0,height:0}}}return n.\u0275fac=function(e){return new(e||n)(Ke(qs),Ke(wn),Ke(kn,8))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Of=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({}),n})(),OM=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({imports:[Rf,Of,Rf,Of]}),n})();function bC(n,...t){return t.length?t.some(e=>n[e]):n.altKey||n.shiftKey||n.ctrlKey||n.metaKey}function FM(n){return Or((t,e)=>n<=e)}function PM(n,t=ze){return n=n??Hse,nn((e,r)=>{let s,o=!0;e.subscribe(Vt(r,i=>{const a=t(i);(o||!n(s,a))&&(o=!1,s=a,r.next(i))}))})}function Hse(n,t){return n===t}let Wse=(()=>{class n{create(e){return typeof MutationObserver>"u"?null:new MutationObserver(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),jse=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({providers:[Wse]}),n})();function $M(n,t=Jy){return nn((e,r)=>{let s=null,o=null,i=null;const a=()=>{if(s){s.unsubscribe(),s=null;const c=o;o=null,r.next(c)}};function l(){const c=i+n,u=t.now();if(u<c)return s=this.schedule(void 0,c-u),void r.add(s);a()}e.subscribe(Vt(r,c=>{o=c,i=t.now(),s||(s=t.schedule(l,n),r.add(s))},()=>{a(),r.complete()},void 0,()=>{o=s=null}))})}const LM=new Set;let Ku,Gse=(()=>{class n{constructor(e,r){this._platform=e,this._nonce=r,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):Xse}matchMedia(e){return(this._platform.WEBKIT||this._platform.BLINK)&&function Kse(n,t){if(!LM.has(n))try{Ku||(Ku=document.createElement("style"),t&&(Ku.nonce=t),Ku.setAttribute("type","text/css"),document.head.appendChild(Ku)),Ku.sheet&&(Ku.sheet.insertRule(`@media ${n} {body{ }}`,0),LM.add(n))}catch(e){console.error(e)}}(e,this._nonce),this._matchMedia(e)}}return n.\u0275fac=function(e){return new(e||n)(Ke(qs),Ke(nv,8))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function Xse(n){return{matches:"all"===n||""===n,media:n,addListener:()=>{},removeListener:()=>{}}}let qse=(()=>{class n{constructor(e,r){this._mediaMatcher=e,this._zone=r,this._queries=new Map,this._destroySubject=new et}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(e){return BM(qy(e)).some(s=>this._registerQuery(s).mql.matches)}observe(e){let o=ry(BM(qy(e)).map(i=>this._registerQuery(i).observable));return o=eh(o.pipe(Jr(1)),o.pipe(FM(1),$M(0))),o.pipe(gt(i=>{const a={matches:!1,breakpoints:{}};return i.forEach(({matches:l,query:c})=>{a.matches=a.matches||l,a.breakpoints[c]=l}),a}))}_registerQuery(e){if(this._queries.has(e))return this._queries.get(e);const r=this._mediaMatcher.matchMedia(e),o={observable:new Me(i=>{const a=l=>this._zone.run(()=>i.next(l));return r.addListener(a),()=>{r.removeListener(a)}}).pipe(Jp(r),gt(({matches:i})=>({query:e,matches:i})),es(this._destroySubject)),mql:r};return this._queries.set(e,o),o}}return n.\u0275fac=function(e){return new(e||n)(Ke(Gse),Ke(wn))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function BM(n){return n.map(t=>t.split(",")).reduce((t,e)=>t.concat(e)).map(t=>t.trim())}function nb(n,t){return(n.getAttribute(t)||"").match(/\S+/g)||[]}const UM="cdk-describedby-message",rb="cdk-describedby-host";let _C=0,Qse=(()=>{class n{constructor(e,r){this._platform=r,this._messageRegistry=new Map,this._messagesContainer=null,this._id=""+_C++,this._document=e,this._id=Ft(wp)+"-"+_C++}describe(e,r,s){if(!this._canBeDescribed(e,r))return;const o=vC(r,s);"string"!=typeof r?(zM(r,this._id),this._messageRegistry.set(o,{messageElement:r,referenceCount:0})):this._messageRegistry.has(o)||this._createMessageElement(r,s),this._isElementDescribedByMessage(e,o)||this._addMessageReference(e,o)}removeDescription(e,r,s){if(!r||!this._isElementNode(e))return;const o=vC(r,s);if(this._isElementDescribedByMessage(e,o)&&this._removeMessageReference(e,o),"string"==typeof r){const i=this._messageRegistry.get(o);i&&0===i.referenceCount&&this._deleteMessageElement(o)}0===this._messagesContainer?.childNodes.length&&(this._messagesContainer.remove(),this._messagesContainer=null)}ngOnDestroy(){const e=this._document.querySelectorAll(`[${rb}="${this._id}"]`);for(let r=0;r<e.length;r++)this._removeCdkDescribedByReferenceIds(e[r]),e[r].removeAttribute(rb);this._messagesContainer?.remove(),this._messagesContainer=null,this._messageRegistry.clear()}_createMessageElement(e,r){const s=this._document.createElement("div");zM(s,this._id),s.textContent=e,r&&s.setAttribute("role",r),this._createMessagesContainer(),this._messagesContainer.appendChild(s),this._messageRegistry.set(vC(e,r),{messageElement:s,referenceCount:0})}_deleteMessageElement(e){this._messageRegistry.get(e)?.messageElement?.remove(),this._messageRegistry.delete(e)}_createMessagesContainer(){if(this._messagesContainer)return;const e="cdk-describedby-message-container",r=this._document.querySelectorAll(`.${e}[platform="server"]`);for(let o=0;o<r.length;o++)r[o].remove();const s=this._document.createElement("div");s.style.visibility="hidden",s.classList.add(e),s.classList.add("cdk-visually-hidden"),this._platform&&!this._platform.isBrowser&&s.setAttribute("platform","server"),this._document.body.appendChild(s),this._messagesContainer=s}_removeCdkDescribedByReferenceIds(e){const r=nb(e,"aria-describedby").filter(s=>0!=s.indexOf(UM));e.setAttribute("aria-describedby",r.join(" "))}_addMessageReference(e,r){const s=this._messageRegistry.get(r);(function Zse(n,t,e){const r=nb(n,t);r.some(s=>s.trim()==e.trim())||(r.push(e.trim()),n.setAttribute(t,r.join(" ")))})(e,"aria-describedby",s.messageElement.id),e.setAttribute(rb,this._id),s.referenceCount++}_removeMessageReference(e,r){const s=this._messageRegistry.get(r);s.referenceCount--,function Yse(n,t,e){const s=nb(n,t).filter(o=>o!=e.trim());s.length?n.setAttribute(t,s.join(" ")):n.removeAttribute(t)}(e,"aria-describedby",s.messageElement.id),e.removeAttribute(rb)}_isElementDescribedByMessage(e,r){const s=nb(e,"aria-describedby"),o=this._messageRegistry.get(r),i=o&&o.messageElement.id;return!!i&&-1!=s.indexOf(i)}_canBeDescribed(e,r){if(!this._isElementNode(e))return!1;if(r&&"object"==typeof r)return!0;const s=null==r?"":`${r}`.trim(),o=e.getAttribute("aria-label");return!(!s||o&&o.trim()===s)}_isElementNode(e){return e.nodeType===this._document.ELEMENT_NODE}}return n.\u0275fac=function(e){return new(e||n)(Ke(kn),Ke(qs))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function vC(n,t){return"string"==typeof n?`${t||""}/${n}`:n}function zM(n,t){n.id||(n.id=`${UM}-${t}-${_C++}`)}let xC=(()=>{class n{constructor(e){this._platform=e}isDisabled(e){return e.hasAttribute("disabled")}isVisible(e){return function eoe(n){return!!(n.offsetWidth||n.offsetHeight||"function"==typeof n.getClientRects&&n.getClientRects().length)}(e)&&"visible"===getComputedStyle(e).visibility}isTabbable(e){if(!this._platform.isBrowser)return!1;const r=function Jse(n){try{return n.frameElement}catch{return null}}(function loe(n){return n.ownerDocument&&n.ownerDocument.defaultView||window}(e));if(r&&(-1===WM(r)||!this.isVisible(r)))return!1;let s=e.nodeName.toLowerCase(),o=WM(e);return e.hasAttribute("contenteditable")?-1!==o:!("iframe"===s||"object"===s||this._platform.WEBKIT&&this._platform.IOS&&!function ioe(n){let t=n.nodeName.toLowerCase(),e="input"===t&&n.type;return"text"===e||"password"===e||"select"===t||"textarea"===t}(e))&&("audio"===s?!!e.hasAttribute("controls")&&-1!==o:"video"===s?-1!==o&&(null!==o||this._platform.FIREFOX||e.hasAttribute("controls")):e.tabIndex>=0)}isFocusable(e,r){return function aoe(n){return!function noe(n){return function soe(n){return"input"==n.nodeName.toLowerCase()}(n)&&"hidden"==n.type}(n)&&(function toe(n){let t=n.nodeName.toLowerCase();return"input"===t||"select"===t||"button"===t||"textarea"===t}(n)||function roe(n){return function ooe(n){return"a"==n.nodeName.toLowerCase()}(n)&&n.hasAttribute("href")}(n)||n.hasAttribute("contenteditable")||HM(n))}(e)&&!this.isDisabled(e)&&(r?.ignoreVisibility||this.isVisible(e))}}return n.\u0275fac=function(e){return new(e||n)(Ke(qs))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function HM(n){if(!n.hasAttribute("tabindex")||void 0===n.tabIndex)return!1;let t=n.getAttribute("tabindex");return!(!t||isNaN(parseInt(t,10)))}function WM(n){if(!HM(n))return null;const t=parseInt(n.getAttribute("tabindex")||"",10);return isNaN(t)?-1:t}class coe{get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}constructor(t,e,r,s,o=!1){this._element=t,this._checker=e,this._ngZone=r,this._document=s,this._hasAttached=!1,this.startAnchorListener=()=>this.focusLastTabbableElement(),this.endAnchorListener=()=>this.focusFirstTabbableElement(),this._enabled=!0,o||this.attachAnchors()}destroy(){const t=this._startAnchor,e=this._endAnchor;t&&(t.removeEventListener("focus",this.startAnchorListener),t.remove()),e&&(e.removeEventListener("focus",this.endAnchorListener),e.remove()),this._startAnchor=this._endAnchor=null,this._hasAttached=!1}attachAnchors(){return!!this._hasAttached||(this._ngZone.runOutsideAngular(()=>{this._startAnchor||(this._startAnchor=this._createAnchor(),this._startAnchor.addEventListener("focus",this.startAnchorListener)),this._endAnchor||(this._endAnchor=this._createAnchor(),this._endAnchor.addEventListener("focus",this.endAnchorListener))}),this._element.parentNode&&(this._element.parentNode.insertBefore(this._startAnchor,this._element),this._element.parentNode.insertBefore(this._endAnchor,this._element.nextSibling),this._hasAttached=!0),this._hasAttached)}focusInitialElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusInitialElement(t)))})}focusFirstTabbableElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusFirstTabbableElement(t)))})}focusLastTabbableElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusLastTabbableElement(t)))})}_getRegionBoundary(t){const e=this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);return"start"==t?e.length?e[0]:this._getFirstTabbableElement(this._element):e.length?e[e.length-1]:this._getLastTabbableElement(this._element)}focusInitialElement(t){const e=this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");if(e){if(!this._checker.isFocusable(e)){const r=this._getFirstTabbableElement(e);return r?.focus(t),!!r}return e.focus(t),!0}return this.focusFirstTabbableElement(t)}focusFirstTabbableElement(t){const e=this._getRegionBoundary("start");return e&&e.focus(t),!!e}focusLastTabbableElement(t){const e=this._getRegionBoundary("end");return e&&e.focus(t),!!e}hasAttached(){return this._hasAttached}_getFirstTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;const e=t.children;for(let r=0;r<e.length;r++){const s=e[r].nodeType===this._document.ELEMENT_NODE?this._getFirstTabbableElement(e[r]):null;if(s)return s}return null}_getLastTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;const e=t.children;for(let r=e.length-1;r>=0;r--){const s=e[r].nodeType===this._document.ELEMENT_NODE?this._getLastTabbableElement(e[r]):null;if(s)return s}return null}_createAnchor(){const t=this._document.createElement("div");return this._toggleAnchorTabIndex(this._enabled,t),t.classList.add("cdk-visually-hidden"),t.classList.add("cdk-focus-trap-anchor"),t.setAttribute("aria-hidden","true"),t}_toggleAnchorTabIndex(t,e){t?e.setAttribute("tabindex","0"):e.removeAttribute("tabindex")}toggleAnchors(t){this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}_executeOnStable(t){this._ngZone.isStable?t():this._ngZone.onStable.pipe(Jr(1)).subscribe(t)}}let jM=(()=>{class n{constructor(e,r,s){this._checker=e,this._ngZone=r,this._document=s}create(e,r=!1){return new coe(e,this._checker,this._ngZone,this._document,r)}}return n.\u0275fac=function(e){return new(e||n)(Ke(xC),Ke(wn),Ke(kn))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function GM(n){return 0===n.buttons||0===n.offsetX&&0===n.offsetY}function KM(n){const t=n.touches&&n.touches[0]||n.changedTouches&&n.changedTouches[0];return!(!t||-1!==t.identifier||null!=t.radiusX&&1!==t.radiusX||null!=t.radiusY&&1!==t.radiusY)}const uoe=new Ct("cdk-input-modality-detector-options"),doe={ignoreKeys:[18,17,224,91,16]},Th=kf({passive:!0,capture:!0});let hoe=(()=>{class n{get mostRecentModality(){return this._modality.value}constructor(e,r,s,o){this._platform=e,this._mostRecentTarget=null,this._modality=new Vi(null),this._lastTouchMs=0,this._onKeydown=i=>{this._options?.ignoreKeys?.some(a=>a===i.keyCode)||(this._modality.next("keyboard"),this._mostRecentTarget=zc(i))},this._onMousedown=i=>{Date.now()-this._lastTouchMs<650||(this._modality.next(GM(i)?"keyboard":"mouse"),this._mostRecentTarget=zc(i))},this._onTouchstart=i=>{KM(i)?this._modality.next("keyboard"):(this._lastTouchMs=Date.now(),this._modality.next("touch"),this._mostRecentTarget=zc(i))},this._options={...doe,...o},this.modalityDetected=this._modality.pipe(FM(1)),this.modalityChanged=this.modalityDetected.pipe(PM()),e.isBrowser&&r.runOutsideAngular(()=>{s.addEventListener("keydown",this._onKeydown,Th),s.addEventListener("mousedown",this._onMousedown,Th),s.addEventListener("touchstart",this._onTouchstart,Th)})}ngOnDestroy(){this._modality.complete(),this._platform.isBrowser&&(document.removeEventListener("keydown",this._onKeydown,Th),document.removeEventListener("mousedown",this._onMousedown,Th),document.removeEventListener("touchstart",this._onTouchstart,Th))}}return n.\u0275fac=function(e){return new(e||n)(Ke(qs),Ke(wn),Ke(kn),Ke(uoe,8))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const foe=new Ct("cdk-focus-monitor-default-options"),sb=kf({passive:!0,capture:!0});let Ff=(()=>{class n{constructor(e,r,s,o,i){this._ngZone=e,this._platform=r,this._inputModalityDetector=s,this._origin=null,this._windowFocused=!1,this._originFromTouchInteraction=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=window.setTimeout(()=>this._windowFocused=!1)},this._stopInputModalityDetector=new et,this._rootNodeFocusAndBlurListener=a=>{for(let c=zc(a);c;c=c.parentElement)"focus"===a.type?this._onFocus(a,c):this._onBlur(a,c)},this._document=o,this._detectionMode=i?.detectionMode||0}monitor(e,r=!1){const s=Sh(e);if(!this._platform.isBrowser||1!==s.nodeType)return sn(null);const o=function kse(n){if(function Nse(){if(null==hC){const n=typeof document<"u"?document.head:null;hC=!(!n||!n.createShadowRoot&&!n.attachShadow)}return hC}()){const t=n.getRootNode?n.getRootNode():null;if(typeof ShadowRoot<"u"&&ShadowRoot&&t instanceof ShadowRoot)return t}return null}(s)||this._getDocument(),i=this._elementInfo.get(s);if(i)return r&&(i.checkChildren=!0),i.subject;const a={checkChildren:r,subject:new et,rootNode:o};return this._elementInfo.set(s,a),this._registerGlobalListeners(a),a.subject}stopMonitoring(e){const r=Sh(e),s=this._elementInfo.get(r);s&&(s.subject.complete(),this._setClasses(r),this._elementInfo.delete(r),this._removeGlobalListeners(s))}focusVia(e,r,s){const o=Sh(e);o===this._getDocument().activeElement?this._getClosestElementsInfo(o).forEach(([a,l])=>this._originChanged(a,r,l)):(this._setOrigin(r),"function"==typeof o.focus&&o.focus(s))}ngOnDestroy(){this._elementInfo.forEach((e,r)=>this.stopMonitoring(r))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_getFocusOrigin(e){return this._origin?this._originFromTouchInteraction?this._shouldBeAttributedToTouch(e)?"touch":"program":this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:e&&this._isLastInteractionFromInputLabel(e)?"mouse":"program"}_shouldBeAttributedToTouch(e){return 1===this._detectionMode||!!e?.contains(this._inputModalityDetector._mostRecentTarget)}_setClasses(e,r){e.classList.toggle("cdk-focused",!!r),e.classList.toggle("cdk-touch-focused","touch"===r),e.classList.toggle("cdk-keyboard-focused","keyboard"===r),e.classList.toggle("cdk-mouse-focused","mouse"===r),e.classList.toggle("cdk-program-focused","program"===r)}_setOrigin(e,r=!1){this._ngZone.runOutsideAngular(()=>{this._origin=e,this._originFromTouchInteraction="touch"===e&&r,0===this._detectionMode&&(clearTimeout(this._originTimeoutId),this._originTimeoutId=setTimeout(()=>this._origin=null,this._originFromTouchInteraction?650:1))})}_onFocus(e,r){const s=this._elementInfo.get(r),o=zc(e);!s||!s.checkChildren&&r!==o||this._originChanged(r,this._getFocusOrigin(o),s)}_onBlur(e,r){const s=this._elementInfo.get(r);!s||s.checkChildren&&e.relatedTarget instanceof Node&&r.contains(e.relatedTarget)||(this._setClasses(r),this._emitOrigin(s,null))}_emitOrigin(e,r){e.subject.observers.length&&this._ngZone.run(()=>e.subject.next(r))}_registerGlobalListeners(e){if(!this._platform.isBrowser)return;const r=e.rootNode,s=this._rootNodeFocusListenerCount.get(r)||0;s||this._ngZone.runOutsideAngular(()=>{r.addEventListener("focus",this._rootNodeFocusAndBlurListener,sb),r.addEventListener("blur",this._rootNodeFocusAndBlurListener,sb)}),this._rootNodeFocusListenerCount.set(r,s+1),1==++this._monitoredElementCount&&(this._ngZone.runOutsideAngular(()=>{this._getWindow().addEventListener("focus",this._windowFocusListener)}),this._inputModalityDetector.modalityDetected.pipe(es(this._stopInputModalityDetector)).subscribe(o=>{this._setOrigin(o,!0)}))}_removeGlobalListeners(e){const r=e.rootNode;if(this._rootNodeFocusListenerCount.has(r)){const s=this._rootNodeFocusListenerCount.get(r);s>1?this._rootNodeFocusListenerCount.set(r,s-1):(r.removeEventListener("focus",this._rootNodeFocusAndBlurListener,sb),r.removeEventListener("blur",this._rootNodeFocusAndBlurListener,sb),this._rootNodeFocusListenerCount.delete(r))}--this._monitoredElementCount||(this._getWindow().removeEventListener("focus",this._windowFocusListener),this._stopInputModalityDetector.next(),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._originTimeoutId))}_originChanged(e,r,s){this._setClasses(e,r),this._emitOrigin(s,r),this._lastFocusOrigin=r}_getClosestElementsInfo(e){const r=[];return this._elementInfo.forEach((s,o)=>{(o===e||s.checkChildren&&o.contains(e))&&r.push([o,s])}),r}_isLastInteractionFromInputLabel(e){const{_mostRecentTarget:r,mostRecentModality:s}=this._inputModalityDetector;if("mouse"!==s||!r||r===e||"INPUT"!==e.nodeName&&"TEXTAREA"!==e.nodeName||e.disabled)return!1;const o=e.labels;if(o)for(let i=0;i<o.length;i++)if(o[i].contains(r))return!0;return!1}}return n.\u0275fac=function(e){return new(e||n)(Ke(wn),Ke(qs),Ke(hoe),Ke(kn,8),Ke(foe,8))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const qM="cdk-high-contrast-black-on-white",ZM="cdk-high-contrast-white-on-black",CC="cdk-high-contrast-active";let YM=(()=>{class n{constructor(e,r){this._platform=e,this._document=r,this._breakpointSubscription=Ft(qse).observe("(forced-colors: active)").subscribe(()=>{this._hasCheckedHighContrastMode&&(this._hasCheckedHighContrastMode=!1,this._applyBodyHighContrastModeCssClasses())})}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const e=this._document.createElement("div");e.style.backgroundColor="rgb(1,2,3)",e.style.position="absolute",this._document.body.appendChild(e);const r=this._document.defaultView||window,s=r&&r.getComputedStyle?r.getComputedStyle(e):null,o=(s&&s.backgroundColor||"").replace(/ /g,"");switch(e.remove(),o){case"rgb(0,0,0)":case"rgb(45,50,54)":case"rgb(32,32,32)":return 2;case"rgb(255,255,255)":case"rgb(255,250,239)":return 1}return 0}ngOnDestroy(){this._breakpointSubscription.unsubscribe()}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&&this._platform.isBrowser&&this._document.body){const e=this._document.body.classList;e.remove(CC,qM,ZM),this._hasCheckedHighContrastMode=!0;const r=this.getHighContrastMode();1===r?e.add(CC,qM):2===r&&e.add(CC,ZM)}}}return n.\u0275fac=function(e){return new(e||n)(Ke(qs),Ke(kn))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),QM=(()=>{class n{constructor(e){e._applyBodyHighContrastModeCssClasses()}}return n.\u0275fac=function(e){return new(e||n)(Ke(YM))},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({imports:[jse]}),n})();const goe=new Ct("mat-sanity-checks",{providedIn:"root",factory:function moe(){return!0}});let Os=(()=>{class n{constructor(e,r,s){this._sanityChecks=r,this._document=s,this._hasDoneGlobalChecks=!1,e._applyBodyHighContrastModeCssClasses(),this._hasDoneGlobalChecks||(this._hasDoneGlobalChecks=!0)}_checkIsEnabled(e){return!fC()&&("boolean"==typeof this._sanityChecks?this._sanityChecks:!!this._sanityChecks[e])}}return n.\u0275fac=function(e){return new(e||n)(Ke(YM),Ke(goe,8),Ke(kn))},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({imports:[Rf,Rf]}),n})();function yoe(n){return class extends n{get disabled(){return this._disabled}set disabled(t){this._disabled=Oo(t)}constructor(...t){super(...t),this._disabled=!1}}}function wC(n,t){return class extends n{get color(){return this._color}set color(e){const r=e||this.defaultColor;r!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),r&&this._elementRef.nativeElement.classList.add(`mat-${r}`),this._color=r)}constructor(...e){super(...e),this.defaultColor=t,this.color=t}}}function rR(n){return class extends n{get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=Oo(t)}constructor(...t){super(...t),this._disableRipple=!1}}}class _oe{constructor(t,e,r,s=!1){this._renderer=t,this.element=e,this.config=r,this._animationForciblyDisabledThroughCss=s,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const sR=kf({passive:!0,capture:!0});class voe{constructor(){this._events=new Map,this._delegateEventHandler=t=>{const e=zc(t);e&&this._events.get(t.type)?.forEach((r,s)=>{(s===e||s.contains(e))&&r.forEach(o=>o.handleEvent(t))})}}addHandler(t,e,r,s){const o=this._events.get(e);if(o){const i=o.get(r);i?i.add(s):o.set(r,new Set([s]))}else this._events.set(e,new Map([[r,new Set([s])]])),t.runOutsideAngular(()=>{document.addEventListener(e,this._delegateEventHandler,sR)})}removeHandler(t,e,r){const s=this._events.get(t);if(!s)return;const o=s.get(e);o&&(o.delete(r),0===o.size&&s.delete(e),0===s.size&&(this._events.delete(t),document.removeEventListener(t,this._delegateEventHandler,sR)))}}const oR={enterDuration:225,exitDuration:150},iR=kf({passive:!0,capture:!0}),aR=["mousedown","touchstart"],lR=["mouseup","mouseleave","touchend","touchcancel"];class Ih{constructor(t,e,r,s){this._target=t,this._ngZone=e,this._platform=s,this._isPointerDown=!1,this._activeRipples=new Map,this._pointerUpEventsRegistered=!1,s.isBrowser&&(this._containerElement=Sh(r))}fadeInRipple(t,e,r={}){const s=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),o={...oR,...r.animation};r.centered&&(t=s.left+s.width/2,e=s.top+s.height/2);const i=r.radius||function Coe(n,t,e){const r=Math.max(Math.abs(n-e.left),Math.abs(n-e.right)),s=Math.max(Math.abs(t-e.top),Math.abs(t-e.bottom));return Math.sqrt(r*r+s*s)}(t,e,s),a=t-s.left,l=e-s.top,c=o.enterDuration,u=document.createElement("div");u.classList.add("mat-ripple-element"),u.style.left=a-i+"px",u.style.top=l-i+"px",u.style.height=2*i+"px",u.style.width=2*i+"px",null!=r.color&&(u.style.backgroundColor=r.color),u.style.transitionDuration=`${c}ms`,this._containerElement.appendChild(u);const d=window.getComputedStyle(u),m=d.transitionDuration,y="none"===d.transitionProperty||"0s"===m||"0s, 0s"===m||0===s.width&&0===s.height,_=new _oe(this,u,r,y);u.style.transform="scale3d(1, 1, 1)",_.state=0,r.persistent||(this._mostRecentTransientRipple=_);let C=null;return!y&&(c||o.exitDuration)&&this._ngZone.runOutsideAngular(()=>{const D=()=>this._finishRippleTransition(_),N=()=>this._destroyRipple(_);u.addEventListener("transitionend",D),u.addEventListener("transitioncancel",N),C={onTransitionEnd:D,onTransitionCancel:N}}),this._activeRipples.set(_,C),(y||!c)&&this._finishRippleTransition(_),_}fadeOutRipple(t){if(2===t.state||3===t.state)return;const e=t.element,r={...oR,...t.config.animation};e.style.transitionDuration=`${r.exitDuration}ms`,e.style.opacity="0",t.state=2,(t._animationForciblyDisabledThroughCss||!r.exitDuration)&&this._finishRippleTransition(t)}fadeOutAll(){this._getActiveRipples().forEach(t=>t.fadeOut())}fadeOutAllNonPersistent(){this._getActiveRipples().forEach(t=>{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=Sh(t);!this._platform.isBrowser||!e||e===this._triggerElement||(this._removeTriggerEvents(),this._triggerElement=e,aR.forEach(r=>{Ih._eventManager.addHandler(this._ngZone,r,e,this)}))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._ngZone.runOutsideAngular(()=>{lR.forEach(e=>{this._triggerElement.addEventListener(e,this,iR)})}),this._pointerUpEventsRegistered=!0)}_finishRippleTransition(t){0===t.state?this._startFadeOutTransition(t):2===t.state&&this._destroyRipple(t)}_startFadeOutTransition(t){const e=t===this._mostRecentTransientRipple,{persistent:r}=t.config;t.state=1,!r&&(!e||!this._isPointerDown)&&t.fadeOut()}_destroyRipple(t){const e=this._activeRipples.get(t)??null;this._activeRipples.delete(t),this._activeRipples.size||(this._containerRect=null),t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),t.state=3,null!==e&&(t.element.removeEventListener("transitionend",e.onTransitionEnd),t.element.removeEventListener("transitioncancel",e.onTransitionCancel)),t.element.remove()}_onMousedown(t){const e=GM(t),r=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;!this._target.rippleDisabled&&!e&&!r&&(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!KM(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let r=0;r<e.length;r++)this.fadeInRipple(e[r].clientX,e[r].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._getActiveRipples().forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_getActiveRipples(){return Array.from(this._activeRipples.keys())}_removeTriggerEvents(){const t=this._triggerElement;t&&(aR.forEach(e=>Ih._eventManager.removeHandler(e,t,this)),this._pointerUpEventsRegistered&&lR.forEach(e=>t.removeEventListener(e,this,iR)))}}Ih._eventManager=new voe;const cR=new Ct("mat-ripple-global-options");let uR=(()=>{class n{get disabled(){return this._disabled}set disabled(e){e&&this.fadeOutAllNonPersistent(),this._disabled=e,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(e){this._trigger=e,this._setupTriggerEventsIfEnabled()}constructor(e,r,s,o,i){this._elementRef=e,this._animationMode=i,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=o||{},this._rippleRenderer=new Ih(this,r,e,s)}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:{...this._globalOptions.animation,..."NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{},...this.animation},terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(e,r=0,s){return"number"==typeof e?this._rippleRenderer.fadeInRipple(e,r,{...this.rippleConfig,...s}):this._rippleRenderer.fadeInRipple(0,0,{...this.rippleConfig,...e})}}return n.\u0275fac=function(e){return new(e||n)(Ve(tr),Ve(wn),Ve(qs),Ve(cR,8),Ve(Rl,8))},n.\u0275dir=It({type:n,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(e,r){2&e&&fo("mat-ripple-unbounded",r.unbounded)},inputs:{color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],radius:["matRippleRadius","radius"],animation:["matRippleAnimation","animation"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"]},exportAs:["matRipple"]}),n})(),dR=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({imports:[Os,Os]}),n})();class hR{}class woe{}const Wl="*";function SC(n,t){return{type:7,name:n,definitions:t,options:{}}}function Ah(n,t=null){return{type:4,styles:t,timings:n}}function fR(n,t=null){return{type:2,steps:n,options:t}}function Hc(n){return{type:6,styles:n,offset:null}}function Nh(n,t,e){return{type:0,name:n,styles:t,options:e}}function kh(n,t,e=null){return{type:1,expr:n,animation:t,options:e}}function yR(n){Promise.resolve().then(n)}class $f{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._originalOnDoneFns=[],this._originalOnStartFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){yR(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this._started=!1,this._finished=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class bR{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,r=0,s=0;const o=this.players.length;0==o?yR(()=>this._onFinish()):this.players.forEach(i=>{i.onDone(()=>{++e==o&&this._onFinish()}),i.onDestroy(()=>{++r==o&&this._onDestroy()}),i.onStart(()=>{++s==o&&this._onStart()})}),this.totalTime=this.players.reduce((i,a)=>Math.max(i,a.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(r=>{const s=r.totalTime?Math.min(1,e/r.totalTime):1;r.setPosition(s)})}getPosition(){const t=this.players.reduce((e,r)=>null===e||r.totalTime>e.totalTime?r:e,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}const EC="!",_R=["*"],Soe=["content"];function Eoe(n,t){if(1&n){const e=function nD(){return ft()}();Nr(0,"div",2),Zr("click",function(){return function _m(n){return fn.lFrame.contextLView=n,n[Cr]}(e),function vm(n){return fn.lFrame.contextLView=null,n}(Lv()._onBackdropClicked())}),Cs()}2&n&&fo("mat-drawer-shown",Lv()._isShowingBackdrop())}function Doe(n,t){1&n&&(Nr(0,"mat-drawer-content"),Ms(1,2),Cs())}const Toe=[[["mat-drawer"]],[["mat-drawer-content"]],"*"],Ioe=["mat-drawer","mat-drawer-content","*"],Aoe={transformDrawer:SC("transform",[Nh("open, open-instant",Hc({transform:"none",visibility:"visible"})),Nh("void",Hc({"box-shadow":"none",visibility:"hidden"})),kh("void => open-instant",Ah("0ms")),kh("void <=> open, open-instant => void",Ah("400ms cubic-bezier(0.25, 0.8, 0.25, 1)"))])},Noe=new Ct("MAT_DRAWER_DEFAULT_AUTOSIZE",{providedIn:"root",factory:function koe(){return!1}}),vR=new Ct("MAT_DRAWER_CONTAINER");let DC=(()=>{class n extends mC{constructor(e,r,s,o,i){super(s,o,i),this._changeDetectorRef=e,this._container=r}ngAfterContentInit(){this._container._contentMarginChanges.subscribe(()=>{this._changeDetectorRef.markForCheck()})}}return n.\u0275fac=function(e){return new(e||n)(Ve(tl),Ve(Fn(()=>xR)),Ve(tr),Ve(tb),Ve(wn))},n.\u0275cmp=ys({type:n,selectors:[["mat-drawer-content"]],hostAttrs:["ngSkipHydration","true",1,"mat-drawer-content"],hostVars:4,hostBindings:function(e,r){2&e&&Dg("margin-left",r._container._contentMargins.left,"px")("margin-right",r._container._contentMargins.right,"px")},features:[mr([{provide:mC,useExisting:n}]),$n],ngContentSelectors:_R,decls:1,vars:0,template:function(e,r){1&e&&(fa(),Ms(0))},encapsulation:2,changeDetection:0}),n})(),Moe=(()=>{class n{get position(){return this._position}set position(e){(e="end"===e?"end":"start")!==this._position&&(this._isAttached&&this._updatePositionInParent(e),this._position=e,this.onPositionChanged.emit())}get mode(){return this._mode}set mode(e){this._mode=e,this._updateFocusTrapState(),this._modeChanged.next()}get disableClose(){return this._disableClose}set disableClose(e){this._disableClose=Oo(e)}get autoFocus(){return this._autoFocus??("side"===this.mode?"dialog":"first-tabbable")}set autoFocus(e){("true"===e||"false"===e||null==e)&&(e=Oo(e)),this._autoFocus=e}get opened(){return this._opened}set opened(e){this.toggle(Oo(e))}constructor(e,r,s,o,i,a,l,c){this._elementRef=e,this._focusTrapFactory=r,this._focusMonitor=s,this._platform=o,this._ngZone=i,this._interactivityChecker=a,this._doc=l,this._container=c,this._elementFocusedBeforeDrawerWasOpened=null,this._enableAnimations=!1,this._position="start",this._mode="over",this._disableClose=!1,this._opened=!1,this._animationStarted=new et,this._animationEnd=new et,this._animationState="void",this.openedChange=new nr(!0),this._openedStream=this.openedChange.pipe(Or(u=>u),gt(()=>{})),this.openedStart=this._animationStarted.pipe(Or(u=>u.fromState!==u.toState&&0===u.toState.indexOf("open")),iy(void 0)),this._closedStream=this.openedChange.pipe(Or(u=>!u),gt(()=>{})),this.closedStart=this._animationStarted.pipe(Or(u=>u.fromState!==u.toState&&"void"===u.toState),iy(void 0)),this._destroyed=new et,this.onPositionChanged=new nr,this._modeChanged=new et,this.openedChange.subscribe(u=>{u?(this._doc&&(this._elementFocusedBeforeDrawerWasOpened=this._doc.activeElement),this._takeFocus()):this._isFocusWithinDrawer()&&this._restoreFocus(this._openedVia||"program")}),this._ngZone.runOutsideAngular(()=>{ju(this._elementRef.nativeElement,"keydown").pipe(Or(u=>27===u.keyCode&&!this.disableClose&&!bC(u)),es(this._destroyed)).subscribe(u=>this._ngZone.run(()=>{this.close(),u.stopPropagation(),u.preventDefault()}))}),this._animationEnd.pipe(PM((u,d)=>u.fromState===d.fromState&&u.toState===d.toState)).subscribe(u=>{const{fromState:d,toState:p}=u;(0===p.indexOf("open")&&"void"===d||"void"===p&&0===d.indexOf("open"))&&this.openedChange.emit(this._opened)})}_forceFocus(e,r){this._interactivityChecker.isFocusable(e)||(e.tabIndex=-1,this._ngZone.runOutsideAngular(()=>{const s=()=>{e.removeEventListener("blur",s),e.removeEventListener("mousedown",s),e.removeAttribute("tabindex")};e.addEventListener("blur",s),e.addEventListener("mousedown",s)})),e.focus(r)}_focusByCssSelector(e,r){let s=this._elementRef.nativeElement.querySelector(e);s&&this._forceFocus(s,r)}_takeFocus(){if(!this._focusTrap)return;const e=this._elementRef.nativeElement;switch(this.autoFocus){case!1:case"dialog":return;case!0:case"first-tabbable":this._focusTrap.focusInitialElementWhenReady().then(r=>{!r&&"function"==typeof this._elementRef.nativeElement.focus&&e.focus()});break;case"first-heading":this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]');break;default:this._focusByCssSelector(this.autoFocus)}}_restoreFocus(e){"dialog"!==this.autoFocus&&(this._elementFocusedBeforeDrawerWasOpened?this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened,e):this._elementRef.nativeElement.blur(),this._elementFocusedBeforeDrawerWasOpened=null)}_isFocusWithinDrawer(){const e=this._doc.activeElement;return!!e&&this._elementRef.nativeElement.contains(e)}ngAfterViewInit(){this._isAttached=!0,this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement),this._updateFocusTrapState(),"end"===this._position&&this._updatePositionInParent("end")}ngAfterContentChecked(){this._platform.isBrowser&&(this._enableAnimations=!0)}ngOnDestroy(){this._focusTrap&&this._focusTrap.destroy(),this._anchor?.remove(),this._anchor=null,this._animationStarted.complete(),this._animationEnd.complete(),this._modeChanged.complete(),this._destroyed.next(),this._destroyed.complete()}open(e){return this.toggle(!0,e)}close(){return this.toggle(!1)}_closeViaBackdropClick(){return this._setOpen(!1,!0,"mouse")}toggle(e=!this.opened,r){e&&r&&(this._openedVia=r);const s=this._setOpen(e,!e&&this._isFocusWithinDrawer(),this._openedVia||"program");return e||(this._openedVia=null),s}_setOpen(e,r,s){return this._opened=e,e?this._animationState=this._enableAnimations?"open":"open-instant":(this._animationState="void",r&&this._restoreFocus(s)),this._updateFocusTrapState(),new Promise(o=>{this.openedChange.pipe(Jr(1)).subscribe(i=>o(i?"open":"close"))})}_getWidth(){return this._elementRef.nativeElement&&this._elementRef.nativeElement.offsetWidth||0}_updateFocusTrapState(){this._focusTrap&&(this._focusTrap.enabled=this.opened&&"side"!==this.mode)}_updatePositionInParent(e){const r=this._elementRef.nativeElement,s=r.parentNode;"end"===e?(this._anchor||(this._anchor=this._doc.createComment("mat-drawer-anchor"),s.insertBefore(this._anchor,r)),s.appendChild(r)):this._anchor&&this._anchor.parentNode.insertBefore(r,this._anchor)}}return n.\u0275fac=function(e){return new(e||n)(Ve(tr),Ve(jM),Ve(Ff),Ve(qs),Ve(wn),Ve(xC),Ve(kn,8),Ve(vR,8))},n.\u0275cmp=ys({type:n,selectors:[["mat-drawer"]],viewQuery:function(e,r){if(1&e&&Ac(Soe,5),2&e){let s;mi(s=gi())&&(r._content=s.first)}},hostAttrs:["tabIndex","-1","ngSkipHydration","true",1,"mat-drawer"],hostVars:12,hostBindings:function(e,r){1&e&&$v("@transform.start",function(o){return r._animationStarted.next(o)})("@transform.done",function(o){return r._animationEnd.next(o)}),2&e&&(Ks("align",null),Gv("@transform",r._animationState),fo("mat-drawer-end","end"===r.position)("mat-drawer-over","over"===r.mode)("mat-drawer-push","push"===r.mode)("mat-drawer-side","side"===r.mode)("mat-drawer-opened",r.opened))},inputs:{position:"position",mode:"mode",disableClose:"disableClose",autoFocus:"autoFocus",opened:"opened"},outputs:{openedChange:"openedChange",_openedStream:"opened",openedStart:"openedStart",_closedStream:"closed",closedStart:"closedStart",onPositionChanged:"positionChanged"},exportAs:["matDrawer"],ngContentSelectors:_R,decls:3,vars:0,consts:[["cdkScrollable","",1,"mat-drawer-inner-container"],["content",""]],template:function(e,r){1&e&&(fa(),Nr(0,"div",0,1),Ms(2),Cs())},dependencies:[mC],encapsulation:2,data:{animation:[Aoe.transformDrawer]},changeDetection:0}),n})(),xR=(()=>{class n{get start(){return this._start}get end(){return this._end}get autosize(){return this._autosize}set autosize(e){this._autosize=Oo(e)}get hasBackdrop(){return null==this._backdropOverride?!this._start||"side"!==this._start.mode||!this._end||"side"!==this._end.mode:this._backdropOverride}set hasBackdrop(e){this._backdropOverride=null==e?null:Oo(e)}get scrollable(){return this._userContent||this._content}constructor(e,r,s,o,i,a=!1,l){this._dir=e,this._element=r,this._ngZone=s,this._changeDetectorRef=o,this._animationMode=l,this._drawers=new Mg,this.backdropClick=new nr,this._destroyed=new et,this._doCheckSubject=new et,this._contentMargins={left:null,right:null},this._contentMarginChanges=new et,e&&e.change.pipe(es(this._destroyed)).subscribe(()=>{this._validateDrawers(),this.updateContentMargins()}),i.change().pipe(es(this._destroyed)).subscribe(()=>this.updateContentMargins()),this._autosize=a}ngAfterContentInit(){this._allDrawers.changes.pipe(Jp(this._allDrawers),es(this._destroyed)).subscribe(e=>{this._drawers.reset(e.filter(r=>!r._container||r._container===this)),this._drawers.notifyOnChanges()}),this._drawers.changes.pipe(Jp(null)).subscribe(()=>{this._validateDrawers(),this._drawers.forEach(e=>{this._watchDrawerToggle(e),this._watchDrawerPosition(e),this._watchDrawerMode(e)}),(!this._drawers.length||this._isDrawerOpen(this._start)||this._isDrawerOpen(this._end))&&this.updateContentMargins(),this._changeDetectorRef.markForCheck()}),this._ngZone.runOutsideAngular(()=>{this._doCheckSubject.pipe($M(10),es(this._destroyed)).subscribe(()=>this.updateContentMargins())})}ngOnDestroy(){this._contentMarginChanges.complete(),this._doCheckSubject.complete(),this._drawers.destroy(),this._destroyed.next(),this._destroyed.complete()}open(){this._drawers.forEach(e=>e.open())}close(){this._drawers.forEach(e=>e.close())}updateContentMargins(){let e=0,r=0;if(this._left&&this._left.opened)if("side"==this._left.mode)e+=this._left._getWidth();else if("push"==this._left.mode){const s=this._left._getWidth();e+=s,r-=s}if(this._right&&this._right.opened)if("side"==this._right.mode)r+=this._right._getWidth();else if("push"==this._right.mode){const s=this._right._getWidth();r+=s,e-=s}e=e||null,r=r||null,(e!==this._contentMargins.left||r!==this._contentMargins.right)&&(this._contentMargins={left:e,right:r},this._ngZone.run(()=>this._contentMarginChanges.next(this._contentMargins)))}ngDoCheck(){this._autosize&&this._isPushed()&&this._ngZone.runOutsideAngular(()=>this._doCheckSubject.next())}_watchDrawerToggle(e){e._animationStarted.pipe(Or(r=>r.fromState!==r.toState),es(this._drawers.changes)).subscribe(r=>{"open-instant"!==r.toState&&"NoopAnimations"!==this._animationMode&&this._element.nativeElement.classList.add("mat-drawer-transition"),this.updateContentMargins(),this._changeDetectorRef.markForCheck()}),"side"!==e.mode&&e.openedChange.pipe(es(this._drawers.changes)).subscribe(()=>this._setContainerClass(e.opened))}_watchDrawerPosition(e){e&&e.onPositionChanged.pipe(es(this._drawers.changes)).subscribe(()=>{this._ngZone.onMicrotaskEmpty.pipe(Jr(1)).subscribe(()=>{this._validateDrawers()})})}_watchDrawerMode(e){e&&e._modeChanged.pipe(es(fs(this._drawers.changes,this._destroyed))).subscribe(()=>{this.updateContentMargins(),this._changeDetectorRef.markForCheck()})}_setContainerClass(e){const r=this._element.nativeElement.classList,s="mat-drawer-container-has-open";e?r.add(s):r.remove(s)}_validateDrawers(){this._start=this._end=null,this._drawers.forEach(e=>{"end"==e.position?this._end=e:this._start=e}),this._right=this._left=null,this._dir&&"rtl"===this._dir.value?(this._left=this._end,this._right=this._start):(this._left=this._start,this._right=this._end)}_isPushed(){return this._isDrawerOpen(this._start)&&"over"!=this._start.mode||this._isDrawerOpen(this._end)&&"over"!=this._end.mode}_onBackdropClicked(){this.backdropClick.emit(),this._closeModalDrawersViaBackdrop()}_closeModalDrawersViaBackdrop(){[this._start,this._end].filter(e=>e&&!e.disableClose&&this._canHaveBackdrop(e)).forEach(e=>e._closeViaBackdropClick())}_isShowingBackdrop(){return this._isDrawerOpen(this._start)&&this._canHaveBackdrop(this._start)||this._isDrawerOpen(this._end)&&this._canHaveBackdrop(this._end)}_canHaveBackdrop(e){return"side"!==e.mode||!!this._backdropOverride}_isDrawerOpen(e){return null!=e&&e.opened}}return n.\u0275fac=function(e){return new(e||n)(Ve(Dh,8),Ve(tr),Ve(wn),Ve(tl),Ve(gC),Ve(Noe),Ve(Rl,8))},n.\u0275cmp=ys({type:n,selectors:[["mat-drawer-container"]],contentQueries:function(e,r,s){if(1&e&&(Zd(s,DC,5),Zd(s,Moe,5)),2&e){let o;mi(o=gi())&&(r._content=o.first),mi(o=gi())&&(r._allDrawers=o)}},viewQuery:function(e,r){if(1&e&&Ac(DC,5),2&e){let s;mi(s=gi())&&(r._userContent=s.first)}},hostAttrs:["ngSkipHydration","true",1,"mat-drawer-container"],hostVars:2,hostBindings:function(e,r){2&e&&fo("mat-drawer-container-explicit-backdrop",r._backdropOverride)},inputs:{autosize:"autosize",hasBackdrop:"hasBackdrop"},outputs:{backdropClick:"backdropClick"},exportAs:["matDrawerContainer"],features:[mr([{provide:vR,useExisting:n}])],ngContentSelectors:Ioe,decls:4,vars:2,consts:[["class","mat-drawer-backdrop",3,"mat-drawer-shown","click",4,"ngIf"],[4,"ngIf"],[1,"mat-drawer-backdrop",3,"click"]],template:function(e,r){1&e&&(fa(Toe),Sg(0,Eoe,1,2,"div",0),Ms(1),Ms(2,1),Sg(3,Doe,2,0,"mat-drawer-content",1)),2&e&&(pa("ngIf",r.hasBackdrop),Tc(3),pa("ngIf",!r._content))},dependencies:[p1,DC],styles:['.mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer[style*="visibility: hidden"]{display:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}'],encapsulation:2,changeDetection:0}),n})(),Roe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({imports:[Qg,Os,Of,Of,Os]}),n})();const Ooe=["*",[["mat-toolbar-row"]]],Foe=["*","mat-toolbar-row"],Poe=wC(class{constructor(n){this._elementRef=n}});let $oe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=It({type:n,selectors:[["mat-toolbar-row"]],hostAttrs:[1,"mat-toolbar-row"],exportAs:["matToolbarRow"]}),n})(),Loe=(()=>{class n extends Poe{constructor(e,r,s){super(e),this._platform=r,this._document=s}ngAfterViewInit(){this._platform.isBrowser&&(this._checkToolbarMixedModes(),this._toolbarRows.changes.subscribe(()=>this._checkToolbarMixedModes()))}_checkToolbarMixedModes(){}}return n.\u0275fac=function(e){return new(e||n)(Ve(tr),Ve(qs),Ve(kn))},n.\u0275cmp=ys({type:n,selectors:[["mat-toolbar"]],contentQueries:function(e,r,s){if(1&e&&Zd(s,$oe,5),2&e){let o;mi(o=gi())&&(r._toolbarRows=o)}},hostAttrs:[1,"mat-toolbar"],hostVars:4,hostBindings:function(e,r){2&e&&fo("mat-toolbar-multiple-rows",r._toolbarRows.length>0)("mat-toolbar-single-row",0===r._toolbarRows.length)},inputs:{color:"color"},exportAs:["matToolbar"],features:[$n],ngContentSelectors:Foe,decls:2,vars:0,template:function(e,r){1&e&&(fa(Ooe),Ms(0),Ms(1,1))},styles:[".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar .mat-mdc-button-base.mat-unthemed{--mdc-text-button-label-text-color: inherit;--mdc-outlined-button-label-text-color: inherit}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}"],encapsulation:2,changeDetection:0}),n})(),Boe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({imports:[Os,Os]}),n})();class TC{}class jl{constructor(t){this.normalizedNames=new Map,this.lazyUpdate=null,t?this.lazyInit="string"==typeof t?()=>{this.headers=new Map,t.split("\n").forEach(e=>{const r=e.indexOf(":");if(r>0){const s=e.slice(0,r),o=s.toLowerCase(),i=e.slice(r+1).trim();this.maybeSetNormalizedName(s,o),this.headers.has(o)?this.headers.get(o).push(i):this.headers.set(o,[i])}})}:()=>{this.headers=new Map,Object.entries(t).forEach(([e,r])=>{let s;if(s="string"==typeof r?[r]:"number"==typeof r?[r.toString()]:r.map(o=>o.toString()),s.length>0){const o=e.toLowerCase();this.headers.set(o,s),this.maybeSetNormalizedName(e,o)}})}:this.headers=new Map}has(t){return this.init(),this.headers.has(t.toLowerCase())}get(t){this.init();const e=this.headers.get(t.toLowerCase());return e&&e.length>0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(t){return this.init(),this.headers.get(t.toLowerCase())||null}append(t,e){return this.clone({name:t,value:e,op:"a"})}set(t,e){return this.clone({name:t,value:e,op:"s"})}delete(t,e){return this.clone({name:t,value:e,op:"d"})}maybeSetNormalizedName(t,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,t)}init(){this.lazyInit&&(this.lazyInit instanceof jl?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(t=>this.applyUpdate(t)),this.lazyUpdate=null))}copyFrom(t){t.init(),Array.from(t.headers.keys()).forEach(e=>{this.headers.set(e,t.headers.get(e)),this.normalizedNames.set(e,t.normalizedNames.get(e))})}clone(t){const e=new jl;return e.lazyInit=this.lazyInit&&this.lazyInit instanceof jl?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([t]),e}applyUpdate(t){const e=t.name.toLowerCase();switch(t.op){case"a":case"s":let r=t.value;if("string"==typeof r&&(r=[r]),0===r.length)return;this.maybeSetNormalizedName(t.name,e);const s=("a"===t.op?this.headers.get(e):void 0)||[];s.push(...r),this.headers.set(e,s);break;case"d":const o=t.value;if(o){let i=this.headers.get(e);if(!i)return;i=i.filter(a=>-1===o.indexOf(a)),0===i.length?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,i)}else this.headers.delete(e),this.normalizedNames.delete(e)}}forEach(t){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=>t(this.normalizedNames.get(e),this.headers.get(e)))}}class Voe{encodeKey(t){return SR(t)}encodeValue(t){return SR(t)}decodeKey(t){return decodeURIComponent(t)}decodeValue(t){return decodeURIComponent(t)}}const zoe=/%(\d[a-f0-9])/gi,Hoe={40:"@","3A":":",24:"$","2C":",","3B":";","3D":"=","3F":"?","2F":"/"};function SR(n){return encodeURIComponent(n).replace(zoe,(t,e)=>Hoe[e]??t)}function ob(n){return`${n}`}class Wc{constructor(t={}){if(this.updates=null,this.cloneFrom=null,this.encoder=t.encoder||new Voe,t.fromString){if(t.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function Uoe(n,t){const e=new Map;return n.length>0&&n.replace(/^\?/,"").split("&").forEach(s=>{const o=s.indexOf("="),[i,a]=-1==o?[t.decodeKey(s),""]:[t.decodeKey(s.slice(0,o)),t.decodeValue(s.slice(o+1))],l=e.get(i)||[];l.push(a),e.set(i,l)}),e}(t.fromString,this.encoder)}else t.fromObject?(this.map=new Map,Object.keys(t.fromObject).forEach(e=>{const r=t.fromObject[e],s=Array.isArray(r)?r.map(ob):[ob(r)];this.map.set(e,s)})):this.map=null}has(t){return this.init(),this.map.has(t)}get(t){this.init();const e=this.map.get(t);return e?e[0]:null}getAll(t){return this.init(),this.map.get(t)||null}keys(){return this.init(),Array.from(this.map.keys())}append(t,e){return this.clone({param:t,value:e,op:"a"})}appendAll(t){const e=[];return Object.keys(t).forEach(r=>{const s=t[r];Array.isArray(s)?s.forEach(o=>{e.push({param:r,value:o,op:"a"})}):e.push({param:r,value:s,op:"a"})}),this.clone(e)}set(t,e){return this.clone({param:t,value:e,op:"s"})}delete(t,e){return this.clone({param:t,value:e,op:"d"})}toString(){return this.init(),this.keys().map(t=>{const e=this.encoder.encodeKey(t);return this.map.get(t).map(r=>e+"="+this.encoder.encodeValue(r)).join("&")}).filter(t=>""!==t).join("&")}clone(t){const e=new Wc({encoder:this.encoder});return e.cloneFrom=this.cloneFrom||this,e.updates=(this.updates||[]).concat(t),e}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(t=>this.map.set(t,this.cloneFrom.map.get(t))),this.updates.forEach(t=>{switch(t.op){case"a":case"s":const e=("a"===t.op?this.map.get(t.param):void 0)||[];e.push(ob(t.value)),this.map.set(t.param,e);break;case"d":if(void 0===t.value){this.map.delete(t.param);break}{let r=this.map.get(t.param)||[];const s=r.indexOf(ob(t.value));-1!==s&&r.splice(s,1),r.length>0?this.map.set(t.param,r):this.map.delete(t.param)}}}),this.cloneFrom=this.updates=null)}}class Woe{constructor(){this.map=new Map}set(t,e){return this.map.set(t,e),this}get(t){return this.map.has(t)||this.map.set(t,t.defaultValue()),this.map.get(t)}delete(t){return this.map.delete(t),this}has(t){return this.map.has(t)}keys(){return this.map.keys()}}function ER(n){return typeof ArrayBuffer<"u"&&n instanceof ArrayBuffer}function DR(n){return typeof Blob<"u"&&n instanceof Blob}function TR(n){return typeof FormData<"u"&&n instanceof FormData}class Lf{constructor(t,e,r,s){let o;if(this.url=e,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=t.toUpperCase(),function joe(n){switch(n){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||s?(this.body=void 0!==r?r:null,o=s):o=r,o&&(this.reportProgress=!!o.reportProgress,this.withCredentials=!!o.withCredentials,o.responseType&&(this.responseType=o.responseType),o.headers&&(this.headers=o.headers),o.context&&(this.context=o.context),o.params&&(this.params=o.params)),this.headers||(this.headers=new jl),this.context||(this.context=new Woe),this.params){const i=this.params.toString();if(0===i.length)this.urlWithParams=e;else{const a=e.indexOf("?");this.urlWithParams=e+(-1===a?"?":a<e.length-1?"&":"")+i}}else this.params=new Wc,this.urlWithParams=e}serializeBody(){return null===this.body?null:ER(this.body)||DR(this.body)||TR(this.body)||function Goe(n){return typeof URLSearchParams<"u"&&n instanceof URLSearchParams}(this.body)||"string"==typeof this.body?this.body:this.body instanceof Wc?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||TR(this.body)?null:DR(this.body)?this.body.type||null:ER(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof Wc?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||"boolean"==typeof this.body?"application/json":null}clone(t={}){const e=t.method||this.method,r=t.url||this.url,s=t.responseType||this.responseType,o=void 0!==t.body?t.body:this.body,i=void 0!==t.withCredentials?t.withCredentials:this.withCredentials,a=void 0!==t.reportProgress?t.reportProgress:this.reportProgress;let l=t.headers||this.headers,c=t.params||this.params;const u=t.context??this.context;return void 0!==t.setHeaders&&(l=Object.keys(t.setHeaders).reduce((d,p)=>d.set(p,t.setHeaders[p]),l)),t.setParams&&(c=Object.keys(t.setParams).reduce((d,p)=>d.set(p,t.setParams[p]),c)),new Lf(e,r,o,{params:c,headers:l,context:u,reportProgress:a,responseType:s,withCredentials:i})}}var Zs=(()=>((Zs=Zs||{})[Zs.Sent=0]="Sent",Zs[Zs.UploadProgress=1]="UploadProgress",Zs[Zs.ResponseHeader=2]="ResponseHeader",Zs[Zs.DownloadProgress=3]="DownloadProgress",Zs[Zs.Response=4]="Response",Zs[Zs.User=5]="User",Zs))();class Koe{constructor(t,e=200,r="OK"){this.headers=t.headers||new jl,this.status=void 0!==t.status?t.status:e,this.statusText=t.statusText||r,this.url=t.url||null,this.ok=this.status>=200&&this.status<300}}class Bf extends Koe{constructor(t={}){super(t),this.type=Zs.Response,this.body=void 0!==t.body?t.body:null}clone(t={}){return new Bf({body:void 0!==t.body?t.body:this.body,headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}function IC(n,t){return{body:t,headers:n.headers,context:n.context,observe:n.observe,params:n.params,reportProgress:n.reportProgress,responseType:n.responseType,withCredentials:n.withCredentials}}let AC=(()=>{class n{constructor(e){this.handler=e}request(e,r,s={}){let o;if(e instanceof Lf)o=e;else{let l,c;l=s.headers instanceof jl?s.headers:new jl(s.headers),s.params&&(c=s.params instanceof Wc?s.params:new Wc({fromObject:s.params})),o=new Lf(e,r,void 0!==s.body?s.body:null,{headers:l,context:s.context,params:c,reportProgress:s.reportProgress,responseType:s.responseType||"json",withCredentials:s.withCredentials})}const i=sn(o).pipe(th(l=>this.handler.handle(l)));if(e instanceof Lf||"events"===s.observe)return i;const a=i.pipe(Or(l=>l instanceof Bf));switch(s.observe||"body"){case"body":switch(o.responseType){case"arraybuffer":return a.pipe(gt(l=>{if(null!==l.body&&!(l.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return l.body}));case"blob":return a.pipe(gt(l=>{if(null!==l.body&&!(l.body instanceof Blob))throw new Error("Response is not a Blob.");return l.body}));case"text":return a.pipe(gt(l=>{if(null!==l.body&&"string"!=typeof l.body)throw new Error("Response is not a string.");return l.body}));default:return a.pipe(gt(l=>l.body))}case"response":return a;default:throw new Error(`Unreachable: unhandled observe type ${s.observe}}`)}}delete(e,r={}){return this.request("DELETE",e,r)}get(e,r={}){return this.request("GET",e,r)}head(e,r={}){return this.request("HEAD",e,r)}jsonp(e,r){return this.request("JSONP",e,{params:(new Wc).append(r,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(e,r={}){return this.request("OPTIONS",e,r)}patch(e,r,s={}){return this.request("PATCH",e,IC(s,r))}post(e,r,s={}){return this.request("POST",e,IC(s,r))}put(e,r,s={}){return this.request("PUT",e,IC(s,r))}}return n.\u0275fac=function(e){return new(e||n)(Ke(TC))},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})();const pie=["*"];let ab;function Uf(n){return function fie(){if(void 0===ab&&(ab=null,typeof window<"u")){const n=window;void 0!==n.trustedTypes&&(ab=n.trustedTypes.createPolicy("angular#components",{createHTML:t=>t}))}return ab}()?.createHTML(n)||n}function FR(n){return Error(`Unable to find icon with the name "${n}"`)}function PR(n){return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${n}".`)}function $R(n){return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${n}".`)}class Xu{constructor(t,e,r){this.url=t,this.svgText=e,this.options=r}}let lb=(()=>{class n{constructor(e,r,s,o){this._httpClient=e,this._sanitizer=r,this._errorHandler=o,this._svgIconConfigs=new Map,this._iconSetConfigs=new Map,this._cachedIconsByUrl=new Map,this._inProgressUrlFetches=new Map,this._fontCssClassesByAlias=new Map,this._resolvers=[],this._defaultFontSetClass=["material-icons","mat-ligature-font"],this._document=s}addSvgIcon(e,r,s){return this.addSvgIconInNamespace("",e,r,s)}addSvgIconLiteral(e,r,s){return this.addSvgIconLiteralInNamespace("",e,r,s)}addSvgIconInNamespace(e,r,s,o){return this._addSvgIconConfig(e,r,new Xu(s,null,o))}addSvgIconResolver(e){return this._resolvers.push(e),this}addSvgIconLiteralInNamespace(e,r,s,o){const i=this._sanitizer.sanitize(Qn.HTML,s);if(!i)throw $R(s);const a=Uf(i);return this._addSvgIconConfig(e,r,new Xu("",a,o))}addSvgIconSet(e,r){return this.addSvgIconSetInNamespace("",e,r)}addSvgIconSetLiteral(e,r){return this.addSvgIconSetLiteralInNamespace("",e,r)}addSvgIconSetInNamespace(e,r,s){return this._addSvgIconSetConfig(e,new Xu(r,null,s))}addSvgIconSetLiteralInNamespace(e,r,s){const o=this._sanitizer.sanitize(Qn.HTML,r);if(!o)throw $R(r);const i=Uf(o);return this._addSvgIconSetConfig(e,new Xu("",i,s))}registerFontClassAlias(e,r=e){return this._fontCssClassesByAlias.set(e,r),this}classNameForFontAlias(e){return this._fontCssClassesByAlias.get(e)||e}setDefaultFontSetClass(...e){return this._defaultFontSetClass=e,this}getDefaultFontSetClass(){return this._defaultFontSetClass}getSvgIconFromUrl(e){const r=this._sanitizer.sanitize(Qn.RESOURCE_URL,e);if(!r)throw PR(e);const s=this._cachedIconsByUrl.get(r);return s?sn(cb(s)):this._loadSvgIconFromConfig(new Xu(e,null)).pipe(Es(o=>this._cachedIconsByUrl.set(r,o)),gt(o=>cb(o)))}getNamedSvgIcon(e,r=""){const s=LR(r,e);let o=this._svgIconConfigs.get(s);if(o)return this._getSvgFromConfig(o);if(o=this._getIconConfigFromResolvers(r,e),o)return this._svgIconConfigs.set(s,o),this._getSvgFromConfig(o);const i=this._iconSetConfigs.get(r);return i?this._getSvgFromIconSetConfigs(e,i):Mu(FR(s))}ngOnDestroy(){this._resolvers=[],this._svgIconConfigs.clear(),this._iconSetConfigs.clear(),this._cachedIconsByUrl.clear()}_getSvgFromConfig(e){return e.svgText?sn(cb(this._svgElementFromConfig(e))):this._loadSvgIconFromConfig(e).pipe(gt(r=>cb(r)))}_getSvgFromIconSetConfigs(e,r){const s=this._extractIconWithNameFromAnySet(e,r);return s?sn(s):function CR(...n){const t=Aa(n),{args:e,keys:r}=z1(n),s=new Me(o=>{const{length:i}=e;if(!i)return void o.complete();const a=new Array(i);let l=i,c=i;for(let u=0;u<i;u++){let d=!1;Dr(e[u]).subscribe(Vt(o,p=>{d||(d=!0,c--),a[u]=p},()=>l--,void 0,()=>{(!l||!d)&&(c||o.next(r?H1(r,a):a),o.complete())}))}});return t?s.pipe(cx(t)):s}(r.filter(i=>!i.svgText).map(i=>this._loadSvgIconSetFromConfig(i).pipe(Rc(a=>{const c=`Loading icon set URL: ${this._sanitizer.sanitize(Qn.RESOURCE_URL,i.url)} failed: ${a.message}`;return this._errorHandler.handleError(new Error(c)),sn(null)})))).pipe(gt(()=>{const i=this._extractIconWithNameFromAnySet(e,r);if(!i)throw FR(e);return i}))}_extractIconWithNameFromAnySet(e,r){for(let s=r.length-1;s>=0;s--){const o=r[s];if(o.svgText&&o.svgText.toString().indexOf(e)>-1){const i=this._svgElementFromConfig(o),a=this._extractSvgIconFromSet(i,e,o.options);if(a)return a}}return null}_loadSvgIconFromConfig(e){return this._fetchIcon(e).pipe(Es(r=>e.svgText=r),gt(()=>this._svgElementFromConfig(e)))}_loadSvgIconSetFromConfig(e){return e.svgText?sn(null):this._fetchIcon(e).pipe(Es(r=>e.svgText=r))}_extractSvgIconFromSet(e,r,s){const o=e.querySelector(`[id="${r}"]`);if(!o)return null;const i=o.cloneNode(!0);if(i.removeAttribute("id"),"svg"===i.nodeName.toLowerCase())return this._setSvgAttributes(i,s);if("symbol"===i.nodeName.toLowerCase())return this._setSvgAttributes(this._toSvgElement(i),s);const a=this._svgElementFromString(Uf("<svg></svg>"));return a.appendChild(i),this._setSvgAttributes(a,s)}_svgElementFromString(e){const r=this._document.createElement("DIV");r.innerHTML=e;const s=r.querySelector("svg");if(!s)throw Error("<svg> tag not found");return s}_toSvgElement(e){const r=this._svgElementFromString(Uf("<svg></svg>")),s=e.attributes;for(let o=0;o<s.length;o++){const{name:i,value:a}=s[o];"id"!==i&&r.setAttribute(i,a)}for(let o=0;o<e.childNodes.length;o++)e.childNodes[o].nodeType===this._document.ELEMENT_NODE&&r.appendChild(e.childNodes[o].cloneNode(!0));return r}_setSvgAttributes(e,r){return e.setAttribute("fit",""),e.setAttribute("height","100%"),e.setAttribute("width","100%"),e.setAttribute("preserveAspectRatio","xMidYMid meet"),e.setAttribute("focusable","false"),r&&r.viewBox&&e.setAttribute("viewBox",r.viewBox),e}_fetchIcon(e){const{url:r,options:s}=e,o=s?.withCredentials??!1;if(!this._httpClient)throw function mie(){return Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.")}();if(null==r)throw Error(`Cannot fetch icon from URL "${r}".`);const i=this._sanitizer.sanitize(Qn.RESOURCE_URL,r);if(!i)throw PR(r);const a=this._inProgressUrlFetches.get(i);if(a)return a;const l=this._httpClient.get(i,{responseType:"text",withCredentials:o}).pipe(gt(c=>Uf(c)),ay(()=>this._inProgressUrlFetches.delete(i)),Qi());return this._inProgressUrlFetches.set(i,l),l}_addSvgIconConfig(e,r,s){return this._svgIconConfigs.set(LR(e,r),s),this}_addSvgIconSetConfig(e,r){const s=this._iconSetConfigs.get(e);return s?s.push(r):this._iconSetConfigs.set(e,[r]),this}_svgElementFromConfig(e){if(!e.svgElement){const r=this._svgElementFromString(e.svgText);this._setSvgAttributes(r,e.options),e.svgElement=r}return e.svgElement}_getIconConfigFromResolvers(e,r){for(let s=0;s<this._resolvers.length;s++){const o=this._resolvers[s](r,e);if(o)return yie(o)?new Xu(o.url,null,o.options):new Xu(o,null)}}}return n.\u0275fac=function(e){return new(e||n)(Ke(AC,8),Ke(lx),Ke(kn,8),Ke(Ka))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function cb(n){return n.cloneNode(!0)}function LR(n,t){return n+":"+t}function yie(n){return!(!n.url||!n.options)}const bie=wC(class{constructor(n){this._elementRef=n}}),_ie=new Ct("MAT_ICON_DEFAULT_OPTIONS"),vie=new Ct("mat-icon-location",{providedIn:"root",factory:function xie(){const n=Ft(kn),t=n?n.location:null;return{getPathname:()=>t?t.pathname+t.search:""}}}),BR=["clip-path","color-profile","src","cursor","fill","filter","marker","marker-start","marker-mid","marker-end","mask","stroke"],Cie=BR.map(n=>`[${n}]`).join(", "),wie=/^url\(['"]?#(.*?)['"]?\)$/;let Sie=(()=>{class n extends bie{get inline(){return this._inline}set inline(e){this._inline=Oo(e)}get svgIcon(){return this._svgIcon}set svgIcon(e){e!==this._svgIcon&&(e?this._updateSvgIcon(e):this._svgIcon&&this._clearSvgElement(),this._svgIcon=e)}get fontSet(){return this._fontSet}set fontSet(e){const r=this._cleanupFontValue(e);r!==this._fontSet&&(this._fontSet=r,this._updateFontIconClasses())}get fontIcon(){return this._fontIcon}set fontIcon(e){const r=this._cleanupFontValue(e);r!==this._fontIcon&&(this._fontIcon=r,this._updateFontIconClasses())}constructor(e,r,s,o,i,a){super(e),this._iconRegistry=r,this._location=o,this._errorHandler=i,this._inline=!1,this._previousFontSetClass=[],this._currentIconFetch=U.EMPTY,a&&(a.color&&(this.color=this.defaultColor=a.color),a.fontSet&&(this.fontSet=a.fontSet)),s||e.nativeElement.setAttribute("aria-hidden","true")}_splitIconName(e){if(!e)return["",""];const r=e.split(":");switch(r.length){case 1:return["",r[0]];case 2:return r;default:throw Error(`Invalid icon name: "${e}"`)}}ngOnInit(){this._updateFontIconClasses()}ngAfterViewChecked(){const e=this._elementsWithExternalReferences;if(e&&e.size){const r=this._location.getPathname();r!==this._previousPath&&(this._previousPath=r,this._prependPathToReferences(r))}}ngOnDestroy(){this._currentIconFetch.unsubscribe(),this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear()}_usingFontIcon(){return!this.svgIcon}_setSvgElement(e){this._clearSvgElement();const r=this._location.getPathname();this._previousPath=r,this._cacheChildrenWithExternalReferences(e),this._prependPathToReferences(r),this._elementRef.nativeElement.appendChild(e)}_clearSvgElement(){const e=this._elementRef.nativeElement;let r=e.childNodes.length;for(this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear();r--;){const s=e.childNodes[r];(1!==s.nodeType||"svg"===s.nodeName.toLowerCase())&&s.remove()}}_updateFontIconClasses(){if(!this._usingFontIcon())return;const e=this._elementRef.nativeElement,r=(this.fontSet?this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/):this._iconRegistry.getDefaultFontSetClass()).filter(s=>s.length>0);this._previousFontSetClass.forEach(s=>e.classList.remove(s)),r.forEach(s=>e.classList.add(s)),this._previousFontSetClass=r,this.fontIcon!==this._previousFontIconClass&&!r.includes("mat-ligature-font")&&(this._previousFontIconClass&&e.classList.remove(this._previousFontIconClass),this.fontIcon&&e.classList.add(this.fontIcon),this._previousFontIconClass=this.fontIcon)}_cleanupFontValue(e){return"string"==typeof e?e.trim().split(" ")[0]:e}_prependPathToReferences(e){const r=this._elementsWithExternalReferences;r&&r.forEach((s,o)=>{s.forEach(i=>{o.setAttribute(i.name,`url('${e}#${i.value}')`)})})}_cacheChildrenWithExternalReferences(e){const r=e.querySelectorAll(Cie),s=this._elementsWithExternalReferences=this._elementsWithExternalReferences||new Map;for(let o=0;o<r.length;o++)BR.forEach(i=>{const a=r[o],l=a.getAttribute(i),c=l?l.match(wie):null;if(c){let u=s.get(a);u||(u=[],s.set(a,u)),u.push({name:i,value:c[1]})}})}_updateSvgIcon(e){if(this._svgNamespace=null,this._svgName=null,this._currentIconFetch.unsubscribe(),e){const[r,s]=this._splitIconName(e);r&&(this._svgNamespace=r),s&&(this._svgName=s),this._currentIconFetch=this._iconRegistry.getNamedSvgIcon(s,r).pipe(Jr(1)).subscribe(o=>this._setSvgElement(o),o=>{this._errorHandler.handleError(new Error(`Error retrieving icon ${r}:${s}! ${o.message}`))})}}}return n.\u0275fac=function(e){return new(e||n)(Ve(tr),Ve(lb),function vc(n){return function ha(n,t){if("class"===t)return n.classes;if("style"===t)return n.styles;const e=n.attrs;if(e){const r=e.length;let s=0;for(;s<r;){const o=e[s];if(au(o))break;if(0===o)s+=2;else if("number"==typeof o)for(s++;s<r&&"string"==typeof e[s];)s++;else{if(o===t)return e[s+1];s+=2}}}return null}(bs(),n)}("aria-hidden"),Ve(vie),Ve(Ka),Ve(_ie,8))},n.\u0275cmp=ys({type:n,selectors:[["mat-icon"]],hostAttrs:["role","img",1,"mat-icon","notranslate"],hostVars:8,hostBindings:function(e,r){2&e&&(Ks("data-mat-icon-type",r._usingFontIcon()?"font":"svg")("data-mat-icon-name",r._svgName||r.fontIcon)("data-mat-icon-namespace",r._svgNamespace||r.fontSet)("fontIcon",r._usingFontIcon()?r.fontIcon:null),fo("mat-icon-inline",r.inline)("mat-icon-no-color","primary"!==r.color&&"accent"!==r.color&&"warn"!==r.color))},inputs:{color:"color",inline:"inline",svgIcon:"svgIcon",fontSet:"fontSet",fontIcon:"fontIcon"},exportAs:["matIcon"],features:[$n],ngContentSelectors:pie,decls:1,vars:0,template:function(e,r){1&e&&(fa(),Ms(0))},styles:[".mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}"],encapsulation:2,changeDetection:0}),n})(),Eie=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({imports:[Os,Os]}),n})();const Tie=["mat-icon-button",""],Iie=["*"],VR={capture:!0},UR=["focus","click","mouseenter","touchstart"],zf="mat-button-ripple-uninitialized";let Aie=(()=>{class n{constructor(){this._document=Ft(kn,{optional:!0}),this._animationMode=Ft(Rl,{optional:!0}),this._globalRippleOptions=Ft(cR,{optional:!0}),this._platform=Ft(qs),this._ngZone=Ft(wn),this._onInteraction=e=>{if(e.target===this._document)return;const s=e.target.closest(`[${zf}]`);s&&(s.removeAttribute(zf),this._appendRipple(s))},this._ngZone.runOutsideAngular(()=>{for(const e of UR)this._document?.addEventListener(e,this._onInteraction,VR)})}ngOnDestroy(){for(const e of UR)this._document?.removeEventListener(e,this._onInteraction,VR)}_appendRipple(e){if(!this._document)return;const r=this._document.createElement("span");r.classList.add("mat-mdc-button-ripple");const s=new Nie(e,this._globalRippleOptions?this._globalRippleOptions:void 0,this._animationMode?this._animationMode:void 0);s.rippleConfig.centered=e.hasAttribute("mat-icon-button"),new Ih(s,this._ngZone,r,this._platform).setupTriggerEvents(e),e.append(r)}_createMatRipple(e){if(!this._document)return;e.querySelector(".mat-mdc-button-ripple")?.remove(),e.removeAttribute(zf);const r=this._document.createElement("span");r.classList.add("mat-mdc-button-ripple");const s=new uR(new tr(r),this._ngZone,this._platform,this._globalRippleOptions?this._globalRippleOptions:void 0,this._animationMode?this._animationMode:void 0);return s._isInitialized=!0,s.trigger=e,e.append(r),s}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class Nie{constructor(t,e,r){this._button=t,this._globalRippleOptions=e,this._setRippleConfig(e,r)}_setRippleConfig(t,e){this.rippleConfig=t||{},"NoopAnimations"===e&&(this.rippleConfig.animation={enterDuration:0,exitDuration:0})}get rippleDisabled(){return this._button.hasAttribute("disabled")||!!this._globalRippleOptions?.disabled}}const kie=[{selector:"mat-button",mdcClasses:["mdc-button","mat-mdc-button"]},{selector:"mat-flat-button",mdcClasses:["mdc-button","mdc-button--unelevated","mat-mdc-unelevated-button"]},{selector:"mat-raised-button",mdcClasses:["mdc-button","mdc-button--raised","mat-mdc-raised-button"]},{selector:"mat-stroked-button",mdcClasses:["mdc-button","mdc-button--outlined","mat-mdc-outlined-button"]},{selector:"mat-fab",mdcClasses:["mdc-fab","mat-mdc-fab"]},{selector:"mat-mini-fab",mdcClasses:["mdc-fab","mdc-fab--mini","mat-mdc-mini-fab"]},{selector:"mat-icon-button",mdcClasses:["mdc-icon-button","mat-mdc-icon-button"]}],Mie=wC(yoe(rR(class{constructor(n){this._elementRef=n}})));let Rie=(()=>{class n extends Mie{get ripple(){return!this._ripple&&this._rippleLoader&&(this._ripple=this._rippleLoader._createMatRipple(this._elementRef.nativeElement)),this._ripple}set ripple(e){this._ripple=e}constructor(e,r,s,o){super(e),this._platform=r,this._ngZone=s,this._animationMode=o,this._focusMonitor=Ft(Ff),this._rippleLoader=Ft(Aie),this._isFab=!1;const i=e.nativeElement.classList;for(const a of kie)this._hasHostAttributes(a.selector)&&a.mdcClasses.forEach(l=>{i.add(l)})}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(e="program",r){e?this._focusMonitor.focusVia(this._elementRef.nativeElement,e,r):this._elementRef.nativeElement.focus(r)}_hasHostAttributes(...e){return e.some(r=>this._elementRef.nativeElement.hasAttribute(r))}_isRippleDisabled(){this._ripple&&(this._ripple.disabled=this.disableRipple||this.disabled)}}return n.\u0275fac=function(e){pg()},n.\u0275dir=It({type:n,features:[$n]}),n})(),Pie=(()=>{class n extends Rie{get ripple(){return!this._ripple&&this._rippleLoader&&(this._ripple=this._rippleLoader._createMatRipple(this._elementRef.nativeElement),this._ripple.centered=!0),this._ripple}constructor(e,r,s,o){super(e,r,s,o)}}return n.\u0275fac=function(e){return new(e||n)(Ve(tr),Ve(qs),Ve(wn),Ve(Rl,8))},n.\u0275cmp=ys({type:n,selectors:[["button","mat-icon-button",""]],hostAttrs:["mat-button-ripple-uninitialized",""],hostVars:9,hostBindings:function(e,r){2&e&&(Ks("disabled",r.disabled||null)("mat-button-disabled",r._isRippleDisabled())("mat-button-is-fab",r._isFab),fo("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-unthemed",!r.color)("mat-mdc-button-base",!0))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[$n],attrs:Tie,ngContentSelectors:Iie,decls:4,vars:0,consts:[[1,"mat-mdc-button-persistent-ripple","mdc-icon-button__ripple"],[1,"mat-mdc-focus-indicator"],[1,"mat-mdc-button-touch-target"]],template:function(e,r){1&e&&(fa(),Za(0,"span",0),Ms(1),Za(2,"span",1)(3,"span",2))},styles:['.mdc-icon-button{display:inline-block;position:relative;box-sizing:border-box;border:none;outline:none;background-color:rgba(0,0,0,0);fill:currentColor;color:inherit;text-decoration:none;cursor:pointer;user-select:none;z-index:0;overflow:visible}.mdc-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}@media screen and (forced-colors: active){.mdc-icon-button.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring,.mdc-icon-button:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring{display:block}}.mdc-icon-button:disabled{cursor:default;pointer-events:none}.mdc-icon-button[hidden]{display:none}.mdc-icon-button--display-flex{align-items:center;display:inline-flex;justify-content:center}.mdc-icon-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:100%;width:100%;display:none}@media screen and (forced-colors: active){.mdc-icon-button__focus-ring{border-color:CanvasText}}.mdc-icon-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-icon-button__focus-ring::after{border-color:CanvasText}}.mdc-icon-button__icon{display:inline-block}.mdc-icon-button__icon.mdc-icon-button__icon--on{display:none}.mdc-icon-button--on .mdc-icon-button__icon{display:none}.mdc-icon-button--on .mdc-icon-button__icon.mdc-icon-button__icon--on{display:inline-block}.mdc-icon-button__link{height:100%;left:0;outline:none;position:absolute;top:0;width:100%}.mat-mdc-icon-button{height:var(--mdc-icon-button-state-layer-size);width:var(--mdc-icon-button-state-layer-size);color:var(--mdc-icon-button-icon-color);--mdc-icon-button-state-layer-size:48px;--mdc-icon-button-icon-size:24px;--mdc-icon-button-disabled-icon-color:black;--mdc-icon-button-disabled-icon-opacity:0.38}.mat-mdc-icon-button .mdc-button__icon{font-size:var(--mdc-icon-button-icon-size)}.mat-mdc-icon-button svg,.mat-mdc-icon-button img{width:var(--mdc-icon-button-icon-size);height:var(--mdc-icon-button-icon-size)}.mat-mdc-icon-button:disabled{opacity:var(--mdc-icon-button-disabled-icon-opacity)}.mat-mdc-icon-button:disabled{color:var(--mdc-icon-button-disabled-icon-color)}.mat-mdc-icon-button{padding:12px;font-size:var(--mdc-icon-button-icon-size);border-radius:50%;flex-shrink:0;text-align:center;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-icon-button svg{vertical-align:baseline}.mat-mdc-icon-button[disabled]{cursor:default;pointer-events:none;opacity:1}.mat-mdc-icon-button .mat-mdc-button-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-icon-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-icon-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-icon-button .mdc-button__label{z-index:1}.mat-mdc-icon-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-icon-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-icon-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mat-mdc-icon-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple{border-radius:50%}.mat-mdc-icon-button.mat-unthemed:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-primary:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-accent:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-warn:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}',".cdk-high-contrast-active .mat-mdc-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-unelevated-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-raised-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-outlined-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-icon-button{outline:solid 1px}"],encapsulation:2,changeDetection:0}),n})(),$ie=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({imports:[Os,dR,Os]}),n})();class kC{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&&(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class ub extends kC{constructor(t,e,r,s,o){super(),this.component=t,this.viewContainerRef=e,this.injector=r,this.componentFactoryResolver=s,this.projectableNodes=o}}class zR extends kC{constructor(t,e,r,s){super(),this.templateRef=t,this.viewContainerRef=e,this.context=r,this.injector=s}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class Lie extends kC{constructor(t){super(),this.element=t instanceof tr?t.nativeElement:t}}class MC{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof ub?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof zR?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof Lie?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class Bie extends MC{constructor(t,e,r,s,o){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=r,this._defaultInjector=s,this.attachDomPortal=i=>{const a=i.element,l=this._document.createComment("dom-portal");a.parentNode.insertBefore(l,a),this.outletElement.appendChild(a),this._attachedPortal=i,super.setDisposeFn(()=>{l.parentNode&&l.parentNode.replaceChild(a,l)})},this._document=o}attachComponentPortal(t){const r=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let s;return t.viewContainerRef?(s=t.viewContainerRef.createComponent(r,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector,t.projectableNodes||void 0),this.setDisposeFn(()=>s.destroy())):(s=r.create(t.injector||this._defaultInjector||Gs.NULL),this._appRef.attachView(s.hostView),this.setDisposeFn(()=>{this._appRef.viewCount>0&&this._appRef.detachView(s.hostView),s.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(s)),this._attachedPortal=t,s}attachTemplatePortal(t){let e=t.viewContainerRef,r=e.createEmbeddedView(t.templateRef,t.context,{injector:t.injector});return r.rootNodes.forEach(s=>this.outletElement.appendChild(s)),r.detectChanges(),this.setDisposeFn(()=>{let s=e.indexOf(r);-1!==s&&e.remove(s)}),this._attachedPortal=t,r}dispose(){super.dispose(),this.outletElement.remove()}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let HR=(()=>{class n extends MC{constructor(e,r,s){super(),this._componentFactoryResolver=e,this._viewContainerRef=r,this._isInitialized=!1,this.attached=new nr,this.attachDomPortal=o=>{const i=o.element,a=this._document.createComment("dom-portal");o.setAttachedHost(this),i.parentNode.insertBefore(a,i),this._getRootNode().appendChild(i),this._attachedPortal=o,super.setDisposeFn(()=>{a.parentNode&&a.parentNode.replaceChild(i,a)})},this._document=s}get portal(){return this._attachedPortal}set portal(e){this.hasAttached()&&!e&&!this._isInitialized||(this.hasAttached()&&super.detach(),e&&super.attach(e),this._attachedPortal=e||null)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedRef=this._attachedPortal=null}attachComponentPortal(e){e.setAttachedHost(this);const r=null!=e.viewContainerRef?e.viewContainerRef:this._viewContainerRef,o=(e.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(e.component),i=r.createComponent(o,r.length,e.injector||r.injector,e.projectableNodes||void 0);return r!==this._viewContainerRef&&this._getRootNode().appendChild(i.hostView.rootNodes[0]),super.setDisposeFn(()=>i.destroy()),this._attachedPortal=e,this._attachedRef=i,this.attached.emit(i),i}attachTemplatePortal(e){e.setAttachedHost(this);const r=this._viewContainerRef.createEmbeddedView(e.templateRef,e.context,{injector:e.injector});return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=e,this._attachedRef=r,this.attached.emit(r),r}_getRootNode(){const e=this._viewContainerRef.element.nativeElement;return e.nodeType===e.ELEMENT_NODE?e:e.parentNode}}return n.\u0275fac=function(e){return new(e||n)(Ve(Rd),Ve(fi),Ve(kn))},n.\u0275dir=It({type:n,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[$n]}),n})(),db=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({}),n})();const WR=RM();class Vie{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=hs(-this._previousScrollPosition.left),t.style.top=hs(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,r=t.style,s=this._document.body.style,o=r.scrollBehavior||"",i=s.scrollBehavior||"";this._isEnabled=!1,r.left=this._previousHTMLStyles.left,r.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),WR&&(r.scrollBehavior=s.scrollBehavior="auto"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),WR&&(r.scrollBehavior=o,s.scrollBehavior=i)}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const e=this._document.body,r=this._viewportRuler.getViewportSize();return e.scrollHeight>r.height||e.scrollWidth>r.width}}class Uie{constructor(t,e,r,s){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=r,this._config=s,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0).pipe(Or(e=>!e||!this._overlayRef.overlayElement.contains(e.getElementRef().nativeElement)));this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const e=this._viewportRuler.getViewportScrollPosition().top;Math.abs(e-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class jR{enable(){}disable(){}attach(){}}function RC(n,t){return t.some(e=>n.bottom<e.top||n.top>e.bottom||n.right<e.left||n.left>e.right)}function GR(n,t){return t.some(e=>n.top<e.top||n.bottom>e.bottom||n.left<e.left||n.right>e.right)}class zie{constructor(t,e,r,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=r,this._config=s,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const e=this._overlayRef.overlayElement.getBoundingClientRect(),{width:r,height:s}=this._viewportRuler.getViewportSize();RC(e,[{width:r,height:s,bottom:s,right:r,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let Hie=(()=>{class n{constructor(e,r,s,o){this._scrollDispatcher=e,this._viewportRuler=r,this._ngZone=s,this.noop=()=>new jR,this.close=i=>new Uie(this._scrollDispatcher,this._ngZone,this._viewportRuler,i),this.block=()=>new Vie(this._viewportRuler,this._document),this.reposition=i=>new zie(this._scrollDispatcher,this._viewportRuler,this._ngZone,i),this._document=o}}return n.\u0275fac=function(e){return new(e||n)(Ke(tb),Ke(gC),Ke(wn),Ke(kn))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class KR{constructor(t){if(this.scrollStrategy=new jR,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const r of e)void 0!==t[r]&&(this[r]=t[r])}}}class Wie{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}let XR=(()=>{class n{constructor(e){this._attachedOverlays=[],this._document=e}ngOnDestroy(){this.detach()}add(e){this.remove(e),this._attachedOverlays.push(e)}remove(e){const r=this._attachedOverlays.indexOf(e);r>-1&&this._attachedOverlays.splice(r,1),0===this._attachedOverlays.length&&this.detach()}}return n.\u0275fac=function(e){return new(e||n)(Ke(kn))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),jie=(()=>{class n extends XR{constructor(e,r){super(e),this._ngZone=r,this._keydownListener=s=>{const o=this._attachedOverlays;for(let i=o.length-1;i>-1;i--)if(o[i]._keydownEvents.observers.length>0){const a=o[i]._keydownEvents;this._ngZone?this._ngZone.run(()=>a.next(s)):a.next(s);break}}}add(e){super.add(e),this._isAttached||(this._ngZone?this._ngZone.runOutsideAngular(()=>this._document.body.addEventListener("keydown",this._keydownListener)):this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return n.\u0275fac=function(e){return new(e||n)(Ke(kn),Ke(wn,8))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Gie=(()=>{class n extends XR{constructor(e,r,s){super(e),this._platform=r,this._ngZone=s,this._cursorStyleIsSet=!1,this._pointerDownListener=o=>{this._pointerDownEventTarget=zc(o)},this._clickListener=o=>{const i=zc(o),a="click"===o.type&&this._pointerDownEventTarget?this._pointerDownEventTarget:i;this._pointerDownEventTarget=null;const l=this._attachedOverlays.slice();for(let c=l.length-1;c>-1;c--){const u=l[c];if(u._outsidePointerEvents.observers.length<1||!u.hasAttached())continue;if(u.overlayElement.contains(i)||u.overlayElement.contains(a))break;const d=u._outsidePointerEvents;this._ngZone?this._ngZone.run(()=>d.next(o)):d.next(o)}}}add(e){if(super.add(e),!this._isAttached){const r=this._document.body;this._ngZone?this._ngZone.runOutsideAngular(()=>this._addEventListeners(r)):this._addEventListeners(r),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=r.style.cursor,r.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0}}detach(){if(this._isAttached){const e=this._document.body;e.removeEventListener("pointerdown",this._pointerDownListener,!0),e.removeEventListener("click",this._clickListener,!0),e.removeEventListener("auxclick",this._clickListener,!0),e.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(e.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1}}_addEventListeners(e){e.addEventListener("pointerdown",this._pointerDownListener,!0),e.addEventListener("click",this._clickListener,!0),e.addEventListener("auxclick",this._clickListener,!0),e.addEventListener("contextmenu",this._clickListener,!0)}}return n.\u0275fac=function(e){return new(e||n)(Ke(kn),Ke(qs),Ke(wn,8))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),OC=(()=>{class n{constructor(e,r){this._platform=r,this._document=e}ngOnDestroy(){this._containerElement?.remove()}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const e="cdk-overlay-container";if(this._platform.isBrowser||fC()){const s=this._document.querySelectorAll(`.${e}[platform="server"], .${e}[platform="test"]`);for(let o=0;o<s.length;o++)s[o].remove()}const r=this._document.createElement("div");r.classList.add(e),fC()?r.setAttribute("platform","test"):this._platform.isBrowser||r.setAttribute("platform","server"),this._document.body.appendChild(r),this._containerElement=r}}return n.\u0275fac=function(e){return new(e||n)(Ke(kn),Ke(qs))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class FC{constructor(t,e,r,s,o,i,a,l,c,u=!1){this._portalOutlet=t,this._host=e,this._pane=r,this._config=s,this._ngZone=o,this._keyboardDispatcher=i,this._document=a,this._location=l,this._outsideClickDispatcher=c,this._animationsDisabled=u,this._backdropElement=null,this._backdropClick=new et,this._attachments=new et,this._detachments=new et,this._locationChanges=U.EMPTY,this._backdropClickHandler=d=>this._backdropClick.next(d),this._backdropTransitionendHandler=d=>{this._disposeBackdrop(d.target)},this._keydownEvents=new et,this._outsidePointerEvents=new et,s.scrollStrategy&&(this._scrollStrategy=s.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=s.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host);const e=this._portalOutlet.attach(t);return this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe(Jr(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),"function"==typeof e?.onDestroy&&e.onDestroy(()=>{this.hasAttached()&&this._ngZone.runOutsideAngular(()=>Promise.resolve().then(()=>this.detach()))}),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this._disposeBackdrop(this._backdropElement),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host?.remove(),this._previousHostParent=this._pane=this._host=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config={...this._config,...t},this._updateElementSize()}setDirection(t){this._config={...this._config,direction:t},this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=hs(this._config.width),t.height=hs(this._config.height),t.minWidth=hs(this._config.minWidth),t.minHeight=hs(this._config.minHeight),t.maxWidth=hs(this._config.maxWidth),t.maxHeight=hs(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"":"none"}_attachBackdrop(){const t="cdk-overlay-backdrop-showing";this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._animationsDisabled&&this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),!this._animationsDisabled&&typeof requestAnimationFrame<"u"?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(t)})}):this._backdropElement.classList.add(t)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){const t=this._backdropElement;if(t){if(this._animationsDisabled)return void this._disposeBackdrop(t);t.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{t.addEventListener("transitionend",this._backdropTransitionendHandler)}),t.style.pointerEvents="none",this._backdropTimeout=this._ngZone.runOutsideAngular(()=>setTimeout(()=>{this._disposeBackdrop(t)},500))}}_toggleClasses(t,e,r){const s=qy(e||[]).filter(o=>!!o);s.length&&(r?t.classList.add(...s):t.classList.remove(...s))}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.pipe(es(fs(this._attachments,this._detachments))).subscribe(()=>{(!this._pane||!this._host||0===this._pane.children.length)&&(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._host.remove()),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}_disposeBackdrop(t){t&&(t.removeEventListener("click",this._backdropClickHandler),t.removeEventListener("transitionend",this._backdropTransitionendHandler),t.remove(),this._backdropElement===t&&(this._backdropElement=null)),this._backdropTimeout&&(clearTimeout(this._backdropTimeout),this._backdropTimeout=void 0)}}const qR="cdk-overlay-connected-position-bounding-box",Kie=/([A-Za-z%]+)$/;class Xie{get positions(){return this._preferredPositions}constructor(t,e,r,s,o){this._viewportRuler=e,this._document=r,this._platform=s,this._overlayContainer=o,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new et,this._resizeSubscription=U.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}attach(t){this._validatePositions(),t.hostElement.classList.add(qR),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const t=this._originRect,e=this._overlayRect,r=this._viewportRect,s=this._containerRect,o=[];let i;for(let a of this._preferredPositions){let l=this._getOriginPoint(t,s,a),c=this._getOverlayPoint(l,e,a),u=this._getOverlayFit(c,e,r,a);if(u.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(a,l);this._canFitWithFlexibleDimensions(u,c,r)?o.push({position:a,origin:l,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(l,a)}):(!i||i.overlayFit.visibleArea<u.visibleArea)&&(i={overlayFit:u,overlayPoint:c,originPoint:l,position:a,overlayRect:e})}if(o.length){let a=null,l=-1;for(const c of o){const u=c.boundingBoxRect.width*c.boundingBoxRect.height*(c.position.weight||1);u>l&&(l=u,a=c)}return this._isPushed=!1,void this._applyPosition(a.position,a.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(i.position,i.originPoint);this._applyPosition(i.position,i.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&qu(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(qR),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(this._isDisposed||!this._platform.isBrowser)return;const t=this._lastPosition;if(t){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const e=this._getOriginPoint(this._originRect,this._containerRect,t);this._applyPosition(t,e)}else this.apply()}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e,r){let s,o;if("center"==r.originX)s=t.left+t.width/2;else{const i=this._isRtl()?t.right:t.left,a=this._isRtl()?t.left:t.right;s="start"==r.originX?i:a}return e.left<0&&(s-=e.left),o="center"==r.originY?t.top+t.height/2:"top"==r.originY?t.top:t.bottom,e.top<0&&(o-=e.top),{x:s,y:o}}_getOverlayPoint(t,e,r){let s,o;return s="center"==r.overlayX?-e.width/2:"start"===r.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,o="center"==r.overlayY?-e.height/2:"top"==r.overlayY?0:-e.height,{x:t.x+s,y:t.y+o}}_getOverlayFit(t,e,r,s){const o=YR(e);let{x:i,y:a}=t,l=this._getOffset(s,"x"),c=this._getOffset(s,"y");l&&(i+=l),c&&(a+=c);let p=0-a,m=a+o.height-r.height,y=this._subtractOverflows(o.width,0-i,i+o.width-r.width),_=this._subtractOverflows(o.height,p,m),C=y*_;return{visibleArea:C,isCompletelyWithinViewport:o.width*o.height===C,fitsInViewportVertically:_===o.height,fitsInViewportHorizontally:y==o.width}}_canFitWithFlexibleDimensions(t,e,r){if(this._hasFlexibleDimensions){const s=r.bottom-e.y,o=r.right-e.x,i=ZR(this._overlayRef.getConfig().minHeight),a=ZR(this._overlayRef.getConfig().minWidth);return(t.fitsInViewportVertically||null!=i&&i<=s)&&(t.fitsInViewportHorizontally||null!=a&&a<=o)}return!1}_pushOverlayOnScreen(t,e,r){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const s=YR(e),o=this._viewportRect,i=Math.max(t.x+s.width-o.width,0),a=Math.max(t.y+s.height-o.height,0),l=Math.max(o.top-r.top-t.y,0),c=Math.max(o.left-r.left-t.x,0);let u=0,d=0;return u=s.width<=o.width?c||-i:t.x<this._viewportMargin?o.left-r.left-t.x:0,d=s.height<=o.height?l||-a:t.y<this._viewportMargin?o.top-r.top-t.y:0,this._previousPushAmount={x:u,y:d},{x:t.x+u,y:t.y+d}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const r=this._getScrollVisibility(),s=new Wie(t,r);this._positionChanges.next(s)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let r,s=t.overlayY;r="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let o=0;o<e.length;o++)e[o].style.transformOrigin=`${r} ${s}`}_calculateBoundingBoxRect(t,e){const r=this._viewportRect,s=this._isRtl();let o,i,a,u,d,p;if("top"===e.overlayY)i=t.y,o=r.height-i+this._viewportMargin;else if("bottom"===e.overlayY)a=r.height-t.y+2*this._viewportMargin,o=r.height-a+this._viewportMargin;else{const m=Math.min(r.bottom-t.y+r.top,t.y),y=this._lastBoundingBoxSize.height;o=2*m,i=t.y-m,o>y&&!this._isInitialRender&&!this._growAfterOpen&&(i=t.y-y/2)}if("end"===e.overlayX&&!s||"start"===e.overlayX&&s)p=r.width-t.x+this._viewportMargin,u=t.x-this._viewportMargin;else if("start"===e.overlayX&&!s||"end"===e.overlayX&&s)d=t.x,u=r.right-t.x;else{const m=Math.min(r.right-t.x+r.left,t.x),y=this._lastBoundingBoxSize.width;u=2*m,d=t.x-m,u>y&&!this._isInitialRender&&!this._growAfterOpen&&(d=t.x-y/2)}return{top:i,left:d,bottom:a,right:p,width:u,height:o}}_setBoundingBoxStyles(t,e){const r=this._calculateBoundingBoxRect(t,e);!this._isInitialRender&&!this._growAfterOpen&&(r.height=Math.min(r.height,this._lastBoundingBoxSize.height),r.width=Math.min(r.width,this._lastBoundingBoxSize.width));const s={};if(this._hasExactPosition())s.top=s.left="0",s.bottom=s.right=s.maxHeight=s.maxWidth="",s.width=s.height="100%";else{const o=this._overlayRef.getConfig().maxHeight,i=this._overlayRef.getConfig().maxWidth;s.height=hs(r.height),s.top=hs(r.top),s.bottom=hs(r.bottom),s.width=hs(r.width),s.left=hs(r.left),s.right=hs(r.right),s.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",s.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",o&&(s.maxHeight=hs(o)),i&&(s.maxWidth=hs(i))}this._lastBoundingBoxSize=r,qu(this._boundingBox.style,s)}_resetBoundingBoxStyles(){qu(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){qu(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const r={},s=this._hasExactPosition(),o=this._hasFlexibleDimensions,i=this._overlayRef.getConfig();if(s){const u=this._viewportRuler.getViewportScrollPosition();qu(r,this._getExactOverlayY(e,t,u)),qu(r,this._getExactOverlayX(e,t,u))}else r.position="static";let a="",l=this._getOffset(e,"x"),c=this._getOffset(e,"y");l&&(a+=`translateX(${l}px) `),c&&(a+=`translateY(${c}px)`),r.transform=a.trim(),i.maxHeight&&(s?r.maxHeight=hs(i.maxHeight):o&&(r.maxHeight="")),i.maxWidth&&(s?r.maxWidth=hs(i.maxWidth):o&&(r.maxWidth="")),qu(this._pane.style,r)}_getExactOverlayY(t,e,r){let s={top:"",bottom:""},o=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(o=this._pushOverlayOnScreen(o,this._overlayRect,r)),"bottom"===t.overlayY?s.bottom=this._document.documentElement.clientHeight-(o.y+this._overlayRect.height)+"px":s.top=hs(o.y),s}_getExactOverlayX(t,e,r){let i,s={left:"",right:""},o=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(o=this._pushOverlayOnScreen(o,this._overlayRect,r)),i=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===i?s.right=this._document.documentElement.clientWidth-(o.x+this._overlayRect.width)+"px":s.left=hs(o.x),s}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),r=this._scrollables.map(s=>s.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:GR(t,r),isOriginOutsideView:RC(t,r),isOverlayClipped:GR(e,r),isOverlayOutsideView:RC(e,r)}}_subtractOverflows(t,...e){return e.reduce((r,s)=>r-Math.max(s,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,r=this._viewportRuler.getViewportScrollPosition();return{top:r.top+this._viewportMargin,left:r.left+this._viewportMargin,right:r.left+t-this._viewportMargin,bottom:r.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?null==t.offsetX?this._offsetX:t.offsetX:null==t.offsetY?this._offsetY:t.offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&&qy(t).forEach(e=>{""!==e&&-1===this._appliedPanelClasses.indexOf(e)&&(this._appliedPanelClasses.push(e),this._pane.classList.add(e))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof tr)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,r=t.height||0;return{top:t.y,bottom:t.y+r,left:t.x,right:t.x+e,height:r,width:e}}}function qu(n,t){for(let e in t)t.hasOwnProperty(e)&&(n[e]=t[e]);return n}function ZR(n){if("number"!=typeof n&&null!=n){const[t,e]=n.split(Kie);return e&&"px"!==e?null:parseFloat(t)}return n||null}function YR(n){return{top:Math.floor(n.top),right:Math.floor(n.right),bottom:Math.floor(n.bottom),left:Math.floor(n.left),width:Math.floor(n.width),height:Math.floor(n.height)}}const QR="cdk-global-overlay-wrapper";class qie{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._alignItems="",this._xPosition="",this._xOffset="",this._width="",this._height="",this._isDisposed=!1}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add(QR),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._xOffset=t,this._xPosition="left",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._xOffset=t,this._xPosition="right",this}start(t=""){return this._xOffset=t,this._xPosition="start",this}end(t=""){return this._xOffset=t,this._xPosition="end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._xPosition="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,r=this._overlayRef.getConfig(),{width:s,height:o,maxWidth:i,maxHeight:a}=r,l=!("100%"!==s&&"100vw"!==s||i&&"100%"!==i&&"100vw"!==i),c=!("100%"!==o&&"100vh"!==o||a&&"100%"!==a&&"100vh"!==a),u=this._xPosition,d=this._xOffset,p="rtl"===this._overlayRef.getConfig().direction;let m="",y="",_="";l?_="flex-start":"center"===u?(_="center",p?y=d:m=d):p?"left"===u||"end"===u?(_="flex-end",m=d):("right"===u||"start"===u)&&(_="flex-start",y=d):"left"===u||"start"===u?(_="flex-start",m=d):("right"===u||"end"===u)&&(_="flex-end",y=d),t.position=this._cssPosition,t.marginLeft=l?"0":m,t.marginTop=c?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=l?"0":y,e.justifyContent=_,e.alignItems=c?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,r=e.style;e.classList.remove(QR),r.justifyContent=r.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let Zie=(()=>{class n{constructor(e,r,s,o){this._viewportRuler=e,this._document=r,this._platform=s,this._overlayContainer=o}global(){return new qie}flexibleConnectedTo(e){return new Xie(e,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return n.\u0275fac=function(e){return new(e||n)(Ke(gC),Ke(kn),Ke(qs),Ke(OC))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Yie=0,Oh=(()=>{class n{constructor(e,r,s,o,i,a,l,c,u,d,p,m){this.scrollStrategies=e,this._overlayContainer=r,this._componentFactoryResolver=s,this._positionBuilder=o,this._keyboardDispatcher=i,this._injector=a,this._ngZone=l,this._document=c,this._directionality=u,this._location=d,this._outsideClickDispatcher=p,this._animationsModuleType=m}create(e){const r=this._createHostElement(),s=this._createPaneElement(r),o=this._createPortalOutlet(s),i=new KR(e);return i.direction=i.direction||this._directionality.value,new FC(o,r,s,i,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher,"NoopAnimations"===this._animationsModuleType)}position(){return this._positionBuilder}_createPaneElement(e){const r=this._document.createElement("div");return r.id="cdk-overlay-"+Yie++,r.classList.add("cdk-overlay-pane"),e.appendChild(r),r}_createHostElement(){const e=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(e),e}_createPortalOutlet(e){return this._appRef||(this._appRef=this._injector.get(Ll)),new Bie(e,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return n.\u0275fac=function(e){return new(e||n)(Ke(Hie),Ke(OC),Ke(Rd),Ke(Zie),Ke(jie),Ke(Gs),Ke(wn),Ke(kn),Ke(Dh),Ke(zg),Ke(Gie),Ke(Rl,8))},n.\u0275prov=b({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const eae={provide:new Ct("cdk-connected-overlay-scroll-strategy"),deps:[Oh],useFactory:function Jie(n){return()=>n.scrollStrategies.reposition()}};let JR=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({providers:[Oh,eae],imports:[Rf,db,OM,OM]}),n})();const tae=["tooltip"],eO=new Ct("mat-tooltip-scroll-strategy"),sae={provide:eO,deps:[Oh],useFactory:function rae(n){return()=>n.scrollStrategies.reposition({scrollThrottle:20})}},iae=new Ct("mat-tooltip-default-options",{providedIn:"root",factory:function oae(){return{showDelay:0,hideDelay:0,touchendHideDelay:1500}}}),tO="tooltip-panel",nO=kf({passive:!0});let hae=(()=>{class n{get position(){return this._position}set position(e){e!==this._position&&(this._position=e,this._overlayRef&&(this._updatePosition(this._overlayRef),this._tooltipInstance?.show(0),this._overlayRef.updatePosition()))}get positionAtOrigin(){return this._positionAtOrigin}set positionAtOrigin(e){this._positionAtOrigin=Oo(e),this._detach(),this._overlayRef=null}get disabled(){return this._disabled}set disabled(e){this._disabled=Oo(e),this._disabled?this.hide(0):this._setupPointerEnterEventsIfNeeded()}get showDelay(){return this._showDelay}set showDelay(e){this._showDelay=DM(e)}get hideDelay(){return this._hideDelay}set hideDelay(e){this._hideDelay=DM(e),this._tooltipInstance&&(this._tooltipInstance._mouseLeaveHideDelay=this._hideDelay)}get message(){return this._message}set message(e){this._ariaDescriber.removeDescription(this._elementRef.nativeElement,this._message,"tooltip"),this._message=null!=e?String(e).trim():"",!this._message&&this._isTooltipVisible()?this.hide(0):(this._setupPointerEnterEventsIfNeeded(),this._updateTooltipMessage(),this._ngZone.runOutsideAngular(()=>{Promise.resolve().then(()=>{this._ariaDescriber.describe(this._elementRef.nativeElement,this.message,"tooltip")})}))}get tooltipClass(){return this._tooltipClass}set tooltipClass(e){this._tooltipClass=e,this._tooltipInstance&&this._setTooltipClass(this._tooltipClass)}constructor(e,r,s,o,i,a,l,c,u,d,p,m){this._overlay=e,this._elementRef=r,this._scrollDispatcher=s,this._viewContainerRef=o,this._ngZone=i,this._platform=a,this._ariaDescriber=l,this._focusMonitor=c,this._dir=d,this._defaultOptions=p,this._position="below",this._positionAtOrigin=!1,this._disabled=!1,this._viewInitialized=!1,this._pointerExitEventsInitialized=!1,this._viewportMargin=8,this._cssClassPrefix="mat",this.touchGestures="auto",this._message="",this._passiveListeners=[],this._destroyed=new et,this._scrollStrategy=u,this._document=m,p&&(this._showDelay=p.showDelay,this._hideDelay=p.hideDelay,p.position&&(this.position=p.position),p.positionAtOrigin&&(this.positionAtOrigin=p.positionAtOrigin),p.touchGestures&&(this.touchGestures=p.touchGestures)),d.change.pipe(es(this._destroyed)).subscribe(()=>{this._overlayRef&&this._updatePosition(this._overlayRef)})}ngAfterViewInit(){this._viewInitialized=!0,this._setupPointerEnterEventsIfNeeded(),this._focusMonitor.monitor(this._elementRef).pipe(es(this._destroyed)).subscribe(e=>{e?"keyboard"===e&&this._ngZone.run(()=>this.show()):this._ngZone.run(()=>this.hide(0))})}ngOnDestroy(){const e=this._elementRef.nativeElement;clearTimeout(this._touchstartTimeout),this._overlayRef&&(this._overlayRef.dispose(),this._tooltipInstance=null),this._passiveListeners.forEach(([r,s])=>{e.removeEventListener(r,s,nO)}),this._passiveListeners.length=0,this._destroyed.next(),this._destroyed.complete(),this._ariaDescriber.removeDescription(e,this.message,"tooltip"),this._focusMonitor.stopMonitoring(e)}show(e=this.showDelay,r){if(this.disabled||!this.message||this._isTooltipVisible())return void this._tooltipInstance?._cancelPendingAnimations();const s=this._createOverlay(r);this._detach(),this._portal=this._portal||new ub(this._tooltipComponent,this._viewContainerRef);const o=this._tooltipInstance=s.attach(this._portal).instance;o._triggerElement=this._elementRef.nativeElement,o._mouseLeaveHideDelay=this._hideDelay,o.afterHidden().pipe(es(this._destroyed)).subscribe(()=>this._detach()),this._setTooltipClass(this._tooltipClass),this._updateTooltipMessage(),o.show(e)}hide(e=this.hideDelay){const r=this._tooltipInstance;r&&(r.isVisible()?r.hide(e):(r._cancelPendingAnimations(),this._detach()))}toggle(e){this._isTooltipVisible()?this.hide():this.show(void 0,e)}_isTooltipVisible(){return!!this._tooltipInstance&&this._tooltipInstance.isVisible()}_createOverlay(e){if(this._overlayRef){const o=this._overlayRef.getConfig().positionStrategy;if((!this.positionAtOrigin||!e)&&o._origin instanceof tr)return this._overlayRef;this._detach()}const r=this._scrollDispatcher.getAncestorScrollContainers(this._elementRef),s=this._overlay.position().flexibleConnectedTo(this.positionAtOrigin&&e||this._elementRef).withTransformOriginOn(`.${this._cssClassPrefix}-tooltip`).withFlexibleDimensions(!1).withViewportMargin(this._viewportMargin).withScrollableContainers(r);return s.positionChanges.pipe(es(this._destroyed)).subscribe(o=>{this._updateCurrentPositionClass(o.connectionPair),this._tooltipInstance&&o.scrollableViewProperties.isOverlayClipped&&this._tooltipInstance.isVisible()&&this._ngZone.run(()=>this.hide(0))}),this._overlayRef=this._overlay.create({direction:this._dir,positionStrategy:s,panelClass:`${this._cssClassPrefix}-${tO}`,scrollStrategy:this._scrollStrategy()}),this._updatePosition(this._overlayRef),this._overlayRef.detachments().pipe(es(this._destroyed)).subscribe(()=>this._detach()),this._overlayRef.outsidePointerEvents().pipe(es(this._destroyed)).subscribe(()=>this._tooltipInstance?._handleBodyInteraction()),this._overlayRef.keydownEvents().pipe(es(this._destroyed)).subscribe(o=>{this._isTooltipVisible()&&27===o.keyCode&&!bC(o)&&(o.preventDefault(),o.stopPropagation(),this._ngZone.run(()=>this.hide(0)))}),this._defaultOptions?.disableTooltipInteractivity&&this._overlayRef.addPanelClass(`${this._cssClassPrefix}-tooltip-panel-non-interactive`),this._overlayRef}_detach(){this._overlayRef&&this._overlayRef.hasAttached()&&this._overlayRef.detach(),this._tooltipInstance=null}_updatePosition(e){const r=e.getConfig().positionStrategy,s=this._getOrigin(),o=this._getOverlayPosition();r.withPositions([this._addOffset({...s.main,...o.main}),this._addOffset({...s.fallback,...o.fallback})])}_addOffset(e){return e}_getOrigin(){const e=!this._dir||"ltr"==this._dir.value,r=this.position;let s;"above"==r||"below"==r?s={originX:"center",originY:"above"==r?"top":"bottom"}:"before"==r||"left"==r&&e||"right"==r&&!e?s={originX:"start",originY:"center"}:("after"==r||"right"==r&&e||"left"==r&&!e)&&(s={originX:"end",originY:"center"});const{x:o,y:i}=this._invertPosition(s.originX,s.originY);return{main:s,fallback:{originX:o,originY:i}}}_getOverlayPosition(){const e=!this._dir||"ltr"==this._dir.value,r=this.position;let s;"above"==r?s={overlayX:"center",overlayY:"bottom"}:"below"==r?s={overlayX:"center",overlayY:"top"}:"before"==r||"left"==r&&e||"right"==r&&!e?s={overlayX:"end",overlayY:"center"}:("after"==r||"right"==r&&e||"left"==r&&!e)&&(s={overlayX:"start",overlayY:"center"});const{x:o,y:i}=this._invertPosition(s.overlayX,s.overlayY);return{main:s,fallback:{overlayX:o,overlayY:i}}}_updateTooltipMessage(){this._tooltipInstance&&(this._tooltipInstance.message=this.message,this._tooltipInstance._markForCheck(),this._ngZone.onMicrotaskEmpty.pipe(Jr(1),es(this._destroyed)).subscribe(()=>{this._tooltipInstance&&this._overlayRef.updatePosition()}))}_setTooltipClass(e){this._tooltipInstance&&(this._tooltipInstance.tooltipClass=e,this._tooltipInstance._markForCheck())}_invertPosition(e,r){return"above"===this.position||"below"===this.position?"top"===r?r="bottom":"bottom"===r&&(r="top"):"end"===e?e="start":"start"===e&&(e="end"),{x:e,y:r}}_updateCurrentPositionClass(e){const{overlayY:r,originX:s,originY:o}=e;let i;if(i="center"===r?this._dir&&"rtl"===this._dir.value?"end"===s?"left":"right":"start"===s?"left":"right":"bottom"===r&&"top"===o?"above":"below",i!==this._currentPosition){const a=this._overlayRef;if(a){const l=`${this._cssClassPrefix}-${tO}-`;a.removePanelClass(l+this._currentPosition),a.addPanelClass(l+i)}this._currentPosition=i}}_setupPointerEnterEventsIfNeeded(){this._disabled||!this.message||!this._viewInitialized||this._passiveListeners.length||(this._platformSupportsMouseEvents()?this._passiveListeners.push(["mouseenter",e=>{let r;this._setupPointerExitEventsIfNeeded(),void 0!==e.x&&void 0!==e.y&&(r=e),this.show(void 0,r)}]):"off"!==this.touchGestures&&(this._disableNativeGesturesIfNecessary(),this._passiveListeners.push(["touchstart",e=>{const r=e.targetTouches?.[0],s=r?{x:r.clientX,y:r.clientY}:void 0;this._setupPointerExitEventsIfNeeded(),clearTimeout(this._touchstartTimeout),this._touchstartTimeout=setTimeout(()=>this.show(void 0,s),500)}])),this._addListeners(this._passiveListeners))}_setupPointerExitEventsIfNeeded(){if(this._pointerExitEventsInitialized)return;this._pointerExitEventsInitialized=!0;const e=[];if(this._platformSupportsMouseEvents())e.push(["mouseleave",r=>{const s=r.relatedTarget;(!s||!this._overlayRef?.overlayElement.contains(s))&&this.hide()}],["wheel",r=>this._wheelListener(r)]);else if("off"!==this.touchGestures){this._disableNativeGesturesIfNecessary();const r=()=>{clearTimeout(this._touchstartTimeout),this.hide(this._defaultOptions.touchendHideDelay)};e.push(["touchend",r],["touchcancel",r])}this._addListeners(e),this._passiveListeners.push(...e)}_addListeners(e){e.forEach(([r,s])=>{this._elementRef.nativeElement.addEventListener(r,s,nO)})}_platformSupportsMouseEvents(){return!this._platform.IOS&&!this._platform.ANDROID}_wheelListener(e){if(this._isTooltipVisible()){const r=this._document.elementFromPoint(e.clientX,e.clientY),s=this._elementRef.nativeElement;r!==s&&!s.contains(r)&&this.hide()}}_disableNativeGesturesIfNecessary(){const e=this.touchGestures;if("off"!==e){const r=this._elementRef.nativeElement,s=r.style;("on"===e||"INPUT"!==r.nodeName&&"TEXTAREA"!==r.nodeName)&&(s.userSelect=s.msUserSelect=s.webkitUserSelect=s.MozUserSelect="none"),("on"===e||!r.draggable)&&(s.webkitUserDrag="none"),s.touchAction="none",s.webkitTapHighlightColor="transparent"}}}return n.\u0275fac=function(e){pg()},n.\u0275dir=It({type:n,inputs:{position:["matTooltipPosition","position"],positionAtOrigin:["matTooltipPositionAtOrigin","positionAtOrigin"],disabled:["matTooltipDisabled","disabled"],showDelay:["matTooltipShowDelay","showDelay"],hideDelay:["matTooltipHideDelay","hideDelay"],touchGestures:["matTooltipTouchGestures","touchGestures"],message:["matTooltip","message"],tooltipClass:["matTooltipClass","tooltipClass"]}}),n})(),pae=(()=>{class n extends hae{constructor(e,r,s,o,i,a,l,c,u,d,p,m){super(e,r,s,o,i,a,l,c,u,d,p,m),this._tooltipComponent=mae,this._cssClassPrefix="mat-mdc",this._viewportMargin=8}_addOffset(e){const s=!this._dir||"ltr"==this._dir.value;return"top"===e.originY?e.offsetY=-8:"bottom"===e.originY?e.offsetY=8:"start"===e.originX?e.offsetX=s?-8:8:"end"===e.originX&&(e.offsetX=s?8:-8),e}}return n.\u0275fac=function(e){return new(e||n)(Ve(Oh),Ve(tr),Ve(tb),Ve(fi),Ve(wn),Ve(qs),Ve(Qse),Ve(Ff),Ve(eO),Ve(Dh,8),Ve(iae,8),Ve(kn))},n.\u0275dir=It({type:n,selectors:[["","matTooltip",""]],hostAttrs:[1,"mat-mdc-tooltip-trigger"],exportAs:["matTooltip"],features:[$n]}),n})(),fae=(()=>{class n{constructor(e,r){this._changeDetectorRef=e,this._closeOnInteraction=!1,this._isVisible=!1,this._onHide=new et,this._animationsDisabled="NoopAnimations"===r}show(e){null!=this._hideTimeoutId&&clearTimeout(this._hideTimeoutId),this._showTimeoutId=setTimeout(()=>{this._toggleVisibility(!0),this._showTimeoutId=void 0},e)}hide(e){null!=this._showTimeoutId&&clearTimeout(this._showTimeoutId),this._hideTimeoutId=setTimeout(()=>{this._toggleVisibility(!1),this._hideTimeoutId=void 0},e)}afterHidden(){return this._onHide}isVisible(){return this._isVisible}ngOnDestroy(){this._cancelPendingAnimations(),this._onHide.complete(),this._triggerElement=null}_handleBodyInteraction(){this._closeOnInteraction&&this.hide(0)}_markForCheck(){this._changeDetectorRef.markForCheck()}_handleMouseLeave({relatedTarget:e}){(!e||!this._triggerElement.contains(e))&&(this.isVisible()?this.hide(this._mouseLeaveHideDelay):this._finalizeAnimation(!1))}_onShow(){}_handleAnimationEnd({animationName:e}){(e===this._showAnimation||e===this._hideAnimation)&&this._finalizeAnimation(e===this._showAnimation)}_cancelPendingAnimations(){null!=this._showTimeoutId&&clearTimeout(this._showTimeoutId),null!=this._hideTimeoutId&&clearTimeout(this._hideTimeoutId),this._showTimeoutId=this._hideTimeoutId=void 0}_finalizeAnimation(e){e?this._closeOnInteraction=!0:this.isVisible()||this._onHide.next()}_toggleVisibility(e){const r=this._tooltip.nativeElement,s=this._showAnimation,o=this._hideAnimation;if(r.classList.remove(e?o:s),r.classList.add(e?s:o),this._isVisible=e,e&&!this._animationsDisabled&&"function"==typeof getComputedStyle){const i=getComputedStyle(r);("0s"===i.getPropertyValue("animation-duration")||"none"===i.getPropertyValue("animation-name"))&&(this._animationsDisabled=!0)}e&&this._onShow(),this._animationsDisabled&&(r.classList.add("_mat-animation-noopable"),this._finalizeAnimation(e))}}return n.\u0275fac=function(e){return new(e||n)(Ve(tl),Ve(Rl,8))},n.\u0275dir=It({type:n}),n})(),mae=(()=>{class n extends fae{constructor(e,r,s){super(e,s),this._elementRef=r,this._isMultiline=!1,this._showAnimation="mat-mdc-tooltip-show",this._hideAnimation="mat-mdc-tooltip-hide"}_onShow(){this._isMultiline=this._isTooltipMultiline(),this._markForCheck()}_isTooltipMultiline(){const e=this._elementRef.nativeElement.getBoundingClientRect();return e.height>24&&e.width>=200}}return n.\u0275fac=function(e){return new(e||n)(Ve(tl),Ve(tr),Ve(Rl,8))},n.\u0275cmp=ys({type:n,selectors:[["mat-tooltip-component"]],viewQuery:function(e,r){if(1&e&&Ac(tae,7),2&e){let s;mi(s=gi())&&(r._tooltip=s.first)}},hostAttrs:["aria-hidden","true"],hostVars:2,hostBindings:function(e,r){1&e&&Zr("mouseleave",function(o){return r._handleMouseLeave(o)}),2&e&&Dg("zoom",r.isVisible()?1:null)},features:[$n],decls:4,vars:4,consts:[[1,"mdc-tooltip","mdc-tooltip--shown","mat-mdc-tooltip",3,"ngClass","animationend"],["tooltip",""],[1,"mdc-tooltip__surface","mdc-tooltip__surface-animation"]],template:function(e,r){1&e&&(Nr(0,"div",0,1),Zr("animationend",function(o){return r._handleAnimationEnd(o)}),Nr(2,"div",2),$l(3),Cs()()),2&e&&(fo("mdc-tooltip--multiline",r._isMultiline),pa("ngClass",r.tooltipClass),Tc(3),Wv(r.message))},dependencies:[u1],styles:['.mdc-tooltip__surface{word-break:var(--mdc-tooltip-word-break, normal);overflow-wrap:anywhere}.mdc-tooltip{position:fixed;display:none;z-index:9}.mdc-tooltip-wrapper--rich{position:relative}.mdc-tooltip--shown,.mdc-tooltip--showing,.mdc-tooltip--hide{display:inline-flex}.mdc-tooltip--shown.mdc-tooltip--rich,.mdc-tooltip--showing.mdc-tooltip--rich,.mdc-tooltip--hide.mdc-tooltip--rich{display:inline-block;left:-320px;position:absolute}.mdc-tooltip__surface{line-height:16px;padding:4px 8px;min-width:40px;max-width:200px;min-height:24px;max-height:40vh;box-sizing:border-box;overflow:hidden;text-align:center}.mdc-tooltip__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-tooltip__surface::before{border-color:CanvasText}}.mdc-tooltip--rich .mdc-tooltip__surface{align-items:flex-start;display:flex;flex-direction:column;min-height:24px;min-width:40px;max-width:320px;position:relative}.mdc-tooltip--multiline .mdc-tooltip__surface{text-align:left}[dir=rtl] .mdc-tooltip--multiline .mdc-tooltip__surface,.mdc-tooltip--multiline .mdc-tooltip__surface[dir=rtl]{text-align:right}.mdc-tooltip__surface .mdc-tooltip__title{margin:0 8px}.mdc-tooltip__surface .mdc-tooltip__content{max-width:calc(200px - (2 * 8px));margin:8px;text-align:left}[dir=rtl] .mdc-tooltip__surface .mdc-tooltip__content,.mdc-tooltip__surface .mdc-tooltip__content[dir=rtl]{text-align:right}.mdc-tooltip--rich .mdc-tooltip__surface .mdc-tooltip__content{max-width:calc(320px - (2 * 8px));align-self:stretch}.mdc-tooltip__surface .mdc-tooltip__content-link{text-decoration:none}.mdc-tooltip--rich-actions,.mdc-tooltip__content,.mdc-tooltip__title{z-index:1}.mdc-tooltip__surface-animation{opacity:0;transform:scale(0.8);will-change:transform,opacity}.mdc-tooltip--shown .mdc-tooltip__surface-animation{transform:scale(1);opacity:1}.mdc-tooltip--hide .mdc-tooltip__surface-animation{transform:scale(1)}.mdc-tooltip__caret-surface-top,.mdc-tooltip__caret-surface-bottom{position:absolute;height:24px;width:24px;transform:rotate(35deg) skewY(20deg) scaleX(0.9396926208)}.mdc-tooltip__caret-surface-top .mdc-elevation-overlay,.mdc-tooltip__caret-surface-bottom .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-tooltip__caret-surface-bottom{outline:1px solid rgba(0,0,0,0);z-index:-1}@media screen and (forced-colors: active){.mdc-tooltip__caret-surface-bottom{outline-color:CanvasText}}.mdc-tooltip__surface{background-color:var(--mdc-plain-tooltip-container-color, #fff)}.mdc-tooltip__surface{border-radius:var(--mdc-plain-tooltip-container-shape, var(--mdc-shape-small, 4px))}.mdc-tooltip__caret-surface-top,.mdc-tooltip__caret-surface-bottom{border-radius:var(--mdc-plain-tooltip-container-shape, var(--mdc-shape-small, 4px))}.mdc-tooltip__surface{color:var(--mdc-plain-tooltip-supporting-text-color, #000)}.mdc-tooltip__surface{font-family:var(--mdc-plain-tooltip-supporting-text-font, inherit);font-size:var(--mdc-plain-tooltip-supporting-text-size, inherit);font-weight:var(--mdc-plain-tooltip-supporting-text-weight, inherit);letter-spacing:var(--mdc-plain-tooltip-supporting-text-tracking, inherit)}.mat-mdc-tooltip{position:relative;transform:scale(0)}.mat-mdc-tooltip::before{content:"";top:0;right:0;bottom:0;left:0;z-index:-1;position:absolute}.mat-mdc-tooltip-panel-below .mat-mdc-tooltip::before{top:-8px}.mat-mdc-tooltip-panel-above .mat-mdc-tooltip::before{bottom:-8px}.mat-mdc-tooltip-panel-right .mat-mdc-tooltip::before{left:-8px}.mat-mdc-tooltip-panel-left .mat-mdc-tooltip::before{right:-8px}.mat-mdc-tooltip._mat-animation-noopable{animation:none;transform:scale(1)}.mat-mdc-tooltip-panel-non-interactive{pointer-events:none}@keyframes mat-mdc-tooltip-show{0%{opacity:0;transform:scale(0.8)}100%{opacity:1;transform:scale(1)}}@keyframes mat-mdc-tooltip-hide{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0.8)}}.mat-mdc-tooltip-show{animation:mat-mdc-tooltip-show 150ms cubic-bezier(0, 0, 0.2, 1) forwards}.mat-mdc-tooltip-hide{animation:mat-mdc-tooltip-hide 75ms cubic-bezier(0.4, 0, 1, 1) forwards}'],encapsulation:2,changeDetection:0}),n})(),gae=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({providers:[sae],imports:[QM,Qg,JR,Os,Os,Of]}),n})();const yae=["video"],bae=["canvas"];let _ae=(()=>{class n{constructor(){this.predict=!1,this.webCamWidth=1,this.webCamHeight=1}ngOnInit(){}start(){var e=this;return(0,xa.Z)(function*(){const r={audio:!1,video:{width:{min:1024,ideal:1920,max:1920},height:{min:576,ideal:1080,max:1080},facingMode:"environment"}};try{e.webCam=yield navigator.mediaDevices.getUserMedia(r);const s=e.webCam?.getVideoTracks()[0]?.getSettings();e.webCamWidth=s.width||1,e.webCamHeight=s.height||1}catch(s){alert(s)}})()}stop(){var e=this;return(0,xa.Z)(function*(){try{e.webCam?.getTracks().forEach(r=>r.stop()),e.webCam=void 0,e.stopPrediction()}catch(r){console.error("Error accessing the webcam",r)}})()}predictWithCocoModel(){var e=this;return(0,xa.Z)(function*(){if(!e.predict)try{e.predict=!0;const r=yield kj.load({base:"lite_mobilenet_v2"});e.detectFrame(e.video?.nativeElement,r)}catch(r){alert(r)}})()}stopPrediction(){this.predict=!1;const e=this.canvas?.nativeElement.getContext("2d");e&&e.clearRect(0,0,e.canvas.width,e.canvas.height)}detectFrame(e,r){this.predict&&r.detect(e).then(s=>{this.renderPredictions(s),requestAnimationFrame(()=>{this.detectFrame(e,r)})})}renderPredictions(e){const r=this.canvas?.nativeElement.getContext("2d"),s=r.canvas.width/this.webCamWidth,o=r.canvas.height/this.webCamHeight;if(!r)return;r.clearRect(0,0,r.canvas.width,r.canvas.height);const i="16px sans-serif";r.font=i,r.textBaseline="top",e.forEach(a=>{const l=s*a.bbox[0],c=o*a.bbox[1],u=s*a.bbox[2],d=o*a.bbox[3];r.strokeStyle="#00FFFF",r.lineWidth=2,r.strokeRect(l,c,u,d),r.fillStyle="#00FFFF";const p=r.measureText(a.class).width,m=parseInt(i,10);r.fillRect(l,c,p+4,m+4)}),e.forEach(a=>{const l=s*a.bbox[0],c=o*a.bbox[1];r.fillStyle="#000000",r.fillText(a.class,l,c)})}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=ys({type:n,selectors:[["app-root"]],viewQuery:function(e,r){if(1&e&&(Ac(yae,5),Ac(bae,5)),2&e){let s;mi(s=gi())&&(r.video=s.first),mi(s=gi())&&(r.canvas=s.first)}},decls:33,vars:4,consts:[[1,"spacer"],["mat-icon-button","","aria-label","Example icon-button with share icon",1,"example-icon"],["autosize","",1,"container"],[1,"header"],[1,"content"],[1,"videos"],["autoplay","",1,"video",3,"srcObject"],["video",""],[1,"result"],[1,"video","canvas"],["canvas",""],[1,"controls"],["mat-icon-button","","matTooltip","Start Camera",3,"click"],["mat-icon-button","","matTooltip","Stop Camera",3,"click"],["mat-icon-button","","matTooltip","Stop Detection",3,"disabled","click"]],template:function(e,r){1&e&&(Nr(0,"mat-toolbar")(1,"span"),$l(2,"IA - 2023"),Cs(),Za(3,"span",0),Nr(4,"button",1)(5,"mat-icon"),$l(6,"share"),Cs()()(),Nr(7,"mat-drawer-container",2)(8,"header",3)(9,"h1"),$l(10,"Tensorflow.js Real Time Object Detection"),Cs()(),Nr(11,"div",4)(12,"div",5),Za(13,"video",6,7),Nr(15,"div",8),Za(16,"video",6)(17,"canvas",9,10),Cs()(),Nr(19,"div",11)(20,"button",12),Zr("click",function(){return r.start()}),Nr(21,"mat-icon"),$l(22,"play_arrow"),Cs()(),Nr(23,"button",13),Zr("click",function(){return r.stop()}),Nr(24,"mat-icon"),$l(25,"pause"),Cs()(),Nr(26,"button",14),Zr("click",function(){return r.predictWithCocoModel()}),Nr(27,"mat-icon"),$l(28,"check"),Cs()(),Nr(29,"button",14),Zr("click",function(){return r.stopPrediction()}),Nr(30,"mat-icon"),$l(31,"close"),Cs()()()(),Za(32,"footer"),Cs()),2&e&&(Tc(13),pa("srcObject",r.webCam),Tc(3),pa("srcObject",r.webCam),Tc(10),pa("disabled",!r.webCam),Tc(3),pa("disabled",!r.webCam))},dependencies:[xR,Loe,Sie,Pie,pae],styles:[".container[_ngcontent-%COMP%]{height:calc(100% - 64px);width:100%}.container[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]{width:100%;text-align:center;margin-top:.5rem}.container[_ngcontent-%COMP%]   .videos[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:space-around;align-items:center}.container[_ngcontent-%COMP%]   .controls[_ngcontent-%COMP%]{position:absolute;bottom:2rem;left:50%;transform:translate(-50%);background-color:#424242;border-radius:.2rem;box-shadow:0 4px 5px -5px #e91e63}.spacer[_ngcontent-%COMP%]{flex:1 1 auto}.result[_ngcontent-%COMP%]{position:relative}.canvas[_ngcontent-%COMP%]{position:absolute;inset:0}@media only screen and (min-width: 1030px){.videos[_ngcontent-%COMP%]{flex-direction:row!important}}"]}),n})();function rO(n){return new qe(3e3,!1)}function jc(n){switch(n.length){case 0:return new $f;case 1:return n[0];default:return new bR(n)}}function sO(n,t,e=new Map,r=new Map){const s=[],o=[];let i=-1,a=null;if(t.forEach(l=>{const c=l.get("offset"),u=c==i,d=u&&a||new Map;l.forEach((p,m)=>{let y=m,_=p;if("offset"!==m)switch(y=n.normalizePropertyName(y,s),_){case EC:_=e.get(m);break;case Wl:_=r.get(m);break;default:_=n.normalizeStyleValue(m,y,_,s)}d.set(y,_)}),u||o.push(d),a=d,i=c}),s.length)throw function zae(n){return new qe(3502,!1)}();return o}function PC(n,t,e,r){switch(t){case"start":n.onStart(()=>r(e&&$C(e,"start",n)));break;case"done":n.onDone(()=>r(e&&$C(e,"done",n)));break;case"destroy":n.onDestroy(()=>r(e&&$C(e,"destroy",n)))}}function $C(n,t,e){const o=LC(n.element,n.triggerName,n.fromState,n.toState,t||n.phaseName,e.totalTime??n.totalTime,!!e.disabled),i=n._data;return null!=i&&(o._data=i),o}function LC(n,t,e,r,s="",o=0,i){return{element:n,triggerName:t,fromState:e,toState:r,phaseName:s,totalTime:o,disabled:!!i}}function vi(n,t,e){let r=n.get(t);return r||n.set(t,r=e),r}function oO(n){const t=n.indexOf(":");return[n.substring(1,t),n.slice(t+1)]}const ele=(()=>typeof document>"u"?null:document.documentElement)();function BC(n){const t=n.parentNode||n.host||null;return t===ele?null:t}let Zu=null,iO=!1;function aO(n,t){for(;t;){if(t===n)return!0;t=BC(t)}return!1}function lO(n,t,e){if(e)return Array.from(n.querySelectorAll(t));const r=n.querySelector(t);return r?[r]:[]}let cO=(()=>{class n{validateStyleProperty(e){return function nle(n){Zu||(Zu=function rle(){return typeof document<"u"?document.body:null}()||{},iO=!!Zu.style&&"WebkitAppearance"in Zu.style);let t=!0;return Zu.style&&!function tle(n){return"ebkit"==n.substring(1,6)}(n)&&(t=n in Zu.style,!t&&iO&&(t="Webkit"+n.charAt(0).toUpperCase()+n.slice(1)in Zu.style)),t}(e)}matchesElement(e,r){return!1}containsElement(e,r){return aO(e,r)}getParentElement(e){return BC(e)}query(e,r,s){return lO(e,r,s)}computeStyle(e,r,s){return s||""}animate(e,r,s,o,i,a=[],l){return new $f(s,o)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})(),VC=(()=>{class n{}return n.NOOP=new cO,n})();const sle=1e3,UC="ng-enter",hb="ng-leave",pb="ng-trigger",fb=".ng-trigger",dO="ng-animating",zC=".ng-animating";function Gl(n){if("number"==typeof n)return n;const t=n.match(/^(-?[\.\d]+)(m?s)/);return!t||t.length<2?0:HC(parseFloat(t[1]),t[2])}function HC(n,t){return"s"===t?n*sle:n}function mb(n,t,e){return n.hasOwnProperty("duration")?n:function ile(n,t,e){let s,o=0,i="";if("string"==typeof n){const a=n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===a)return t.push(rO()),{duration:0,delay:0,easing:""};s=HC(parseFloat(a[1]),a[2]);const l=a[3];null!=l&&(o=HC(parseFloat(l),a[4]));const c=a[5];c&&(i=c)}else s=n;if(!e){let a=!1,l=t.length;s<0&&(t.push(function vae(){return new qe(3100,!1)}()),a=!0),o<0&&(t.push(function xae(){return new qe(3101,!1)}()),a=!0),a&&t.splice(l,0,rO())}return{duration:s,delay:o,easing:i}}(n,t,e)}function Hf(n,t={}){return Object.keys(n).forEach(e=>{t[e]=n[e]}),t}function hO(n){const t=new Map;return Object.keys(n).forEach(e=>{t.set(e,n[e])}),t}function Gc(n,t=new Map,e){if(e)for(let[r,s]of e)t.set(r,s);for(let[r,s]of n)t.set(r,s);return t}function ll(n,t,e){t.forEach((r,s)=>{const o=jC(s);e&&!e.has(s)&&e.set(s,n.style[o]),n.style[o]=r})}function Yu(n,t){t.forEach((e,r)=>{const s=jC(r);n.style[s]=""})}function Wf(n){return Array.isArray(n)?1==n.length?n[0]:fR(n):n}const WC=new RegExp("{{\\s*(.+?)\\s*}}","g");function fO(n){let t=[];if("string"==typeof n){let e;for(;e=WC.exec(n);)t.push(e[1]);WC.lastIndex=0}return t}function jf(n,t,e){const r=n.toString(),s=r.replace(WC,(o,i)=>{let a=t[i];return null==a&&(e.push(function wae(n){return new qe(3003,!1)}()),a=""),a.toString()});return s==r?n:s}function gb(n){const t=[];let e=n.next();for(;!e.done;)t.push(e.value),e=n.next();return t}const cle=/-+([a-z0-9])/g;function jC(n){return n.replace(cle,(...t)=>t[1].toUpperCase())}function xi(n,t,e){switch(t.type){case 7:return n.visitTrigger(t,e);case 0:return n.visitState(t,e);case 1:return n.visitTransition(t,e);case 2:return n.visitSequence(t,e);case 3:return n.visitGroup(t,e);case 4:return n.visitAnimate(t,e);case 5:return n.visitKeyframes(t,e);case 6:return n.visitStyle(t,e);case 8:return n.visitReference(t,e);case 9:return n.visitAnimateChild(t,e);case 10:return n.visitAnimateRef(t,e);case 11:return n.visitQuery(t,e);case 12:return n.visitStagger(t,e);default:throw function Sae(n){return new qe(3004,!1)}()}}function mO(n,t){return window.getComputedStyle(n)[t]}const yb="*";function hle(n,t){const e=[];return"string"==typeof n?n.split(/\s*,\s*/).forEach(r=>function ple(n,t,e){if(":"==n[0]){const l=function fle(n,t){switch(n){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(e,r)=>parseFloat(r)>parseFloat(e);case":decrement":return(e,r)=>parseFloat(r)<parseFloat(e);default:return t.push(function Lae(n){return new qe(3016,!1)}()),"* => *"}}(n,e);if("function"==typeof l)return void t.push(l);n=l}const r=n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==r||r.length<4)return e.push(function $ae(n){return new qe(3015,!1)}()),t;const s=r[1],o=r[2],i=r[3];t.push(gO(s,i));"<"==o[0]&&!(s==yb&&i==yb)&&t.push(gO(i,s))}(r,e,t)):e.push(n),e}const bb=new Set(["true","1"]),_b=new Set(["false","0"]);function gO(n,t){const e=bb.has(n)||_b.has(n),r=bb.has(t)||_b.has(t);return(s,o)=>{let i=n==yb||n==s,a=t==yb||t==o;return!i&&e&&"boolean"==typeof s&&(i=s?bb.has(n):_b.has(n)),!a&&r&&"boolean"==typeof o&&(a=o?bb.has(t):_b.has(t)),i&&a}}const mle=new RegExp("s*:selfs*,?","g");function GC(n,t,e,r){return new gle(n).build(t,e,r)}class gle{constructor(t){this._driver=t}build(t,e,r){const s=new _le(e);return this._resetContextStyleTimingState(s),xi(this,Wf(t),s)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles=new Map,t.collectedStyles.set("",new Map),t.currentTime=0}visitTrigger(t,e){let r=e.queryCount=0,s=e.depCount=0;const o=[],i=[];return"@"==t.name.charAt(0)&&e.errors.push(function Dae(){return new qe(3006,!1)}()),t.definitions.forEach(a=>{if(this._resetContextStyleTimingState(e),0==a.type){const l=a,c=l.name;c.toString().split(/\s*,\s*/).forEach(u=>{l.name=u,o.push(this.visitState(l,e))}),l.name=c}else if(1==a.type){const l=this.visitTransition(a,e);r+=l.queryCount,s+=l.depCount,i.push(l)}else e.errors.push(function Tae(){return new qe(3007,!1)}())}),{type:7,name:t.name,states:o,transitions:i,queryCount:r,depCount:s,options:null}}visitState(t,e){const r=this.visitStyle(t.styles,e),s=t.options&&t.options.params||null;if(r.containsDynamicStyles){const o=new Set,i=s||{};r.styles.forEach(a=>{a instanceof Map&&a.forEach(l=>{fO(l).forEach(c=>{i.hasOwnProperty(c)||o.add(c)})})}),o.size&&(gb(o.values()),e.errors.push(function Iae(n,t){return new qe(3008,!1)}()))}return{type:0,name:t.name,style:r,options:s?{params:s}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const r=xi(this,Wf(t.animation),e);return{type:1,matchers:hle(t.expr,e.errors),animation:r,queryCount:e.queryCount,depCount:e.depCount,options:Qu(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(r=>xi(this,r,e)),options:Qu(t.options)}}visitGroup(t,e){const r=e.currentTime;let s=0;const o=t.steps.map(i=>{e.currentTime=r;const a=xi(this,i,e);return s=Math.max(s,e.currentTime),a});return e.currentTime=s,{type:3,steps:o,options:Qu(t.options)}}visitAnimate(t,e){const r=function xle(n,t){if(n.hasOwnProperty("duration"))return n;if("number"==typeof n)return KC(mb(n,t).duration,0,"");const e=n;if(e.split(/\s+/).some(o=>"{"==o.charAt(0)&&"{"==o.charAt(1))){const o=KC(0,0,"");return o.dynamic=!0,o.strValue=e,o}const s=mb(e,t);return KC(s.duration,s.delay,s.easing)}(t.timings,e.errors);e.currentAnimateTimings=r;let s,o=t.styles?t.styles:Hc({});if(5==o.type)s=this.visitKeyframes(o,e);else{let i=t.styles,a=!1;if(!i){a=!0;const c={};r.easing&&(c.easing=r.easing),i=Hc(c)}e.currentTime+=r.duration+r.delay;const l=this.visitStyle(i,e);l.isEmptyStep=a,s=l}return e.currentAnimateTimings=null,{type:4,timings:r,style:s,options:null}}visitStyle(t,e){const r=this._makeStyleAst(t,e);return this._validateStyleAst(r,e),r}_makeStyleAst(t,e){const r=[],s=Array.isArray(t.styles)?t.styles:[t.styles];for(let a of s)"string"==typeof a?a===Wl?r.push(a):e.errors.push(new qe(3002,!1)):r.push(hO(a));let o=!1,i=null;return r.forEach(a=>{if(a instanceof Map&&(a.has("easing")&&(i=a.get("easing"),a.delete("easing")),!o))for(let l of a.values())if(l.toString().indexOf("{{")>=0){o=!0;break}}),{type:6,styles:r,easing:i,offset:t.offset,containsDynamicStyles:o,options:null}}_validateStyleAst(t,e){const r=e.currentAnimateTimings;let s=e.currentTime,o=e.currentTime;r&&o>0&&(o-=r.duration+r.delay),t.styles.forEach(i=>{"string"!=typeof i&&i.forEach((a,l)=>{const c=e.collectedStyles.get(e.currentQuerySelector),u=c.get(l);let d=!0;u&&(o!=s&&o>=u.startTime&&s<=u.endTime&&(e.errors.push(function Nae(n,t,e,r,s){return new qe(3010,!1)}()),d=!1),o=u.startTime),d&&c.set(l,{startTime:o,endTime:s}),e.options&&function lle(n,t,e){const r=t.params||{},s=fO(n);s.length&&s.forEach(o=>{r.hasOwnProperty(o)||e.push(function Cae(n){return new qe(3001,!1)}())})}(a,e.options,e.errors)})})}visitKeyframes(t,e){const r={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push(function kae(){return new qe(3011,!1)}()),r;let o=0;const i=[];let a=!1,l=!1,c=0;const u=t.steps.map(D=>{const N=this._makeStyleAst(D,e);let W=null!=N.offset?N.offset:function vle(n){if("string"==typeof n)return null;let t=null;if(Array.isArray(n))n.forEach(e=>{if(e instanceof Map&&e.has("offset")){const r=e;t=parseFloat(r.get("offset")),r.delete("offset")}});else if(n instanceof Map&&n.has("offset")){const e=n;t=parseFloat(e.get("offset")),e.delete("offset")}return t}(N.styles),j=0;return null!=W&&(o++,j=N.offset=W),l=l||j<0||j>1,a=a||j<c,c=j,i.push(j),N});l&&e.errors.push(function Mae(){return new qe(3012,!1)}()),a&&e.errors.push(function Rae(){return new qe(3200,!1)}());const d=t.steps.length;let p=0;o>0&&o<d?e.errors.push(function Oae(){return new qe(3202,!1)}()):0==o&&(p=1/(d-1));const m=d-1,y=e.currentTime,_=e.currentAnimateTimings,C=_.duration;return u.forEach((D,N)=>{const W=p>0?N==m?1:p*N:i[N],j=W*C;e.currentTime=y+_.delay+j,_.duration=j,this._validateStyleAst(D,e),D.offset=W,r.styles.push(D)}),r}visitReference(t,e){return{type:8,animation:xi(this,Wf(t.animation),e),options:Qu(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:Qu(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:Qu(t.options)}}visitQuery(t,e){const r=e.currentQuerySelector,s=t.options||{};e.queryCount++,e.currentQuery=t;const[o,i]=function yle(n){const t=!!n.split(/\s*,\s*/).find(e=>":self"==e);return t&&(n=n.replace(mle,"")),n=n.replace(/@\*/g,fb).replace(/@\w+/g,e=>fb+"-"+e.slice(1)).replace(/:animating/g,zC),[n,t]}(t.selector);e.currentQuerySelector=r.length?r+" "+o:o,vi(e.collectedStyles,e.currentQuerySelector,new Map);const a=xi(this,Wf(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=r,{type:11,selector:o,limit:s.limit||0,optional:!!s.optional,includeSelf:i,animation:a,originalSelector:t.selector,options:Qu(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push(function Fae(){return new qe(3013,!1)}());const r="full"===t.timings?{duration:0,delay:0,easing:"full"}:mb(t.timings,e.errors,!0);return{type:12,animation:xi(this,Wf(t.animation),e),timings:r,options:null}}}class _le{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles=new Map,this.options=null,this.unsupportedCSSPropertiesFound=new Set}}function Qu(n){return n?(n=Hf(n)).params&&(n.params=function ble(n){return n?Hf(n):null}(n.params)):n={},n}function KC(n,t,e){return{duration:n,delay:t,easing:e}}function XC(n,t,e,r,s,o,i=null,a=!1){return{type:1,element:n,keyframes:t,preStyleProps:e,postStyleProps:r,duration:s,delay:o,totalTime:s+o,easing:i,subTimeline:a}}class vb{constructor(){this._map=new Map}get(t){return this._map.get(t)||[]}append(t,e){let r=this._map.get(t);r||this._map.set(t,r=[]),r.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const Sle=new RegExp(":enter","g"),Dle=new RegExp(":leave","g");function qC(n,t,e,r,s,o=new Map,i=new Map,a,l,c=[]){return(new Tle).buildKeyframes(n,t,e,r,s,o,i,a,l,c)}class Tle{buildKeyframes(t,e,r,s,o,i,a,l,c,u=[]){c=c||new vb;const d=new ZC(t,e,c,s,o,u,[]);d.options=l;const p=l.delay?Gl(l.delay):0;d.currentTimeline.delayNextStep(p),d.currentTimeline.setStyles([i],null,d.errors,l),xi(this,r,d);const m=d.timelines.filter(y=>y.containsAnimation());if(m.length&&a.size){let y;for(let _=m.length-1;_>=0;_--){const C=m[_];if(C.element===e){y=C;break}}y&&!y.allowOnlyTimelineStyles()&&y.setStyles([a],null,d.errors,l)}return m.length?m.map(y=>y.buildKeyframes()):[XC(e,[],[],[],0,p,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const r=e.subInstructions.get(e.element);if(r){const s=e.createSubContext(t.options),o=e.currentTimeline.currentTime,i=this._visitSubInstructions(r,s,s.options);o!=i&&e.transformIntoNewTimeline(i)}e.previousNode=t}visitAnimateRef(t,e){const r=e.createSubContext(t.options);r.transformIntoNewTimeline(),this._applyAnimationRefDelays([t.options,t.animation.options],e,r),this.visitReference(t.animation,r),e.transformIntoNewTimeline(r.currentTimeline.currentTime),e.previousNode=t}_applyAnimationRefDelays(t,e,r){for(const s of t){const o=s?.delay;if(o){const i="number"==typeof o?o:Gl(jf(o,s?.params??{},e.errors));r.delayNextStep(i)}}}_visitSubInstructions(t,e,r){let o=e.currentTimeline.currentTime;const i=null!=r.duration?Gl(r.duration):null,a=null!=r.delay?Gl(r.delay):null;return 0!==i&&t.forEach(l=>{const c=e.appendInstructionToTimeline(l,i,a);o=Math.max(o,c.duration+c.delay)}),o}visitReference(t,e){e.updateOptions(t.options,!0),xi(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const r=e.subContextCount;let s=e;const o=t.options;if(o&&(o.params||o.delay)&&(s=e.createSubContext(o),s.transformIntoNewTimeline(),null!=o.delay)){6==s.previousNode.type&&(s.currentTimeline.snapshotCurrentStyles(),s.previousNode=xb);const i=Gl(o.delay);s.delayNextStep(i)}t.steps.length&&(t.steps.forEach(i=>xi(this,i,s)),s.currentTimeline.applyStylesToKeyframe(),s.subContextCount>r&&s.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const r=[];let s=e.currentTimeline.currentTime;const o=t.options&&t.options.delay?Gl(t.options.delay):0;t.steps.forEach(i=>{const a=e.createSubContext(t.options);o&&a.delayNextStep(o),xi(this,i,a),s=Math.max(s,a.currentTimeline.currentTime),r.push(a.currentTimeline)}),r.forEach(i=>e.currentTimeline.mergeTimelineCollectedStyles(i)),e.transformIntoNewTimeline(s),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const r=t.strValue;return mb(e.params?jf(r,e.params,e.errors):r,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const r=e.currentAnimateTimings=this._visitTiming(t.timings,e),s=e.currentTimeline;r.delay&&(e.incrementTime(r.delay),s.snapshotCurrentStyles());const o=t.style;5==o.type?this.visitKeyframes(o,e):(e.incrementTime(r.duration),this.visitStyle(o,e),s.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const r=e.currentTimeline,s=e.currentAnimateTimings;!s&&r.hasCurrentStyleProperties()&&r.forwardFrame();const o=s&&s.easing||t.easing;t.isEmptyStep?r.applyEmptyStep(o):r.setStyles(t.styles,o,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const r=e.currentAnimateTimings,s=e.currentTimeline.duration,o=r.duration,a=e.createSubContext().currentTimeline;a.easing=r.easing,t.styles.forEach(l=>{a.forwardTime((l.offset||0)*o),a.setStyles(l.styles,l.easing,e.errors,e.options),a.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(a),e.transformIntoNewTimeline(s+o),e.previousNode=t}visitQuery(t,e){const r=e.currentTimeline.currentTime,s=t.options||{},o=s.delay?Gl(s.delay):0;o&&(6===e.previousNode.type||0==r&&e.currentTimeline.hasCurrentStyleProperties())&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=xb);let i=r;const a=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!s.optional,e.errors);e.currentQueryTotal=a.length;let l=null;a.forEach((c,u)=>{e.currentQueryIndex=u;const d=e.createSubContext(t.options,c);o&&d.delayNextStep(o),c===e.element&&(l=d.currentTimeline),xi(this,t.animation,d),d.currentTimeline.applyStylesToKeyframe(),i=Math.max(i,d.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(i),l&&(e.currentTimeline.mergeTimelineCollectedStyles(l),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const r=e.parentContext,s=e.currentTimeline,o=t.timings,i=Math.abs(o.duration),a=i*(e.currentQueryTotal-1);let l=i*e.currentQueryIndex;switch(o.duration<0?"reverse":o.easing){case"reverse":l=a-l;break;case"full":l=r.currentStaggerTime}const u=e.currentTimeline;l&&u.delayNextStep(l);const d=u.currentTime;xi(this,t.animation,e),e.previousNode=t,r.currentStaggerTime=s.currentTime-d+(s.startTime-r.currentTimeline.startTime)}}const xb={};class ZC{constructor(t,e,r,s,o,i,a,l){this._driver=t,this.element=e,this.subInstructions=r,this._enterClassName=s,this._leaveClassName=o,this.errors=i,this.timelines=a,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=xb,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=l||new Cb(this._driver,e,0),a.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const r=t;let s=this.options;null!=r.duration&&(s.duration=Gl(r.duration)),null!=r.delay&&(s.delay=Gl(r.delay));const o=r.params;if(o){let i=s.params;i||(i=this.options.params={}),Object.keys(o).forEach(a=>{(!e||!i.hasOwnProperty(a))&&(i[a]=jf(o[a],i,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const r=t.params={};Object.keys(e).forEach(s=>{r[s]=e[s]})}}return t}createSubContext(t=null,e,r){const s=e||this.element,o=new ZC(this._driver,s,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(s,r||0));return o.previousNode=this.previousNode,o.currentAnimateTimings=this.currentAnimateTimings,o.options=this._copyOptions(),o.updateOptions(t),o.currentQueryIndex=this.currentQueryIndex,o.currentQueryTotal=this.currentQueryTotal,o.parentContext=this,this.subContextCount++,o}transformIntoNewTimeline(t){return this.previousNode=xb,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,r){const s={duration:e??t.duration,delay:this.currentTimeline.currentTime+(r??0)+t.delay,easing:""},o=new Ile(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,s,t.stretchStartingKeyframe);return this.timelines.push(o),s}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,r,s,o,i){let a=[];if(s&&a.push(this.element),t.length>0){t=(t=t.replace(Sle,"."+this._enterClassName)).replace(Dle,"."+this._leaveClassName);let c=this._driver.query(this.element,t,1!=r);0!==r&&(c=r<0?c.slice(c.length+r,c.length):c.slice(0,r)),a.push(...c)}return!o&&0==a.length&&i.push(function Pae(n){return new qe(3014,!1)}()),a}}class Cb{constructor(t,e,r,s){this._driver=t,this.element=e,this.startTime=r,this._elementTimelineStylesLookup=s,this.duration=0,this.easing=null,this._previousKeyframe=new Map,this._currentKeyframe=new Map,this._keyframes=new Map,this._styleSummary=new Map,this._localTimelineStyles=new Map,this._pendingStyles=new Map,this._backFill=new Map,this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.hasCurrentStyleProperties();default:return!0}}hasCurrentStyleProperties(){return this._currentKeyframe.size>0}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1===this._keyframes.size&&this._pendingStyles.size;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new Cb(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=new Map,this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles.set(t,e),this._globalTimelineStyles.set(t,e),this._styleSummary.set(t,{time:this.currentTime,value:e})}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&this._previousKeyframe.set("easing",t);for(let[e,r]of this._globalTimelineStyles)this._backFill.set(e,r||Wl),this._currentKeyframe.set(e,Wl);this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,r,s){e&&this._previousKeyframe.set("easing",e);const o=s&&s.params||{},i=function Ale(n,t){const e=new Map;let r;return n.forEach(s=>{if("*"===s){r=r||t.keys();for(let o of r)e.set(o,Wl)}else Gc(s,e)}),e}(t,this._globalTimelineStyles);for(let[a,l]of i){const c=jf(l,o,r);this._pendingStyles.set(a,c),this._localTimelineStyles.has(a)||this._backFill.set(a,this._globalTimelineStyles.get(a)??Wl),this._updateStyle(a,c)}}applyStylesToKeyframe(){0!=this._pendingStyles.size&&(this._pendingStyles.forEach((t,e)=>{this._currentKeyframe.set(e,t)}),this._pendingStyles.clear(),this._localTimelineStyles.forEach((t,e)=>{this._currentKeyframe.has(e)||this._currentKeyframe.set(e,t)}))}snapshotCurrentStyles(){for(let[t,e]of this._localTimelineStyles)this._pendingStyles.set(t,e),this._updateStyle(t,e)}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){t._styleSummary.forEach((e,r)=>{const s=this._styleSummary.get(r);(!s||e.time>s.time)&&this._updateStyle(r,e.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,r=1===this._keyframes.size&&0===this.duration;let s=[];this._keyframes.forEach((a,l)=>{const c=Gc(a,new Map,this._backFill);c.forEach((u,d)=>{u===EC?t.add(d):u===Wl&&e.add(d)}),r||c.set("offset",l/this.duration),s.push(c)});const o=t.size?gb(t.values()):[],i=e.size?gb(e.values()):[];if(r){const a=s[0],l=new Map(a);a.set("offset",0),l.set("offset",1),s=[a,l]}return XC(this.element,s,o,i,this.duration,this.startTime,this.easing,!1)}}class Ile extends Cb{constructor(t,e,r,s,o,i,a=!1){super(t,e,i.delay),this.keyframes=r,this.preStyleProps=s,this.postStyleProps=o,this._stretchStartingKeyframe=a,this.timings={duration:i.duration,delay:i.delay,easing:i.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:r,easing:s}=this.timings;if(this._stretchStartingKeyframe&&e){const o=[],i=r+e,a=e/i,l=Gc(t[0]);l.set("offset",0),o.push(l);const c=Gc(t[0]);c.set("offset",_O(a)),o.push(c);const u=t.length-1;for(let d=1;d<=u;d++){let p=Gc(t[d]);const m=p.get("offset");p.set("offset",_O((e+m*r)/i)),o.push(p)}r=i,e=0,s="",t=o}return XC(this.element,t,this.preStyleProps,this.postStyleProps,r,e,s,!0)}}function _O(n,t=3){const e=Math.pow(10,t-1);return Math.round(n*e)/e}class YC{}const Nle=new Set(["width","height","minWidth","minHeight","maxWidth","maxHeight","left","top","bottom","right","fontSize","outlineWidth","outlineOffset","paddingTop","paddingLeft","paddingBottom","paddingRight","marginTop","marginLeft","marginBottom","marginRight","borderRadius","borderWidth","borderTopWidth","borderLeftWidth","borderRightWidth","borderBottomWidth","textIndent","perspective"]);class kle extends YC{normalizePropertyName(t,e){return jC(t)}normalizeStyleValue(t,e,r,s){let o="";const i=r.toString().trim();if(Nle.has(e)&&0!==r&&"0"!==r)if("number"==typeof r)o="px";else{const a=r.match(/^[+-]?[\d\.]+([a-z]*)$/);a&&0==a[1].length&&s.push(function Eae(n,t){return new qe(3005,!1)}())}return i+o}}function vO(n,t,e,r,s,o,i,a,l,c,u,d,p){return{type:0,element:n,triggerName:t,isRemovalTransition:s,fromState:e,fromStyles:o,toState:r,toStyles:i,timelines:a,queriedElements:l,preStyleProps:c,postStyleProps:u,totalTime:d,errors:p}}const QC={};class xO{constructor(t,e,r){this._triggerName=t,this.ast=e,this._stateStyles=r}match(t,e,r,s){return function Mle(n,t,e,r,s){return n.some(o=>o(t,e,r,s))}(this.ast.matchers,t,e,r,s)}buildStyles(t,e,r){let s=this._stateStyles.get("*");return void 0!==t&&(s=this._stateStyles.get(t?.toString())||s),s?s.buildStyles(e,r):new Map}build(t,e,r,s,o,i,a,l,c,u){const d=[],p=this.ast.options&&this.ast.options.params||QC,y=this.buildStyles(r,a&&a.params||QC,d),_=l&&l.params||QC,C=this.buildStyles(s,_,d),D=new Set,N=new Map,W=new Map,j="void"===s,te={params:Rle(_,p),delay:this.ast.options?.delay},_e=u?[]:qC(t,e,this.ast.animation,o,i,y,C,te,c,d);let Ee=0;if(_e.forEach(je=>{Ee=Math.max(je.duration+je.delay,Ee)}),d.length)return vO(e,this._triggerName,r,s,j,y,C,[],[],N,W,Ee,d);_e.forEach(je=>{const He=je.element,it=vi(N,He,new Set);je.preStyleProps.forEach(tt=>it.add(tt));const at=vi(W,He,new Set);je.postStyleProps.forEach(tt=>at.add(tt)),He!==e&&D.add(He)});const Ne=gb(D.values());return vO(e,this._triggerName,r,s,j,y,C,_e,Ne,N,W,Ee)}}function Rle(n,t){const e=Hf(t);for(const r in n)n.hasOwnProperty(r)&&null!=n[r]&&(e[r]=n[r]);return e}class Ole{constructor(t,e,r){this.styles=t,this.defaultParams=e,this.normalizer=r}buildStyles(t,e){const r=new Map,s=Hf(this.defaultParams);return Object.keys(t).forEach(o=>{const i=t[o];null!==i&&(s[o]=i)}),this.styles.styles.forEach(o=>{"string"!=typeof o&&o.forEach((i,a)=>{i&&(i=jf(i,s,e));const l=this.normalizer.normalizePropertyName(a,e);i=this.normalizer.normalizeStyleValue(a,l,i,e),r.set(a,i)})}),r}}class Ple{constructor(t,e,r){this.name=t,this.ast=e,this._normalizer=r,this.transitionFactories=[],this.states=new Map,e.states.forEach(s=>{this.states.set(s.name,new Ole(s.style,s.options&&s.options.params||{},r))}),CO(this.states,"true","1"),CO(this.states,"false","0"),e.transitions.forEach(s=>{this.transitionFactories.push(new xO(t,s,this.states))}),this.fallbackTransition=function $le(n,t,e){return new xO(n,{type:1,animation:{type:2,steps:[],options:null},matchers:[(i,a)=>!0],options:null,queryCount:0,depCount:0},t)}(t,this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,r,s){return this.transitionFactories.find(i=>i.match(t,e,r,s))||null}matchStyles(t,e,r){return this.fallbackTransition.buildStyles(t,e,r)}}function CO(n,t,e){n.has(t)?n.has(e)||n.set(e,n.get(t)):n.has(e)&&n.set(t,n.get(e))}const Lle=new vb;class Ble{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._animations=new Map,this._playersById=new Map,this.players=[]}register(t,e){const r=[],o=GC(this._driver,e,r,[]);if(r.length)throw function Hae(n){return new qe(3503,!1)}();this._animations.set(t,o)}_buildPlayer(t,e,r){const s=t.element,o=sO(this._normalizer,t.keyframes,e,r);return this._driver.animate(s,o,t.duration,t.delay,t.easing,[],!0)}create(t,e,r={}){const s=[],o=this._animations.get(t);let i;const a=new Map;if(o?(i=qC(this._driver,e,o,UC,hb,new Map,new Map,r,Lle,s),i.forEach(u=>{const d=vi(a,u.element,new Map);u.postStyleProps.forEach(p=>d.set(p,null))})):(s.push(function Wae(){return new qe(3300,!1)}()),i=[]),s.length)throw function jae(n){return new qe(3504,!1)}();a.forEach((u,d)=>{u.forEach((p,m)=>{u.set(m,this._driver.computeStyle(d,m,Wl))})});const c=jc(i.map(u=>{const d=a.get(u.element);return this._buildPlayer(u,new Map,d)}));return this._playersById.set(t,c),c.onDestroy(()=>this.destroy(t)),this.players.push(c),c}destroy(t){const e=this._getPlayer(t);e.destroy(),this._playersById.delete(t);const r=this.players.indexOf(e);r>=0&&this.players.splice(r,1)}_getPlayer(t){const e=this._playersById.get(t);if(!e)throw function Gae(n){return new qe(3301,!1)}();return e}listen(t,e,r,s){const o=LC(e,"","","");return PC(this._getPlayer(t),r,o,s),()=>{}}command(t,e,r,s){if("register"==r)return void this.register(t,s[0]);if("create"==r)return void this.create(t,e,s[0]||{});const o=this._getPlayer(t);switch(r){case"play":o.play();break;case"pause":o.pause();break;case"reset":o.reset();break;case"restart":o.restart();break;case"finish":o.finish();break;case"init":o.init();break;case"setPosition":o.setPosition(parseFloat(s[0]));break;case"destroy":this.destroy(t)}}}const wO="ng-animate-queued",JC="ng-animate-disabled",Wle=[],SO={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},jle={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0},Wi="__ng_removed";class ew{get params(){return this.options.params}constructor(t,e=""){this.namespaceId=e;const r=t&&t.hasOwnProperty("value");if(this.value=function qle(n){return n??null}(r?t.value:t),r){const o=Hf(t);delete o.value,this.options=o}else this.options={};this.options.params||(this.options.params={})}absorbOptions(t){const e=t.params;if(e){const r=this.options.params;Object.keys(e).forEach(s=>{null==r[s]&&(r[s]=e[s])})}}}const Gf="void",tw=new ew(Gf);class Gle{constructor(t,e,r){this.id=t,this.hostElement=e,this._engine=r,this.players=[],this._triggers=new Map,this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,ji(e,this._hostClassName)}listen(t,e,r,s){if(!this._triggers.has(e))throw function Kae(n,t){return new qe(3302,!1)}();if(null==r||0==r.length)throw function Xae(n){return new qe(3303,!1)}();if(!function Zle(n){return"start"==n||"done"==n}(r))throw function qae(n,t){return new qe(3400,!1)}();const o=vi(this._elementListeners,t,[]),i={name:e,phase:r,callback:s};o.push(i);const a=vi(this._engine.statesByElement,t,new Map);return a.has(e)||(ji(t,pb),ji(t,pb+"-"+e),a.set(e,tw)),()=>{this._engine.afterFlush(()=>{const l=o.indexOf(i);l>=0&&o.splice(l,1),this._triggers.has(e)||a.delete(e)})}}register(t,e){return!this._triggers.has(t)&&(this._triggers.set(t,e),!0)}_getTrigger(t){const e=this._triggers.get(t);if(!e)throw function Zae(n){return new qe(3401,!1)}();return e}trigger(t,e,r,s=!0){const o=this._getTrigger(e),i=new nw(this.id,e,t);let a=this._engine.statesByElement.get(t);a||(ji(t,pb),ji(t,pb+"-"+e),this._engine.statesByElement.set(t,a=new Map));let l=a.get(e);const c=new ew(r,this.id);if(!(r&&r.hasOwnProperty("value"))&&l&&c.absorbOptions(l.options),a.set(e,c),l||(l=tw),c.value!==Gf&&l.value===c.value){if(!function Jle(n,t){const e=Object.keys(n),r=Object.keys(t);if(e.length!=r.length)return!1;for(let s=0;s<e.length;s++){const o=e[s];if(!t.hasOwnProperty(o)||n[o]!==t[o])return!1}return!0}(l.params,c.params)){const _=[],C=o.matchStyles(l.value,l.params,_),D=o.matchStyles(c.value,c.params,_);_.length?this._engine.reportError(_):this._engine.afterFlush(()=>{Yu(t,C),ll(t,D)})}return}const p=vi(this._engine.playersByElement,t,[]);p.forEach(_=>{_.namespaceId==this.id&&_.triggerName==e&&_.queued&&_.destroy()});let m=o.matchTransition(l.value,c.value,t,c.params),y=!1;if(!m){if(!s)return;m=o.fallbackTransition,y=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:m,fromState:l,toState:c,player:i,isFallbackTransition:y}),y||(ji(t,wO),i.onStart(()=>{Fh(t,wO)})),i.onDone(()=>{let _=this.players.indexOf(i);_>=0&&this.players.splice(_,1);const C=this._engine.playersByElement.get(t);if(C){let D=C.indexOf(i);D>=0&&C.splice(D,1)}}),this.players.push(i),p.push(i),i}deregister(t){this._triggers.delete(t),this._engine.statesByElement.forEach(e=>e.delete(t)),this._elementListeners.forEach((e,r)=>{this._elementListeners.set(r,e.filter(s=>s.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(r=>r.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const r=this._engine.driver.query(t,fb,!0);r.forEach(s=>{if(s[Wi])return;const o=this._engine.fetchNamespacesByElement(s);o.size?o.forEach(i=>i.triggerLeaveAnimation(s,e,!1,!0)):this.clearElementCache(s)}),this._engine.afterFlushAnimationsDone(()=>r.forEach(s=>this.clearElementCache(s)))}triggerLeaveAnimation(t,e,r,s){const o=this._engine.statesByElement.get(t),i=new Map;if(o){const a=[];if(o.forEach((l,c)=>{if(i.set(c,l.value),this._triggers.has(c)){const u=this.trigger(t,c,Gf,s);u&&a.push(u)}}),a.length)return this._engine.markElementAsRemoved(this.id,t,!0,e,i),r&&jc(a).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),r=this._engine.statesByElement.get(t);if(e&&r){const s=new Set;e.forEach(o=>{const i=o.name;if(s.has(i))return;s.add(i);const l=this._triggers.get(i).fallbackTransition,c=r.get(i)||tw,u=new ew(Gf),d=new nw(this.id,i,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:i,transition:l,fromState:c,toState:u,player:d,isFallbackTransition:!0})})}}removeNode(t,e){const r=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let s=!1;if(r.totalAnimations){const o=r.players.length?r.playersByQueriedElement.get(t):[];if(o&&o.length)s=!0;else{let i=t;for(;i=i.parentNode;)if(r.statesByElement.get(i)){s=!0;break}}}if(this.prepareLeaveAnimationListeners(t),s)r.markElementAsRemoved(this.id,t,!1,e);else{const o=t[Wi];(!o||o===SO)&&(r.afterFlush(()=>this.clearElementCache(t)),r.destroyInnerAnimations(t),r._onRemovalComplete(t,e))}}insertNode(t,e){ji(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(r=>{const s=r.player;if(s.destroyed)return;const o=r.element,i=this._elementListeners.get(o);i&&i.forEach(a=>{if(a.name==r.triggerName){const l=LC(o,r.triggerName,r.fromState.value,r.toState.value);l._data=t,PC(r.player,a.phase,l,a.callback)}}),s.markedForDestroy?this._engine.afterFlush(()=>{s.destroy()}):e.push(r)}),this._queue=[],e.sort((r,s)=>{const o=r.transition.ast.depCount,i=s.transition.ast.depCount;return 0==o||0==i?o-i:this._engine.driver.containsElement(r.element,s.element)?1:-1})}destroy(t){this.players.forEach(e=>e.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(r=>r.element===t)||e,e}}class Kle{_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}constructor(t,e,r){this.bodyNode=t,this.driver=e,this._normalizer=r,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(s,o)=>{}}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(r=>{r.queued&&t.push(r)})}),t}createNamespace(t,e){const r=new Gle(t,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(r,e):(this.newHostElements.set(e,r),this.collectEnterElement(e)),this._namespaceLookup[t]=r}_balanceNamespaceList(t,e){const r=this._namespaceList,s=this.namespacesByHostElement;if(r.length-1>=0){let i=!1,a=this.driver.getParentElement(e);for(;a;){const l=s.get(a);if(l){const c=r.indexOf(l);r.splice(c+1,0,t),i=!0;break}a=this.driver.getParentElement(a)}i||r.unshift(t)}else r.push(t);return s.set(e,t),t}register(t,e){let r=this._namespaceLookup[t];return r||(r=this.createNamespace(t,e)),r}registerTrigger(t,e,r){let s=this._namespaceLookup[t];s&&s.register(e,r)&&this.totalAnimations++}destroy(t,e){if(!t)return;const r=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(r.hostElement),delete this._namespaceLookup[t];const s=this._namespaceList.indexOf(r);s>=0&&this._namespaceList.splice(s,1)}),this.afterFlushAnimationsDone(()=>r.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,r=this.statesByElement.get(t);if(r)for(let s of r.values())if(s.namespaceId){const o=this._fetchNamespace(s.namespaceId);o&&e.add(o)}return e}trigger(t,e,r,s){if(wb(e)){const o=this._fetchNamespace(t);if(o)return o.trigger(e,r,s),!0}return!1}insertNode(t,e,r,s){if(!wb(e))return;const o=e[Wi];if(o&&o.setForRemoval){o.setForRemoval=!1,o.setForMove=!0;const i=this.collectedLeaveElements.indexOf(e);i>=0&&this.collectedLeaveElements.splice(i,1)}if(t){const i=this._fetchNamespace(t);i&&i.insertNode(e,r)}s&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),ji(t,JC)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),Fh(t,JC))}removeNode(t,e,r,s){if(wb(e)){const o=t?this._fetchNamespace(t):null;if(o?o.removeNode(e,s):this.markElementAsRemoved(t,e,!1,s),r){const i=this.namespacesByHostElement.get(e);i&&i.id!==t&&i.removeNode(e,s)}}else this._onRemovalComplete(e,s)}markElementAsRemoved(t,e,r,s,o){this.collectedLeaveElements.push(e),e[Wi]={namespaceId:t,setForRemoval:s,hasAnimation:r,removedBeforeQueried:!1,previousTriggersValues:o}}listen(t,e,r,s,o){return wb(e)?this._fetchNamespace(t).listen(e,r,s,o):()=>{}}_buildInstruction(t,e,r,s,o){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,r,s,t.fromState.options,t.toState.options,e,o)}destroyInnerAnimations(t){let e=this.driver.query(t,fb,!0);e.forEach(r=>this.destroyActiveAnimationsForElement(r)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,zC,!0),e.forEach(r=>this.finishActiveQueriedAnimationOnElement(r)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(r=>{r.queued?r.markedForDestroy=!0:r.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(r=>r.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return jc(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t[Wi];if(e&&e.setForRemoval){if(t[Wi]=SO,e.namespaceId){this.destroyInnerAnimations(t);const r=this._fetchNamespace(e.namespaceId);r&&r.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}t.classList?.contains(JC)&&this.markElementAsDisabled(t,!1),this.driver.query(t,".ng-animate-disabled",!0).forEach(r=>{this.markElementAsDisabled(r,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((r,s)=>this._balanceNamespaceList(r,s)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let r=0;r<this.collectedEnterElements.length;r++)ji(this.collectedEnterElements[r],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const r=[];try{e=this._flushAnimations(r,t)}finally{for(let s=0;s<r.length;s++)r[s]()}}else for(let r=0;r<this.collectedLeaveElements.length;r++)this.processLeaveNode(this.collectedLeaveElements[r]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(r=>r()),this._flushFns=[],this._whenQuietFns.length){const r=this._whenQuietFns;this._whenQuietFns=[],e.length?jc(e).onDone(()=>{r.forEach(s=>s())}):r.forEach(s=>s())}}reportError(t){throw function Yae(n){return new qe(3402,!1)}()}_flushAnimations(t,e){const r=new vb,s=[],o=new Map,i=[],a=new Map,l=new Map,c=new Map,u=new Set;this.disabledNodes.forEach(Pe=>{u.add(Pe);const We=this.driver.query(Pe,".ng-animate-queued",!0);for(let Ue=0;Ue<We.length;Ue++)u.add(We[Ue])});const d=this.bodyNode,p=Array.from(this.statesByElement.keys()),m=TO(p,this.collectedEnterElements),y=new Map;let _=0;m.forEach((Pe,We)=>{const Ue=UC+_++;y.set(We,Ue),Pe.forEach(Ye=>ji(Ye,Ue))});const C=[],D=new Set,N=new Set;for(let Pe=0;Pe<this.collectedLeaveElements.length;Pe++){const We=this.collectedLeaveElements[Pe],Ue=We[Wi];Ue&&Ue.setForRemoval&&(C.push(We),D.add(We),Ue.hasAnimation?this.driver.query(We,".ng-star-inserted",!0).forEach(Ye=>D.add(Ye)):N.add(We))}const W=new Map,j=TO(p,Array.from(D));j.forEach((Pe,We)=>{const Ue=hb+_++;W.set(We,Ue),Pe.forEach(Ye=>ji(Ye,Ue))}),t.push(()=>{m.forEach((Pe,We)=>{const Ue=y.get(We);Pe.forEach(Ye=>Fh(Ye,Ue))}),j.forEach((Pe,We)=>{const Ue=W.get(We);Pe.forEach(Ye=>Fh(Ye,Ue))}),C.forEach(Pe=>{this.processLeaveNode(Pe)})});const te=[],_e=[];for(let Pe=this._namespaceList.length-1;Pe>=0;Pe--)this._namespaceList[Pe].drainQueuedTransitions(e).forEach(Ue=>{const Ye=Ue.player,pt=Ue.element;if(te.push(Ye),this.collectedEnterElements.length){const Ut=pt[Wi];if(Ut&&Ut.setForMove){if(Ut.previousTriggersValues&&Ut.previousTriggersValues.has(Ue.triggerName)){const tn=Ut.previousTriggersValues.get(Ue.triggerName),Xt=this.statesByElement.get(Ue.element);if(Xt&&Xt.has(Ue.triggerName)){const Cn=Xt.get(Ue.triggerName);Cn.value=tn,Xt.set(Ue.triggerName,Cn)}}return void Ye.destroy()}}const yt=!d||!this.driver.containsElement(d,pt),Et=W.get(pt),wt=y.get(pt),vt=this._buildInstruction(Ue,r,wt,Et,yt);if(vt.errors&&vt.errors.length)return void _e.push(vt);if(yt)return Ye.onStart(()=>Yu(pt,vt.fromStyles)),Ye.onDestroy(()=>ll(pt,vt.toStyles)),void s.push(Ye);if(Ue.isFallbackTransition)return Ye.onStart(()=>Yu(pt,vt.fromStyles)),Ye.onDestroy(()=>ll(pt,vt.toStyles)),void s.push(Ye);const kt=[];vt.timelines.forEach(Ut=>{Ut.stretchStartingKeyframe=!0,this.disabledNodes.has(Ut.element)||kt.push(Ut)}),vt.timelines=kt,r.append(pt,vt.timelines),i.push({instruction:vt,player:Ye,element:pt}),vt.queriedElements.forEach(Ut=>vi(a,Ut,[]).push(Ye)),vt.preStyleProps.forEach((Ut,tn)=>{if(Ut.size){let Xt=l.get(tn);Xt||l.set(tn,Xt=new Set),Ut.forEach((Cn,Sn)=>Xt.add(Sn))}}),vt.postStyleProps.forEach((Ut,tn)=>{let Xt=c.get(tn);Xt||c.set(tn,Xt=new Set),Ut.forEach((Cn,Sn)=>Xt.add(Sn))})});if(_e.length){const Pe=[];_e.forEach(We=>{Pe.push(function Qae(n,t){return new qe(3505,!1)}())}),te.forEach(We=>We.destroy()),this.reportError(Pe)}const Ee=new Map,Ne=new Map;i.forEach(Pe=>{const We=Pe.element;r.has(We)&&(Ne.set(We,We),this._beforeAnimationBuild(Pe.player.namespaceId,Pe.instruction,Ee))}),s.forEach(Pe=>{const We=Pe.element;this._getPreviousPlayers(We,!1,Pe.namespaceId,Pe.triggerName,null).forEach(Ye=>{vi(Ee,We,[]).push(Ye),Ye.destroy()})});const je=C.filter(Pe=>AO(Pe,l,c)),He=new Map;DO(He,this.driver,N,c,Wl).forEach(Pe=>{AO(Pe,l,c)&&je.push(Pe)});const at=new Map;m.forEach((Pe,We)=>{DO(at,this.driver,new Set(Pe),l,EC)}),je.forEach(Pe=>{const We=He.get(Pe),Ue=at.get(Pe);He.set(Pe,new Map([...Array.from(We?.entries()??[]),...Array.from(Ue?.entries()??[])]))});const tt=[],lt=[],st={};i.forEach(Pe=>{const{element:We,player:Ue,instruction:Ye}=Pe;if(r.has(We)){if(u.has(We))return Ue.onDestroy(()=>ll(We,Ye.toStyles)),Ue.disabled=!0,Ue.overrideTotalTime(Ye.totalTime),void s.push(Ue);let pt=st;if(Ne.size>1){let Et=We;const wt=[];for(;Et=Et.parentNode;){const vt=Ne.get(Et);if(vt){pt=vt;break}wt.push(Et)}wt.forEach(vt=>Ne.set(vt,pt))}const yt=this._buildAnimation(Ue.namespaceId,Ye,Ee,o,at,He);if(Ue.setRealPlayer(yt),pt===st)tt.push(Ue);else{const Et=this.playersByElement.get(pt);Et&&Et.length&&(Ue.parentPlayer=jc(Et)),s.push(Ue)}}else Yu(We,Ye.fromStyles),Ue.onDestroy(()=>ll(We,Ye.toStyles)),lt.push(Ue),u.has(We)&&s.push(Ue)}),lt.forEach(Pe=>{const We=o.get(Pe.element);if(We&&We.length){const Ue=jc(We);Pe.setRealPlayer(Ue)}}),s.forEach(Pe=>{Pe.parentPlayer?Pe.syncPlayerEvents(Pe.parentPlayer):Pe.destroy()});for(let Pe=0;Pe<C.length;Pe++){const We=C[Pe],Ue=We[Wi];if(Fh(We,hb),Ue&&Ue.hasAnimation)continue;let Ye=[];if(a.size){let yt=a.get(We);yt&&yt.length&&Ye.push(...yt);let Et=this.driver.query(We,zC,!0);for(let wt=0;wt<Et.length;wt++){let vt=a.get(Et[wt]);vt&&vt.length&&Ye.push(...vt)}}const pt=Ye.filter(yt=>!yt.destroyed);pt.length?Yle(this,We,pt):this.processLeaveNode(We)}return C.length=0,tt.forEach(Pe=>{this.players.push(Pe),Pe.onDone(()=>{Pe.destroy();const We=this.players.indexOf(Pe);this.players.splice(We,1)}),Pe.play()}),tt}elementContainsData(t,e){let r=!1;const s=e[Wi];return s&&s.setForRemoval&&(r=!0),this.playersByElement.has(e)&&(r=!0),this.playersByQueriedElement.has(e)&&(r=!0),this.statesByElement.has(e)&&(r=!0),this._fetchNamespace(t).elementContainsData(e)||r}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,r,s,o){let i=[];if(e){const a=this.playersByQueriedElement.get(t);a&&(i=a)}else{const a=this.playersByElement.get(t);if(a){const l=!o||o==Gf;a.forEach(c=>{c.queued||!l&&c.triggerName!=s||i.push(c)})}}return(r||s)&&(i=i.filter(a=>!(r&&r!=a.namespaceId||s&&s!=a.triggerName))),i}_beforeAnimationBuild(t,e,r){const o=e.element,i=e.isRemovalTransition?void 0:t,a=e.isRemovalTransition?void 0:e.triggerName;for(const l of e.timelines){const c=l.element,u=c!==o,d=vi(r,c,[]);this._getPreviousPlayers(c,u,i,a,e.toState).forEach(m=>{const y=m.getRealPlayer();y.beforeDestroy&&y.beforeDestroy(),m.destroy(),d.push(m)})}Yu(o,e.fromStyles)}_buildAnimation(t,e,r,s,o,i){const a=e.triggerName,l=e.element,c=[],u=new Set,d=new Set,p=e.timelines.map(y=>{const _=y.element;u.add(_);const C=_[Wi];if(C&&C.removedBeforeQueried)return new $f(y.duration,y.delay);const D=_!==l,N=function Qle(n){const t=[];return IO(n,t),t}((r.get(_)||Wle).map(Ee=>Ee.getRealPlayer())).filter(Ee=>!!Ee.element&&Ee.element===_),W=o.get(_),j=i.get(_),te=sO(this._normalizer,y.keyframes,W,j),_e=this._buildPlayer(y,te,N);if(y.subTimeline&&s&&d.add(_),D){const Ee=new nw(t,a,_);Ee.setRealPlayer(_e),c.push(Ee)}return _e});c.forEach(y=>{vi(this.playersByQueriedElement,y.element,[]).push(y),y.onDone(()=>function Xle(n,t,e){let r=n.get(t);if(r){if(r.length){const s=r.indexOf(e);r.splice(s,1)}0==r.length&&n.delete(t)}return r}(this.playersByQueriedElement,y.element,y))}),u.forEach(y=>ji(y,dO));const m=jc(p);return m.onDestroy(()=>{u.forEach(y=>Fh(y,dO)),ll(l,e.toStyles)}),d.forEach(y=>{vi(s,y,[]).push(m)}),m}_buildPlayer(t,e,r){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,r):new $f(t.duration,t.delay)}}class nw{constructor(t,e,r){this.namespaceId=t,this.triggerName=e,this.element=r,this._player=new $f,this._containsRealPlayer=!1,this._queuedCallbacks=new Map,this.destroyed=!1,this.parentPlayer=null,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,this._queuedCallbacks.forEach((e,r)=>{e.forEach(s=>PC(t,r,void 0,s))}),this._queuedCallbacks.clear(),this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){vi(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function wb(n){return n&&1===n.nodeType}function EO(n,t){const e=n.style.display;return n.style.display=t??"none",e}function DO(n,t,e,r,s){const o=[];e.forEach(l=>o.push(EO(l)));const i=[];r.forEach((l,c)=>{const u=new Map;l.forEach(d=>{const p=t.computeStyle(c,d,s);u.set(d,p),(!p||0==p.length)&&(c[Wi]=jle,i.push(c))}),n.set(c,u)});let a=0;return e.forEach(l=>EO(l,o[a++])),i}function TO(n,t){const e=new Map;if(n.forEach(a=>e.set(a,[])),0==t.length)return e;const r=1,s=new Set(t),o=new Map;function i(a){if(!a)return r;let l=o.get(a);if(l)return l;const c=a.parentNode;return l=e.has(c)?c:s.has(c)?r:i(c),o.set(a,l),l}return t.forEach(a=>{const l=i(a);l!==r&&e.get(l).push(a)}),e}function ji(n,t){n.classList?.add(t)}function Fh(n,t){n.classList?.remove(t)}function Yle(n,t,e){jc(e).onDone(()=>n.processLeaveNode(t))}function IO(n,t){for(let e=0;e<n.length;e++){const r=n[e];r instanceof bR?IO(r.players,t):t.push(r)}}function AO(n,t,e){const r=e.get(n);if(!r)return!1;let s=t.get(n);return s?r.forEach(o=>s.add(o)):t.set(n,r),e.delete(n),!0}class Sb{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._triggerCache={},this.onRemovalComplete=(s,o)=>{},this._transitionEngine=new Kle(t,e,r),this._timelineEngine=new Ble(t,e,r),this._transitionEngine.onRemovalComplete=(s,o)=>this.onRemovalComplete(s,o)}registerTrigger(t,e,r,s,o){const i=t+"-"+s;let a=this._triggerCache[i];if(!a){const l=[],u=GC(this._driver,o,l,[]);if(l.length)throw function Uae(n,t){return new qe(3404,!1)}();a=function Fle(n,t,e){return new Ple(n,t,e)}(s,u,this._normalizer),this._triggerCache[i]=a}this._transitionEngine.registerTrigger(e,s,a)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,r,s){this._transitionEngine.insertNode(t,e,r,s)}onRemove(t,e,r,s){this._transitionEngine.removeNode(t,e,s||!1,r)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,r,s){if("@"==r.charAt(0)){const[o,i]=oO(r);this._timelineEngine.command(o,e,i,s)}else this._transitionEngine.trigger(t,e,r,s)}listen(t,e,r,s,o){if("@"==r.charAt(0)){const[i,a]=oO(r);return this._timelineEngine.listen(i,e,a,o)}return this._transitionEngine.listen(t,e,r,s,o)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}let tce=(()=>{class n{constructor(e,r,s){this._element=e,this._startStyles=r,this._endStyles=s,this._state=0;let o=n.initialStylesByElement.get(e);o||n.initialStylesByElement.set(e,o=new Map),this._initialStyles=o}start(){this._state<1&&(this._startStyles&&ll(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(ll(this._element,this._initialStyles),this._endStyles&&(ll(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(n.initialStylesByElement.delete(this._element),this._startStyles&&(Yu(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(Yu(this._element,this._endStyles),this._endStyles=null),ll(this._element,this._initialStyles),this._state=3)}}return n.initialStylesByElement=new WeakMap,n})();function rw(n){let t=null;return n.forEach((e,r)=>{(function nce(n){return"display"===n||"position"===n})(r)&&(t=t||new Map,t.set(r,e))}),t}class NO{constructor(t,e,r,s){this.element=t,this.keyframes=e,this.options=r,this._specialStyles=s,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this._originalOnDoneFns=[],this._originalOnStartFns=[],this.time=0,this.parentPlayer=null,this.currentSnapshot=new Map,this._duration=r.duration,this._delay=r.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:new Map,this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_convertKeyframesToObject(t){const e=[];return t.forEach(r=>{e.push(Object.fromEntries(r))}),e}_triggerWebAnimation(t,e,r){return t.animate(this._convertKeyframesToObject(e),r)}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t=new Map;this.hasStarted()&&this._finalKeyframe.forEach((r,s)=>{"offset"!==s&&t.set(s,this._finished?r:mO(this.element,s))}),this.currentSnapshot=t}triggerCallback(t){const e="start"===t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class rce{validateStyleProperty(t){return!0}validateAnimatableStyleProperty(t){return!0}matchesElement(t,e){return!1}containsElement(t,e){return aO(t,e)}getParentElement(t){return BC(t)}query(t,e,r){return lO(t,e,r)}computeStyle(t,e,r){return window.getComputedStyle(t)[e]}animate(t,e,r,s,o,i=[]){const l={duration:r,delay:s,fill:0==s?"both":"forwards"};o&&(l.easing=o);const c=new Map,u=i.filter(m=>m instanceof NO);(function ule(n,t){return 0===n||0===t})(r,s)&&u.forEach(m=>{m.currentSnapshot.forEach((y,_)=>c.set(_,y))});let d=function ale(n){return n.length?n[0]instanceof Map?n:n.map(t=>hO(t)):[]}(e).map(m=>Gc(m));d=function dle(n,t,e){if(e.size&&t.length){let r=t[0],s=[];if(e.forEach((o,i)=>{r.has(i)||s.push(i),r.set(i,o)}),s.length)for(let o=1;o<t.length;o++){let i=t[o];s.forEach(a=>i.set(a,mO(n,a)))}}return t}(t,d,c);const p=function ece(n,t){let e=null,r=null;return Array.isArray(t)&&t.length?(e=rw(t[0]),t.length>1&&(r=rw(t[t.length-1]))):t instanceof Map&&(e=rw(t)),e||r?new tce(n,e,r):null}(t,d);return new NO(t,d,l,p)}}let sce=(()=>{class n extends hR{constructor(e,r){super(),this._nextAnimationId=0,this._renderer=e.createRenderer(r.body,{id:"0",encapsulation:gs.None,styles:[],data:{animation:[]}})}build(e){const r=this._nextAnimationId.toString();this._nextAnimationId++;const s=Array.isArray(e)?fR(e):e;return kO(this._renderer,null,r,"register",[s]),new oce(r,this._renderer)}}return n.\u0275fac=function(e){return new(e||n)(Ke(Tp),Ke(kn))},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})();class oce extends woe{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new ice(this._id,t,e||{},this._renderer)}}class ice{constructor(t,e,r,s){this.id=t,this.element=e,this._renderer=s,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",r)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return kO(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(t){this._command("setPosition",t)}getPosition(){return this._renderer.engine.players[+this.id]?.getPosition()??0}}function kO(n,t,e,r,s){return n.setProperty(t,`@@${e}:${r}`,s)}const MO="@.disabled";let ace=(()=>{class n{constructor(e,r,s){this.delegate=e,this.engine=r,this._zone=s,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),r.onRemovalComplete=(o,i)=>{const a=i?.parentNode(o);a&&i.removeChild(a,o)}}createRenderer(e,r){const o=this.delegate.createRenderer(e,r);if(!(e&&r&&r.data&&r.data.animation)){let u=this._rendererCache.get(o);return u||(u=new RO("",o,this.engine,()=>this._rendererCache.delete(o)),this._rendererCache.set(o,u)),u}const i=r.id,a=r.id+"-"+this._currentId;this._currentId++,this.engine.register(a,e);const l=u=>{Array.isArray(u)?u.forEach(l):this.engine.registerTrigger(i,a,e,u.name,u)};return r.data.animation.forEach(l),new lce(this,a,o,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(e,r,s){e>=0&&e<this._microtaskId?this._zone.run(()=>r(s)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(o=>{const[i,a]=o;i(a)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([r,s]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return n.\u0275fac=function(e){return new(e||n)(Ke(Tp),Ke(Sb),Ke(wn))},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})();class RO{constructor(t,e,r,s){this.namespaceId=t,this.delegate=e,this.engine=r,this._onDestroy=s,this.destroyNode=this.delegate.destroyNode?o=>e.destroyNode(o):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy(),this._onDestroy?.()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,r,s=!0){this.delegate.insertBefore(t,e,r),this.engine.onInsert(this.namespaceId,e,t,s)}removeChild(t,e,r){this.engine.onRemove(this.namespaceId,e,this.delegate,r)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,r,s){this.delegate.setAttribute(t,e,r,s)}removeAttribute(t,e,r){this.delegate.removeAttribute(t,e,r)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,r,s){this.delegate.setStyle(t,e,r,s)}removeStyle(t,e,r){this.delegate.removeStyle(t,e,r)}setProperty(t,e,r){"@"==e.charAt(0)&&e==MO?this.disableAnimations(t,!!r):this.delegate.setProperty(t,e,r)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,r){return this.delegate.listen(t,e,r)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class lce extends RO{constructor(t,e,r,s,o){super(e,r,s,o),this.factory=t,this.namespaceId=e}setProperty(t,e,r){"@"==e.charAt(0)?"."==e.charAt(1)&&e==MO?this.disableAnimations(t,r=void 0===r||!!r):this.engine.process(this.namespaceId,t,e.slice(1),r):this.delegate.setProperty(t,e,r)}listen(t,e,r){if("@"==e.charAt(0)){const s=function cce(n){switch(n){case"body":return document.body;case"document":return document;case"window":return window;default:return n}}(t);let o=e.slice(1),i="";return"@"!=o.charAt(0)&&([o,i]=function uce(n){const t=n.indexOf(".");return[n.substring(0,t),n.slice(t+1)]}(o)),this.engine.listen(this.namespaceId,s,o,i,a=>{this.factory.scheduleListenerCallback(a._data||-1,r,a)})}return this.delegate.listen(t,e,r)}}const OO=[{provide:hR,useClass:sce},{provide:YC,useFactory:function hce(){return new kle}},{provide:Sb,useClass:(()=>{class n extends Sb{constructor(e,r,s,o){super(e.body,r,s)}ngOnDestroy(){this.flush()}}return n.\u0275fac=function(e){return new(e||n)(Ke(kn),Ke(VC),Ke(YC),Ke(Ll))},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})()},{provide:Tp,useFactory:function pce(n,t,e){return new ace(n,t,e)},deps:[sx,Sb,wn]}],sw=[{provide:VC,useFactory:()=>new rce},{provide:Rl,useValue:"BrowserAnimations"},...OO],FO=[{provide:VC,useClass:cO},{provide:Rl,useValue:"NoopAnimations"},...OO];let fce=(()=>{class n{static withConfig(e){return{ngModule:n,providers:e.disableAnimations?FO:sw}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({providers:sw,imports:[P1]}),n})();function mce(n,t){}class ow{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.ariaModal=!0,this.autoFocus="first-tabbable",this.restoreFocus=!0,this.closeOnNavigation=!0,this.closeOnDestroy=!0,this.closeOnOverlayDetachments=!0}}let gce=(()=>{class n extends MC{constructor(e,r,s,o,i,a,l,c){super(),this._elementRef=e,this._focusTrapFactory=r,this._config=o,this._interactivityChecker=i,this._ngZone=a,this._overlayRef=l,this._focusMonitor=c,this._elementFocusedBeforeDialogWasOpened=null,this._closeInteractionType=null,this.attachDomPortal=u=>{this._portalOutlet.hasAttached();const d=this._portalOutlet.attachDomPortal(u);return this._contentAttached(),d},this._ariaLabelledBy=this._config.ariaLabelledBy||null,this._document=s}_contentAttached(){this._initializeFocusTrap(),this._handleBackdropClicks(),this._captureInitialFocus()}_captureInitialFocus(){this._trapFocus()}ngOnDestroy(){this._restoreFocus()}attachComponentPortal(e){this._portalOutlet.hasAttached();const r=this._portalOutlet.attachComponentPortal(e);return this._contentAttached(),r}attachTemplatePortal(e){this._portalOutlet.hasAttached();const r=this._portalOutlet.attachTemplatePortal(e);return this._contentAttached(),r}_recaptureFocus(){this._containsFocus()||this._trapFocus()}_forceFocus(e,r){this._interactivityChecker.isFocusable(e)||(e.tabIndex=-1,this._ngZone.runOutsideAngular(()=>{const s=()=>{e.removeEventListener("blur",s),e.removeEventListener("mousedown",s),e.removeAttribute("tabindex")};e.addEventListener("blur",s),e.addEventListener("mousedown",s)})),e.focus(r)}_focusByCssSelector(e,r){let s=this._elementRef.nativeElement.querySelector(e);s&&this._forceFocus(s,r)}_trapFocus(){const e=this._elementRef.nativeElement;switch(this._config.autoFocus){case!1:case"dialog":this._containsFocus()||e.focus();break;case!0:case"first-tabbable":this._focusTrap.focusInitialElementWhenReady().then(r=>{r||this._focusDialogContainer()});break;case"first-heading":this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]');break;default:this._focusByCssSelector(this._config.autoFocus)}}_restoreFocus(){const e=this._config.restoreFocus;let r=null;if("string"==typeof e?r=this._document.querySelector(e):"boolean"==typeof e?r=e?this._elementFocusedBeforeDialogWasOpened:null:e&&(r=e),this._config.restoreFocus&&r&&"function"==typeof r.focus){const s=pC(),o=this._elementRef.nativeElement;(!s||s===this._document.body||s===o||o.contains(s))&&(this._focusMonitor?(this._focusMonitor.focusVia(r,this._closeInteractionType),this._closeInteractionType=null):r.focus())}this._focusTrap&&this._focusTrap.destroy()}_focusDialogContainer(){this._elementRef.nativeElement.focus&&this._elementRef.nativeElement.focus()}_containsFocus(){const e=this._elementRef.nativeElement,r=pC();return e===r||e.contains(r)}_initializeFocusTrap(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement),this._document&&(this._elementFocusedBeforeDialogWasOpened=pC())}_handleBackdropClicks(){this._overlayRef.backdropClick().subscribe(()=>{this._config.disableClose&&this._recaptureFocus()})}}return n.\u0275fac=function(e){return new(e||n)(Ve(tr),Ve(jM),Ve(kn,8),Ve(ow),Ve(xC),Ve(wn),Ve(FC),Ve(Ff))},n.\u0275cmp=ys({type:n,selectors:[["cdk-dialog-container"]],viewQuery:function(e,r){if(1&e&&Ac(HR,7),2&e){let s;mi(s=gi())&&(r._portalOutlet=s.first)}},hostAttrs:["tabindex","-1",1,"cdk-dialog-container"],hostVars:6,hostBindings:function(e,r){2&e&&Ks("id",r._config.id||null)("role",r._config.role)("aria-modal",r._config.ariaModal)("aria-labelledby",r._config.ariaLabel?null:r._ariaLabelledBy)("aria-label",r._config.ariaLabel)("aria-describedby",r._config.ariaDescribedBy||null)},features:[$n],decls:1,vars:0,consts:[["cdkPortalOutlet",""]],template:function(e,r){1&e&&Sg(0,mce,0,0,"ng-template",0)},dependencies:[HR],styles:[".cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}"],encapsulation:2}),n})();class iw{constructor(t,e){this.overlayRef=t,this.config=e,this.closed=new et,this.disableClose=e.disableClose,this.backdropClick=t.backdropClick(),this.keydownEvents=t.keydownEvents(),this.outsidePointerEvents=t.outsidePointerEvents(),this.id=e.id,this.keydownEvents.subscribe(r=>{27===r.keyCode&&!this.disableClose&&!bC(r)&&(r.preventDefault(),this.close(void 0,{focusOrigin:"keyboard"}))}),this.backdropClick.subscribe(()=>{this.disableClose||this.close(void 0,{focusOrigin:"mouse"})}),this._detachSubscription=t.detachments().subscribe(()=>{!1!==e.closeOnOverlayDetachments&&this.close()})}close(t,e){if(this.containerInstance){const r=this.closed;this.containerInstance._closeInteractionType=e?.focusOrigin||"program",this._detachSubscription.unsubscribe(),this.overlayRef.dispose(),r.next(t),r.complete(),this.componentInstance=this.containerInstance=null}}updatePosition(){return this.overlayRef.updatePosition(),this}updateSize(t="",e=""){return this.overlayRef.updateSize({width:t,height:e}),this}addPanelClass(t){return this.overlayRef.addPanelClass(t),this}removePanelClass(t){return this.overlayRef.removePanelClass(t),this}}const PO=new Ct("DialogScrollStrategy"),yce=new Ct("DialogData"),bce=new Ct("DefaultDialogConfig"),vce={provide:PO,deps:[Oh],useFactory:function _ce(n){return()=>n.scrollStrategies.block()}};let xce=0,Cce=(()=>{class n{get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}constructor(e,r,s,o,i,a){this._overlay=e,this._injector=r,this._defaultOptions=s,this._parentDialog=o,this._overlayContainer=i,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new et,this._afterOpenedAtThisLevel=new et,this._ariaHiddenElements=new Map,this.afterAllClosed=Qp(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(Jp(void 0))),this._scrollStrategy=a}open(e,r){(r={...this._defaultOptions||new ow,...r}).id=r.id||"cdk-dialog-"+xce++,r.id&&this.getDialogById(r.id);const o=this._getOverlayConfig(r),i=this._overlay.create(o),a=new iw(i,r),l=this._attachContainer(i,a,r);return a.containerInstance=l,this._attachDialogContent(e,a,l,r),this.openDialogs.length||this._hideNonDialogContentFromAssistiveTechnology(),this.openDialogs.push(a),a.closed.subscribe(()=>this._removeOpenDialog(a,!0)),this.afterOpened.next(a),a}closeAll(){aw(this.openDialogs,e=>e.close())}getDialogById(e){return this.openDialogs.find(r=>r.id===e)}ngOnDestroy(){aw(this._openDialogsAtThisLevel,e=>{!1===e.config.closeOnDestroy&&this._removeOpenDialog(e,!1)}),aw(this._openDialogsAtThisLevel,e=>e.close()),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete(),this._openDialogsAtThisLevel=[]}_getOverlayConfig(e){const r=new KR({positionStrategy:e.positionStrategy||this._overlay.position().global().centerHorizontally().centerVertically(),scrollStrategy:e.scrollStrategy||this._scrollStrategy(),panelClass:e.panelClass,hasBackdrop:e.hasBackdrop,direction:e.direction,minWidth:e.minWidth,minHeight:e.minHeight,maxWidth:e.maxWidth,maxHeight:e.maxHeight,width:e.width,height:e.height,disposeOnNavigation:e.closeOnNavigation});return e.backdropClass&&(r.backdropClass=e.backdropClass),r}_attachContainer(e,r,s){const o=s.injector||s.viewContainerRef?.injector,i=[{provide:ow,useValue:s},{provide:iw,useValue:r},{provide:FC,useValue:e}];let a;s.container?"function"==typeof s.container?a=s.container:(a=s.container.type,i.push(...s.container.providers(s))):a=gce;const l=new ub(a,s.viewContainerRef,Gs.create({parent:o||this._injector,providers:i}),s.componentFactoryResolver);return e.attach(l).instance}_attachDialogContent(e,r,s,o){if(e instanceof Ja){const i=this._createInjector(o,r,s,void 0);let a={$implicit:o.data,dialogRef:r};o.templateContext&&(a={...a,..."function"==typeof o.templateContext?o.templateContext():o.templateContext}),s.attachTemplatePortal(new zR(e,null,a,i))}else{const i=this._createInjector(o,r,s,this._injector),a=s.attachComponentPortal(new ub(e,o.viewContainerRef,i,o.componentFactoryResolver));r.componentInstance=a.instance}}_createInjector(e,r,s,o){const i=e.injector||e.viewContainerRef?.injector,a=[{provide:yce,useValue:e.data},{provide:iw,useValue:r}];return e.providers&&("function"==typeof e.providers?a.push(...e.providers(r,e,s)):a.push(...e.providers)),e.direction&&(!i||!i.get(Dh,null,{optional:!0}))&&a.push({provide:Dh,useValue:{value:e.direction,change:sn()}}),Gs.create({parent:i||o,providers:a})}_removeOpenDialog(e,r){const s=this.openDialogs.indexOf(e);s>-1&&(this.openDialogs.splice(s,1),this.openDialogs.length||(this._ariaHiddenElements.forEach((o,i)=>{o?i.setAttribute("aria-hidden",o):i.removeAttribute("aria-hidden")}),this._ariaHiddenElements.clear(),r&&this._getAfterAllClosed().next()))}_hideNonDialogContentFromAssistiveTechnology(){const e=this._overlayContainer.getContainerElement();if(e.parentElement){const r=e.parentElement.children;for(let s=r.length-1;s>-1;s--){const o=r[s];o!==e&&"SCRIPT"!==o.nodeName&&"STYLE"!==o.nodeName&&!o.hasAttribute("aria-live")&&(this._ariaHiddenElements.set(o,o.getAttribute("aria-hidden")),o.setAttribute("aria-hidden","true"))}}}_getAfterAllClosed(){const e=this._parentDialog;return e?e._getAfterAllClosed():this._afterAllClosedAtThisLevel}}return n.\u0275fac=function(e){return new(e||n)(Ke(Oh),Ke(Gs),Ke(bce,8),Ke(n,12),Ke(OC),Ke(PO))},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})();function aw(n,t){let e=n.length;for(;e--;)t(n[e])}let wce=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({providers:[Cce,vce],imports:[JR,db,QM,db]}),n})(),Sce=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({imports:[wce,Os,db,Os]}),n})(),Nue=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({imports:[Os,dR,Os]}),n})(),$ue=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({imports:[Os,Qg,Os]}),n})();const Zc=new Me(se),Bue={connector:()=>new et};function WF(n,t=Bue){const{connector:e}=t;return nn((r,s)=>{const o=e();Dr(n(function Lue(n){return new Me(t=>n.subscribe(t))}(o))).subscribe(s),s.add(r.subscribe(o))})}function jF(n,t){return t?e=>eh(t.pipe(Jr(1),function zue(){return nn((n,t)=>{n.subscribe(Vt(t,se))})}()),e.pipe(jF(n))):hr((e,r)=>Dr(n(e,r)).pipe(Jr(1),iy(e)))}const Qf="Service workers are disabled or not supported by this browser";class Fb{constructor(t){if(this.serviceWorker=t,t){const r=ju(t,"controllerchange").pipe(gt(()=>t.controller)),o=eh(Qp(()=>sn(t.controller)),r);this.worker=o.pipe(Or(u=>!!u)),this.registration=this.worker.pipe(yi(()=>t.getRegistration()));const c=ju(t,"message").pipe(gt(u=>u.data)).pipe(Or(u=>u&&u.type)).pipe(function Uue(n){return n?t=>WF(n)(t):t=>function Vue(n,t){const e=xe(n)?n:()=>n;return xe(t)?WF(t,{connector:e}):r=>new dx(r,e)}(new et)(t)}());c.connect(),this.events=c}else this.worker=this.events=this.registration=function Wue(n){return Qp(()=>Mu(new Error(n)))}(Qf)}postMessage(t,e){return this.worker.pipe(Jr(1),Es(r=>{r.postMessage({action:t,...e})})).toPromise().then(()=>{})}postMessageWithOperation(t,e,r){const s=this.waitForOperationCompleted(r),o=this.postMessage(t,e);return Promise.all([o,s]).then(([,i])=>i)}generateNonce(){return Math.round(1e7*Math.random())}eventsOfType(t){let e;return e="string"==typeof t?r=>r.type===t:r=>t.includes(r.type),this.events.pipe(Or(e))}nextEventOfType(t){return this.eventsOfType(t).pipe(Jr(1))}waitForOperationCompleted(t){return this.eventsOfType("OPERATION_COMPLETED").pipe(Or(e=>e.nonce===t),Jr(1),gt(e=>{if(void 0!==e.result)return e.result;throw new Error(e.error)})).toPromise()}get isEnabled(){return!!this.serviceWorker}}let GF=(()=>{class n{get isEnabled(){return this.sw.isEnabled}constructor(e){if(this.sw=e,this.pushManager=null,this.subscriptionChanges=new et,!e.isEnabled)return this.messages=Zc,this.notificationClicks=Zc,void(this.subscription=Zc);this.messages=this.sw.eventsOfType("PUSH").pipe(gt(s=>s.data)),this.notificationClicks=this.sw.eventsOfType("NOTIFICATION_CLICK").pipe(gt(s=>s.data)),this.pushManager=this.sw.registration.pipe(gt(s=>s.pushManager));const r=this.pushManager.pipe(yi(s=>s.getSubscription()));this.subscription=fs(r,this.subscriptionChanges)}requestSubscription(e){if(!this.sw.isEnabled||null===this.pushManager)return Promise.reject(new Error(Qf));const r={userVisibleOnly:!0};let s=this.decodeBase64(e.serverPublicKey.replace(/_/g,"/").replace(/-/g,"+")),o=new Uint8Array(new ArrayBuffer(s.length));for(let i=0;i<s.length;i++)o[i]=s.charCodeAt(i);return r.applicationServerKey=o,this.pushManager.pipe(yi(i=>i.subscribe(r)),Jr(1)).toPromise().then(i=>(this.subscriptionChanges.next(i),i))}unsubscribe(){return this.sw.isEnabled?this.subscription.pipe(Jr(1),yi(r=>{if(null===r)throw new Error("Not subscribed to push notifications.");return r.unsubscribe().then(s=>{if(!s)throw new Error("Unsubscribe failed!");this.subscriptionChanges.next(null)})})).toPromise():Promise.reject(new Error(Qf))}decodeBase64(e){return atob(e)}}return n.\u0275fac=function(e){return new(e||n)(Ke(Fb))},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})(),KF=(()=>{class n{get isEnabled(){return this.sw.isEnabled}constructor(e){if(this.sw=e,!e.isEnabled)return this.versionUpdates=Zc,this.available=Zc,this.activated=Zc,void(this.unrecoverable=Zc);this.versionUpdates=this.sw.eventsOfType(["VERSION_DETECTED","VERSION_INSTALLATION_FAILED","VERSION_READY","NO_NEW_VERSION_DETECTED"]),this.available=this.versionUpdates.pipe(Or(r=>"VERSION_READY"===r.type),gt(r=>({type:"UPDATE_AVAILABLE",current:r.currentVersion,available:r.latestVersion}))),this.activated=this.sw.eventsOfType("UPDATE_ACTIVATED"),this.unrecoverable=this.sw.eventsOfType("UNRECOVERABLE_STATE")}checkForUpdate(){if(!this.sw.isEnabled)return Promise.reject(new Error(Qf));const e=this.sw.generateNonce();return this.sw.postMessageWithOperation("CHECK_FOR_UPDATES",{nonce:e},e)}activateUpdate(){if(!this.sw.isEnabled)return Promise.reject(new Error(Qf));const e=this.sw.generateNonce();return this.sw.postMessageWithOperation("ACTIVATE_UPDATE",{nonce:e},e)}}return n.\u0275fac=function(e){return new(e||n)(Ke(Fb))},n.\u0275prov=b({token:n,factory:n.\u0275fac}),n})();const XF=new Ct("NGSW_REGISTER_SCRIPT");function jue(n,t,e,r){return()=>{if(!Z0(r)||!("serviceWorker"in navigator)||!1===e.enabled)return;let s;if(navigator.serviceWorker.addEventListener("controllerchange",()=>{null!==navigator.serviceWorker.controller&&navigator.serviceWorker.controller.postMessage({action:"INITIALIZE"})}),"function"==typeof e.registrationStrategy)s=e.registrationStrategy();else{const[i,...a]=(e.registrationStrategy||"registerWhenStable:30000").split(":");switch(i){case"registerImmediately":s=sn(null);break;case"registerWithDelay":s=qF(+a[0]||0);break;case"registerWhenStable":s=a[0]?fs(ZF(n),qF(+a[0])):ZF(n);break;default:throw new Error(`Unknown ServiceWorker registration strategy: ${e.registrationStrategy}`)}}n.get(wn).runOutsideAngular(()=>s.pipe(Jr(1)).subscribe(()=>navigator.serviceWorker.register(t,{scope:e.scope}).catch(i=>console.error("Service worker registration failed with:",i))))}}function qF(n){return sn(null).pipe(function Hue(n,t=Jy){const e=NM(n,t);return jF(()=>e)}(n))}function ZF(n){return n.get(Ll).isStable.pipe(Or(e=>e))}function Gue(n,t){return new Fb(Z0(t)&&!1!==n.enabled?navigator.serviceWorker:void 0)}class Aw{}function Kue(n,t={}){return function K_(n){return{\u0275providers:n}}([GF,KF,{provide:XF,useValue:n},{provide:Aw,useValue:t},{provide:Fb,useFactory:Gue,deps:[Aw,Ml]},{provide:Fg,useFactory:jue,deps:[Gs,XF,Aw,Ml],multi:!0}])}let Xue=(()=>{class n{static register(e,r={}){return{ngModule:n,providers:[Kue(e,r)]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n}),n.\u0275inj=B({providers:[GF,KF]}),n})(),que=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zn({type:n,bootstrap:[_ae]}),n.\u0275inj=B({imports:[P1,Nj,fce,Roe,Boe,Eie,$ie,Sce,Nue,gae,$ue,Xue.register("ngsw-worker.js",{enabled:!0,registrationStrategy:"registerWhenStable:30000"})]}),n})();GH().bootstrapModule(que).catch(n=>console.error(n))},5103:function(mt,Le,O){var ue=O(7156).default;!function(xe,G,q){"use strict";const P={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class U{constructor(ce,X){this.modelPath=X||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(ce)}/model.json`}getPrefix(ce){return"lite_mobilenet_v2"===ce?`ssd${ce}`:`ssd_${ce}`}load(){var ce=this;return ue(function*(){ce.model=yield G.loadGraphModel(ce.modelPath);const X=q.zeros([1,300,300,3],"int32"),ie=yield ce.model.executeAsync(X);yield Promise.all(ie.map(re=>re.data())),ie.map(re=>re.dispose()),X.dispose()})()}infer(ce,X,ie){var re=this;return ue(function*(){const I=q.tidy(()=>(ce instanceof q.Tensor||(ce=q.browser.fromPixels(ce)),q.expandDims(ce))),se=I.shape[1],Ae=I.shape[2],ge=yield re.model.executeAsync(I),Fe=ge[0].dataSync(),ut=ge[1].dataSync();I.dispose(),q.dispose(ge);const[ot,Mt]=re.calculateMaxScores(Fe,ge[0].shape[1],ge[0].shape[2]),ct=q.getBackend();"webgl"===q.getBackend()&&q.setBackend("cpu");const de=q.tidy(()=>{const Be=q.tensor2d(ut,[ge[1].shape[1],ge[1].shape[3]]);return q.image.nonMaxSuppression(Be,ot,X,ie,ie)}),nt=de.dataSync();return de.dispose(),ct!==q.getBackend()&&q.setBackend(ct),re.buildDetectedObjects(Ae,se,ut,ot,nt,Mt)})()}buildDetectedObjects(ce,X,ie,re,I,se){const Ae=I.length,ge=[];for(let Fe=0;Fe<Ae;Fe++){const ut=[];for(let nt=0;nt<4;nt++)ut[nt]=ie[4*I[Fe]+nt];const ot=ut[0]*X,Mt=ut[1]*ce,ct=ut[2]*X,de=ut[3]*ce;ut[0]=Mt,ut[1]=ot,ut[2]=de-Mt,ut[3]=ct-ot,ge.push({bbox:ut,class:P[se[I[Fe]]+1].displayName,score:re[I[Fe]]})}return ge}calculateMaxScores(ce,X,ie){const re=[],I=[];for(let se=0;se<X;se++){let Ae=Number.MIN_VALUE,ge=-1;for(let Fe=0;Fe<ie;Fe++)ce[se*ie+Fe]>Ae&&(Ae=ce[se*ie+Fe],ge=Fe);re[se]=Ae,I[se]=ge}return[re,I]}detect(ce,X=20,ie=.5){var re=this;return ue(function*(){return re.infer(ce,X,ie)})()}dispose(){null!=this.model&&this.model.dispose()}}xe.ObjectDetection=U,xe.load=ue(function*(pe={}){if(null==q)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const ce=pe.base||"lite_mobilenet_v2",X=pe.modelUrl;if(-1===["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(ce))throw new Error(`ObjectDetection constructed with invalid base model ${ce}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const ie=new U(ce,X);return yield ie.load(),ie}),xe.version="2.2.2",Object.defineProperty(xe,"__esModule",{value:!0})}(Le,O(200),O(3798))},200:(mt,Le,O)=>{"use strict";O.r(Le),O.d(Le,{GraphModel:()=>Uo,deregisterOp:()=>Re,loadGraphModel:()=>ta,loadGraphModelSync:()=>gl,registerOp:()=>ee,version_converter:()=>En});var ue={};O.r(ue),O.d(ue,{json:()=>et});var xe={};O.r(xe),O.d(xe,{json:()=>Kt});var G={};O.r(G),O.d(G,{json:()=>dn});var q={};O.r(q),O.d(q,{json:()=>nn});var P={};O.r(P),O.d(P,{json:()=>Vt});var U={};O.r(U),O.d(U,{json:()=>rn});var pe={};O.r(pe),O.d(pe,{json:()=>gt});var ce={};O.r(ce),O.d(ce,{json:()=>cn});var X={};O.r(X),O.d(X,{json:()=>wi});var ie={};O.r(ie),O.d(ie,{json:()=>Rn});var re={};O.r(re),O.d(re,{json:()=>Se});var I={};O.r(I),O.d(I,{json:()=>Ge});var se={};O.r(se),O.d(se,{json:()=>rt});var Ae={};O.r(Ae),O.d(Ae,{json:()=>Rt});var ge={};O.r(ge),O.d(ge,{json:()=>_n});var Fe={};O.r(Fe),O.d(Fe,{json:()=>Nn});var ut={};O.r(ut),O.d(ut,{json:()=>Er});var ot={};O.r(ot),O.d(ot,{json:()=>Yn});var Mt={};O.r(Mt),O.d(Mt,{json:()=>Mr});var ct={};O.r(ct),O.d(ct,{OP_SCOPE_SUFFIX:()=>Ce.zvA,abs:()=>Ce.WnP,acos:()=>Ce.Khb,acosh:()=>Ce.__u,add:()=>Ce.IHx,addN:()=>Ce.QBD,all:()=>Ce.$6P,any:()=>Ce.YjB,argMax:()=>Ce.NqF,argMin:()=>Ce.vHJ,asin:()=>Ce.ZRM,asinh:()=>Ce.VfV,atan:()=>Ce.z4N,atan2:()=>Ce.fvJ,atanh:()=>Ce.C80,avgPool:()=>Ce.wS1,avgPool3d:()=>Ce.uR5,basicLSTMCell:()=>Ce.zEQ,batchNorm:()=>Ce.tgs,batchNorm2d:()=>Ce.Dxk,batchNorm3d:()=>Ce.JY5,batchNorm4d:()=>Ce.p3b,batchToSpaceND:()=>Ce.E4h,bincount:()=>Ce.yE8,bitwiseAnd:()=>Ce.ycw,booleanMaskAsync:()=>Ce.anm,broadcastArgs:()=>Ce.XsQ,broadcastTo:()=>Ce.UFq,buffer:()=>Ce.f3b,cast:()=>Ce.pju,ceil:()=>Ce.mDi,clipByValue:()=>Ce.iUl,clone:()=>Ce.d9v,complex:()=>Ce.PYB,concat:()=>Ce.zoF,concat1d:()=>Ce.gME,concat2d:()=>Ce.Izb,concat3d:()=>Ce.MNy,concat4d:()=>Ce.ZaL,conv1d:()=>Ce.PAt,conv2d:()=>Ce.Tek,conv2dTranspose:()=>Ce.bc,conv3d:()=>Ce.pdZ,conv3dTranspose:()=>Ce.$QV,cos:()=>Ce.mCk,cosh:()=>Ce.f9Y,cosineWindow:()=>Ce.mew,cumprod:()=>Ce.$Gn,cumsum:()=>Ce.zbp,denseBincount:()=>Ce.ppE,depthToSpace:()=>Ce.nTT,depthwiseConv2d:()=>Ce.B10,diag:()=>Ce.Ka3,dilation2d:()=>Ce.WmZ,div:()=>Ce.hiC,divNoNan:()=>Ce.NTj,dot:()=>Ce.AKD,dropout:()=>Ce.rvX,einsum:()=>Ce.WYO,elu:()=>Ce.pyx,enclosingPowerOfTwo:()=>Ce.GRh,ensureShape:()=>Ce.EDe,equal:()=>Ce.DgJ,erf:()=>Ce.qNN,euclideanNorm:()=>Ce.d2q,exp:()=>Ce.Qqt,expandDims:()=>Ce.dt4,expm1:()=>Ce.t$B,eye:()=>Ce.iyy,fft:()=>Ce.kp_,fill:()=>Ce.hlL,floor:()=>Ce.GWj,floorDiv:()=>Ce.qPi,fused:()=>Ce.imm,gather:()=>Ce.Iqj,gatherND:()=>Ce.dbB,greater:()=>Ce.pjt,greaterEqual:()=>Ce.brS,ifft:()=>Ce.Sxn,imag:()=>Ce.asL,image:()=>Ce.BHj,inTopKAsync:()=>Ce.V3u,irfft:()=>Ce.wx0,isFinite:()=>Ce.xVT,isInf:()=>Ce.UWc,isNaN:()=>Ce.i2d,leakyRelu:()=>Ce.hi7,less:()=>Ce.d9m,lessEqual:()=>Ce.zN1,linalg:()=>Ce.$r2,linspace:()=>Ce.SX3,localResponseNormalization:()=>Ce.G9k,log:()=>Ce.cM7,log1p:()=>Ce.Krr,logSigmoid:()=>Ce.e_t,logSoftmax:()=>Ce.CmS,logSumExp:()=>Ce.l_t,logicalAnd:()=>Ce.HvI,logicalNot:()=>Ce.hJK,logicalOr:()=>Ce.K5V,logicalXor:()=>Ce.egP,losses:()=>Ce.MB5,lowerBound:()=>Ce.eab,matMul:()=>Ce.OI3,max:()=>Ce.Fp7,maxPool:()=>Ce._sB,maxPool3d:()=>Ce.YQQ,maxPoolWithArgmax:()=>Ce.Ip$,maximum:()=>Ce.gWQ,mean:()=>Ce.J69,meshgrid:()=>Ce.ry_,min:()=>Ce.VV$,minimum:()=>Ce.LTh,mirrorPad:()=>Ce.VdP,mod:()=>Ce.wQq,moments:()=>Ce.Gi7,movingAverage:()=>Ce.p_,mul:()=>Ce.dC7,multiRNNCell:()=>Ce.rq4,multinomial:()=>Ce.SJ_,neg:()=>Ce.W76,norm:()=>Ce.KOy,notEqual:()=>Ce.Quu,oneHot:()=>Ce.lfX,ones:()=>Ce.iUs,onesLike:()=>Ce.JpU,op:()=>Ce.op,outerProduct:()=>Ce.N2O,pad:()=>Ce.vku,pad1d:()=>Ce.pNR,pad2d:()=>Ce.koy,pad3d:()=>Ce.t1L,pad4d:()=>Ce.lGY,pool:()=>Ce.d_R,pow:()=>Ce.sQ3,prelu:()=>Ce.AL3,print:()=>Ce.S0v,prod:()=>Ce.WVs,raggedGather:()=>Ce.$gW,raggedRange:()=>Ce.VT$,raggedTensorToTensor:()=>Ce.N89,rand:()=>Ce.TN_,randomGamma:()=>Ce.wzB,randomNormal:()=>Ce.nGf,randomStandardNormal:()=>Ce.ruB,randomUniform:()=>Ce.LGj,randomUniformInt:()=>Ce.pe5,range:()=>Ce.w6H,real:()=>Ce.kwC,reciprocal:()=>Ce.M25,relu:()=>Ce.UYe,relu6:()=>Ce.btT,reshape:()=>Ce.XLQ,reverse:()=>Ce.GYS,reverse1d:()=>Ce.SDf,reverse2d:()=>Ce.diP,reverse3d:()=>Ce.sx7,reverse4d:()=>Ce.mG2,rfft:()=>Ce.QEs,round:()=>Ce.NMM,rsqrt:()=>Ce.bp0,scalar:()=>Ce.iD$,scatterND:()=>Ce.snQ,searchSorted:()=>Ce.zcT,selu:()=>Ce.U8D,separableConv2d:()=>Ce.U_I,setdiff1dAsync:()=>Ce.ODp,sigmoid:()=>Ce.XD2,sign:()=>Ce.Xxe,signal:()=>Ce.tdS,sin:()=>Ce.O$l,sinh:()=>Ce.R_K,slice:()=>Ce.tPi,slice1d:()=>Ce.jZU,slice2d:()=>Ce.SmN,slice3d:()=>Ce.CnO,slice4d:()=>Ce.p0P,softmax:()=>Ce.XAC,softplus:()=>Ce.Wvh,spaceToBatchND:()=>Ce.fBT,sparse:()=>Ce.rVs,sparseToDense:()=>Ce.ers,spectral:()=>Ce.uN7,split:()=>Ce.Vl2,sqrt:()=>Ce._b3,square:()=>Ce.h62,squaredDifference:()=>Ce.$i,squeeze:()=>Ce.L9e,stack:()=>Ce.knu,step:()=>Ce.Nbs,stridedSlice:()=>Ce.NXj,string:()=>Ce.Z_8,sub:()=>Ce.luU,sum:()=>Ce.Smz,tan:()=>Ce.ORZ,tanh:()=>Ce.AEp,tensor:()=>Ce.XeE,tensor1d:()=>Ce.RRF,tensor2d:()=>Ce.odF,tensor3d:()=>Ce.wOQ,tensor4d:()=>Ce.yXz,tensor5d:()=>Ce.Bfx,tensor6d:()=>Ce.xZs,tensorScatterUpdate:()=>Ce.Pg0,tile:()=>Ce.Gg6,topk:()=>Ce.hg7,transpose:()=>Ce.p4s,truncatedNormal:()=>Ce.Xu6,unique:()=>Ce.Two,unsortedSegmentSum:()=>Ce.pUJ,unstack:()=>Ce.HHK,upperBound:()=>Ce.GaM,variable:()=>Ce.VD$,where:()=>Ce.arb,whereAsync:()=>Ce.itS,zeros:()=>Ce.lls,zerosLike:()=>Ce.P84});var de=O(3798);(0,de.env)().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,E=>{E&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var ae,Be=O(5861),Q=(()=>((Q=Q||{})[Q.DT_INVALID=0]="DT_INVALID",Q[Q.DT_FLOAT=1]="DT_FLOAT",Q[Q.DT_DOUBLE=2]="DT_DOUBLE",Q[Q.DT_INT32=3]="DT_INT32",Q[Q.DT_UINT8=4]="DT_UINT8",Q[Q.DT_INT16=5]="DT_INT16",Q[Q.DT_INT8=6]="DT_INT8",Q[Q.DT_STRING=7]="DT_STRING",Q[Q.DT_COMPLEX64=8]="DT_COMPLEX64",Q[Q.DT_INT64=9]="DT_INT64",Q[Q.DT_BOOL=10]="DT_BOOL",Q[Q.DT_QINT8=11]="DT_QINT8",Q[Q.DT_QUINT8=12]="DT_QUINT8",Q[Q.DT_QINT32=13]="DT_QINT32",Q[Q.DT_BFLOAT16=14]="DT_BFLOAT16",Q[Q.DT_QINT16=15]="DT_QINT16",Q[Q.DT_QUINT16=16]="DT_QUINT16",Q[Q.DT_UINT16=17]="DT_UINT16",Q[Q.DT_COMPLEX128=18]="DT_COMPLEX128",Q[Q.DT_HALF=19]="DT_HALF",Q[Q.DT_RESOURCE=20]="DT_RESOURCE",Q[Q.DT_VARIANT=21]="DT_VARIANT",Q[Q.DT_UINT32=22]="DT_UINT32",Q[Q.DT_UINT64=23]="DT_UINT64",Q[Q.DT_FLOAT_REF=101]="DT_FLOAT_REF",Q[Q.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",Q[Q.DT_INT32_REF=103]="DT_INT32_REF",Q[Q.DT_UINT8_REF=104]="DT_UINT8_REF",Q[Q.DT_INT16_REF=105]="DT_INT16_REF",Q[Q.DT_INT8_REF=106]="DT_INT8_REF",Q[Q.DT_STRING_REF=107]="DT_STRING_REF",Q[Q.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",Q[Q.DT_INT64_REF=109]="DT_INT64_REF",Q[Q.DT_BOOL_REF=110]="DT_BOOL_REF",Q[Q.DT_QINT8_REF=111]="DT_QINT8_REF",Q[Q.DT_QUINT8_REF=112]="DT_QUINT8_REF",Q[Q.DT_QINT32_REF=113]="DT_QINT32_REF",Q[Q.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",Q[Q.DT_QINT16_REF=115]="DT_QINT16_REF",Q[Q.DT_QUINT16_REF=116]="DT_QUINT16_REF",Q[Q.DT_UINT16_REF=117]="DT_UINT16_REF",Q[Q.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",Q[Q.DT_HALF_REF=119]="DT_HALF_REF",Q[Q.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",Q[Q.DT_VARIANT_REF=121]="DT_VARIANT_REF",Q[Q.DT_UINT32_REF=122]="DT_UINT32_REF",Q[Q.DT_UINT64_REF=123]="DT_UINT64_REF",Q))();!function(E){let f;var g;(g=f=E.CheckpointFormatVersion||(E.CheckpointFormatVersion={}))[g.LEGACY=0]="LEGACY",g[g.V1=1]="V1",g[g.V2=2]="V2"}(ae||(ae={}));const F={};function ee(E,f){F[E]={tfOpName:E,category:"custom",inputs:[],attrs:[],customExecutor:f}}function he(E){return F[E]}function Re(E){delete F[E]}function S(E,f,g,b,z){const B=f.inputParams[E];if(B&&void 0!==B.inputIndexStart){const J=B.inputIndexStart,Ie=0===B.inputIndexEnd?void 0:void 0===B.inputIndexEnd?J+1:B.inputIndexEnd,ht=J<0?f.inputNames.length+J:J;if("tensor"===B.type)return ze(f.inputNames[ht],g,b,z);if("tensors"===B.type){const Tt=f.inputs.slice(J,Ie);return f.inputNames.slice(J,Ie).filter((ln,Dt)=>{var $t;return"NoOp"!==(null===($t=Tt[Dt])||void 0===$t?void 0:$t.op)}).map(ln=>ze(ln,g,b,z))}const dt=ze(f.inputNames[ht],g,b,z),xt=dt.dataSync();return"number"===B.type?xt[0]:de.util.toNestedArray(dt.shape,xt)}const ne=f.attrParams[E];return ne&&ne.value}function ze(E,f,g,b){const[z,B]=ke(E,g);if(null!=b){const J=b.getHashTableHandleByName(z);if(null!=J)return J}const ne=g.currentContextIds.find(J=>!!f[Me(z,J)]);return void 0!==ne?f[Me(z,ne)][B]:void 0}function ye(E,f,g){return f[Me(E,g.currentContextId)]}function ve(E,f){const[g,b,z]=ke(E,f);return[Me(g,f&&f.currentContextId),b,z]}function Me(E,f){return f?`${E}-${f}`:E}function ke(E,f){if(""===E)return["",0,void 0];const g=null!=f&&null!=f.parseNodeNameCache;if(g){const B=f.parseNodeNameCache.get(E);if(null!=B)return B}const b=E.split(":");let z;if(1===b.length)z=[E,0,void 0];else{const ne=3===b.length?b[1]:void 0;z=[b[0],Number(b[b.length-1]),ne]}return g&&f.parseNodeNameCache.set(E,z),z}function _t(E,f,g){let b=S("pad",E,f,g);if("explicit"===b){b=S("explicitPaddings",E,f,g);const z=[[0,0],[0,0],[0,0],[0,0]];for(let B=0;B<4;B++)z[B][0]=b[2*B],z[B][1]=b[2*B+1];return z}return b}function At(E){return E.kept?E:(0,de.clone)(E)}const et=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Kt=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],dn=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],nn=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Vt=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],rn=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],gt=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],cn=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],wi=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Rn=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Se=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Ge=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],rt=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Rt=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],_n=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Nn=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Er=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Yn=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Mr=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class Zo{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const g=[].concat(...[ue,xe,G,q,P,U,pe,ce,X,ie,re,I,se,Ae,ge,Fe,ut,ot,Mt].map(b=>b.json));this.opMappers=g.reduce((b,z)=>(b[z.tfOpName]=z,b),{})}transformGraph(f,g={}){const z=[],B=[],ne=[],J=f.node.reduce((Dt,$t)=>(Dt[$t.name]=this.mapNode($t),$t.op.startsWith("Placeholder")?z.push(Dt[$t.name]):"Const"===$t.op?B.push(Dt[$t.name]):(null==$t.input||0===$t.input.length)&&ne.push(Dt[$t.name]),Dt),{});let Ie=[];const ht=[];let dt={},xt={};null!=g&&(dt=this.mapSignatureEntries(g.inputs),xt=this.mapSignatureEntries(g.outputs));const Tt=Object.keys(J);Tt.forEach(Dt=>{const $t=J[Dt];$t.inputNames.forEach((pn,Vn)=>{const[Us,,Is]=ve(pn),be=J[Us];if(null!=be.outputs){const ms=be.outputs.indexOf(Is);-1!==ms&&($t.inputNames[Vn]=`${Us}:${ms}`)}$t.inputs.push(be),be.children.push($t)})}),0===Object.keys(xt).length?Tt.forEach(Dt=>{const $t=J[Dt];0===$t.children.length&&ht.push($t)}):Object.keys(xt).forEach(Dt=>{const[$t]=ve(Dt),pn=J[$t];null!=pn&&(pn.signatureKey=xt[Dt],ht.push(pn))}),Object.keys(dt).length>0?Object.keys(dt).forEach(Dt=>{const[$t]=ve(Dt),pn=J[$t];pn&&(pn.signatureKey=dt[Dt],Ie.push(pn))}):Ie=z;let Gt={};null!=f.library&&null!=f.library.function&&(Gt=f.library.function.reduce((Dt,$t)=>(Dt[$t.signature.name]=this.mapFunction($t),Dt),{}));const ln={nodes:J,inputs:Ie,outputs:ht,weights:B,placeholders:z,signature:g,functions:Gt};return ne.length>0&&(ln.initNodes=ne),ln}mapSignatureEntries(f){return Object.keys(f||{}).reduce((g,b)=>(g[f[b].name]=b,g),{})}mapNode(f){const g=he(f.op)||this.opMappers[f.op]||{};null==f.attr&&(f.attr={});const b={name:f.name,op:f.op,category:g.category,inputNames:(f.input||[]).map(z=>z.startsWith("^")?z.slice(1):z),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:f.attr,outputs:g.outputs};return null!=g.inputs&&(b.inputParams=g.inputs.reduce((z,B)=>(z[B.name]={type:B.type,inputIndexStart:B.start,inputIndexEnd:B.end},z),{})),null!=g.attrs&&(b.attrParams=g.attrs.reduce((z,B)=>{const ne=B.type;let J;switch(B.type){case"string":J=Si(f.attr,B.tfName,B.defaultValue),void 0===J&&B.tfDeprecatedName&&(J=Si(f.attr,B.tfDeprecatedName,B.defaultValue));break;case"string[]":J=Yo(f.attr,B.tfName,B.defaultValue),void 0===J&&B.tfDeprecatedName&&(J=Yo(f.attr,B.tfDeprecatedName,B.defaultValue));break;case"number":J=Da(f.attr,B.tfName,B.defaultValue||0),void 0===J&&B.tfDeprecatedName&&(J=Da(f.attr,B.tfDeprecatedName,B.defaultValue));break;case"number[]":J=Ta(f.attr,B.tfName,B.defaultValue),void 0===J&&B.tfDeprecatedName&&(J=Ta(f.attr,B.tfDeprecatedName,B.defaultValue));break;case"bool":J=Gi(f.attr,B.tfName,B.defaultValue),void 0===J&&B.tfDeprecatedName&&(J=Gi(f.attr,B.tfDeprecatedName,B.defaultValue));break;case"bool[]":J=qi(f.attr,B.tfName,B.defaultValue),void 0===J&&B.tfDeprecatedName&&(J=qi(f.attr,B.tfDeprecatedName,B.defaultValue));break;case"shape":J=Xi(f.attr,B.tfName,B.defaultValue),void 0===J&&B.tfDeprecatedName&&(J=Xi(f.attr,B.tfDeprecatedName,B.defaultValue));break;case"shape[]":J=Qs(f.attr,B.tfName,B.defaultValue),void 0===J&&B.tfDeprecatedName&&(J=Qs(f.attr,B.tfDeprecatedName,B.defaultValue));break;case"dtype":J=Ds(f.attr,B.tfName,B.defaultValue),void 0===J&&B.tfDeprecatedName&&(J=Ds(f.attr,B.tfDeprecatedName,B.defaultValue));break;case"dtype[]":J=Ki(f.attr,B.tfName,B.defaultValue),void 0===J&&B.tfDeprecatedName&&(J=Ki(f.attr,B.tfDeprecatedName,B.defaultValue));break;case"func":J=Ys(f.attr,B.tfName,B.defaultValue),void 0===J&&B.tfDeprecatedName&&(J=Ys(f.attr,B.tfDeprecatedName,B.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${B.type} for op: ${f.op}`)}return z[B.name]={value:J,type:ne},z},{})),b}mapFunction(f){const g=f.nodeDef,z=[];let B={};null!=g&&(B=g.reduce((xt,Tt)=>(xt[Tt.name]=this.mapNode(Tt),"Const"===Tt.op&&z.push(xt[Tt.name]),xt),{}));const ne=[],J=[];f.signature.inputArg.forEach(xt=>{const[Tt]=ve(xt.name),Gt={name:Tt,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:ps(xt.type),type:"dtype"}},children:[]};Gt.signatureKey=xt.name,ne.push(Gt),B[Tt]=Gt}),Object.keys(B).forEach(xt=>{const Tt=B[xt];Tt.inputNames.forEach((Gt,ln)=>{const[Dt,,$t]=ve(Gt),pn=B[Dt];if(null!=pn.outputs){const Vn=pn.outputs.indexOf($t);-1!==Vn&&(Tt.inputNames[ln]=`${Dt}:${Vn}`)}Tt.inputs.push(pn),pn.children.push(Tt)})});const ht=f.ret;f.signature.outputArg.forEach(xt=>{const[Tt,Gt]=ve(ht[xt.name]),ln=B[Tt];null!=ln&&(ln.defaultOutput=Gt,J.push(ln))});const dt=this.mapArgsToSignature(f);return{nodes:B,inputs:ne,outputs:J,weights:z,placeholders:[],signature:dt}}mapArgsToSignature(f){return{methodName:f.signature.name,inputs:f.signature.inputArg.reduce((g,b)=>(g[b.name]=this.mapArgToTensorInfo(b),g),{}),outputs:f.signature.outputArg.reduce((g,b)=>(g[b.name]=this.mapArgToTensorInfo(b,f.ret),g),{})}}mapArgToTensorInfo(f,g){let b=f.name;return null!=g&&(b=g[b]),{name:b,dtype:f.type}}}function Ea(E,f){const g=Array.isArray(E)?String.fromCharCode.apply(null,E):function _o(E){const f=(0,de.env)().global;if(typeof f.atob<"u")return f.atob(E);if(typeof Buffer<"u")return new Buffer(E,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(E);return f?g:g.toLowerCase()}function Si(E,f,g,b=!1){const z=E[f];return null!=z?Ea(z.s,b):g}function Gi(E,f,g){const b=E[f];return b?b.b:g}function Da(E,f,g){const b=E[f]||{},z=null!=b.i?b.i:null!=b.f?b.f:g;return"number"==typeof z?z:parseInt(z,10)}function ps(E){switch("string"==typeof E&&(E=Q[E]),E){case Q.DT_FLOAT:case Q.DT_HALF:return"float32";case Q.DT_INT32:case Q.DT_INT64:case Q.DT_INT8:case Q.DT_UINT8:return"int32";case Q.DT_BOOL:return"bool";case Q.DT_DOUBLE:return"float32";case Q.DT_STRING:return"string";default:return null}}function Ys(E,f,g){const b=E[f];return b&&b.func?b.func.name:g}function Ds(E,f,g){const b=E[f];return b&&b.type?ps(b.type):g}function Ki(E,f,g){const b=E[f];return b&&b.list&&b.list.type?b.list.type.map(z=>ps(z)):g}function cl(E){if(!E.unknownRank)return null!=E.dim?E.dim.map(f=>"number"==typeof f.size?f.size:parseInt(f.size,10)):[]}function Xi(E,f,g){const b=E[f];return b&&b.shape?cl(b.shape):g}function Ta(E,f,g){const b=E[f];return b?((b.list.f&&b.list.f.length?b.list.f:b.list.i)||[]).map(z=>"number"==typeof z?z:parseInt(z,10)):g}function Yo(E,f,g,b=!1){const z=E[f];return z&&z.list&&z.list.s?z.list.s.map(B=>Ea(B,b)):g}function Qs(E,f,g){const b=E[f];return b&&b.list&&b.list.shape?b.list.shape.map(z=>cl(z)):g}function qi(E,f,g){const b=E[f];return b&&b.list&&b.list.b?b.list.b:g}class ul{constructor(f,g,b){this.node=f,this.tensorMap=g,this.context=b,this.inputs=[],this.attrs={},this.inputs=f.inputNames.map(z=>this.getInput(z)),null!=f.rawAttrs&&(this.attrs=Object.keys(f.rawAttrs).reduce((z,B)=>(z[B]=this.getAttr(B),z),{}))}getInput(f){return ze(f,this.tensorMap,this.context)}getAttr(f,g){const b=this.node.rawAttrs[f];if(null!=b.tensor)return ze(f,this.tensorMap,this.context);if(null!=b.i||null!=b.f)return Da(this.node.rawAttrs,f,g);if(null!=b.s)return Si(this.node.rawAttrs,f,g);if(null!=b.b)return Gi(this.node.rawAttrs,f,g);if(null!=b.shape)return Xi(this.node.rawAttrs,f,g);if(null!=b.type)return Ds(this.node.rawAttrs,f,g);if(null!=b.list){if(null!=b.list.i||null!=b.list.f)return Ta(this.node.rawAttrs,f,g);if(null!=b.list.s)return Yo(this.node.rawAttrs,f,g);if(null!=b.list.shape)return Qs(this.node.rawAttrs,f,g);if(null!=b.list.b)return qi(this.node.rawAttrs,f,g);if(null!=b.list.type)return Ki(this.node.rawAttrs,f,g)}return g}}var Ce=O(3809);function _r(E,f,g=""){if("number"!=typeof E&&"number"!=typeof f){de.util.assert(E.length===f.length,()=>g+` Shapes ${E} and ${f} must match`);for(let b=0;b<E.length;b++){const z=E[b],B=f[b];de.util.assert(z<0||B<0||z===B,()=>g+` Shapes ${E} and ${f} must match`)}}}function vr(E){return!("number"==typeof E||E.some(f=>f<0))}function Js(E,f,g){let b=Jo(E,g);const z=!vr(b);if(z&&0===f.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${b}`);if(z&&f.forEach(B=>{b=Jo(B.shape,b)}),!vr(b))throw new Error(`Non-fully-defined elementShape: ${b}`);return b}function Jo(E,f){if("number"==typeof E)return f;if("number"==typeof f)return E;if(E.length!==f.length)throw new Error(`Incompatible ranks during merge: ${E} vs. ${f}`);const g=[];for(let b=0;b<E.length;++b){const z=E[b],B=f[b];if(z>=0&&B>=0&&z!==B)throw new Error(`Incompatible shape during merge: ${E} vs. ${f}`);g[b]=z>=0?z:B}return g}class Ei{constructor(f,g,b,z,B,ne,J){this.name=f,this.dtype=g,this.maxSize=b,this.elementShape=z,this.identicalElementShapes=B,this.dynamicSize=ne,this.clearAfterRead=J,this.tensors=[],this.closed_=!1,this.idTensor=(0,de.scalar)(0),(0,de.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(f){this.tensors.forEach(g=>{(null==f||!f.has(g.tensor.id))&&g.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(f){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(f<0||f>=this.size())throw new Error(`Tried to read from index ${f}, but array size is: ${this.size()}`);const g=this.tensors[f];if(g.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${f} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(g.cleared=!0),g.read=!0,g.tensor}readMany(f){return f.map(g=>this.read(g))}write(f,g){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(f<0||!this.dynamicSize&&f>=this.maxSize)throw new Error(`Tried to write to index ${f}, but array is not resizeable and size is: ${this.maxSize}`);const b=this.tensors[f]||{};if(g.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${f},\n          because the value dtype is ${g.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=g.shape),_r(this.elementShape,g.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${f}.`),b.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${f}, because it has already been read.`);if(b.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${f}, because it has already been written.`);b.tensor=g,(0,de.keep)(g),b.written=!0,this.tensors[f]=b}writeMany(f,g){if(f.length!==g.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${f.length} is not the same as tensors size: ${g.length}.`);f.forEach((b,z)=>this.write(b,g[z]))}gather(f,g){if(g&&g!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${g}`);if(f)f=f.slice(0,this.size());else{f=[];for(let z=0;z<this.size();z++)f.push(z)}if(0===f.length)return(0,de.tensor)([],[0].concat(this.elementShape));const b=this.readMany(f);return _r(this.elementShape,b[0].shape,"TensorArray shape mismatch: "),(0,de.stack)(b,0)}concat(f){if(f&&f!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${f}`);if(0===this.size())return(0,de.tensor)([],[0].concat(this.elementShape));const g=[];for(let z=0;z<this.size();z++)g.push(z);const b=this.readMany(g);return _r(this.elementShape,b[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${b[0].shape})`),(0,de.concat)(b,0)}scatter(f,g){if(g.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${g.dtype}`);if(f.length!==g.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${f.length} vs. ${g.shape[0]}`);const b=Math.max(...f);if(!this.dynamicSize&&b>=this.maxSize)throw new Error(`Max index must be < array size (${b}  vs. ${this.maxSize})`);this.writeMany(f,(0,de.unstack)(g,0))}split(f,g){if(g.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${g.dtype}`);let b=0;const z=f.map(Ie=>(b+=Ie,b));if(b!==g.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${b}, and tensor's shape is: ${g.shape}`);if(!this.dynamicSize&&f.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${f.length}), and the TensorArray is not marked as dynamically resizeable`);const B=0===b?0:g.size/b,ne=[];(0,de.tidy)(()=>{g=(0,de.reshape)(g,[1,b,B]);for(let Ie=0;Ie<f.length;++Ie)ne[Ie]=(0,de.reshape)((0,de.slice)(g,[0,0===Ie?0:z[Ie-1],0],[1,f[Ie],B]),this.elementShape);return ne});const J=[];for(let Ie=0;Ie<f.length;Ie++)J[Ie]=Ie;this.writeMany(J,ne)}}class eo{get id(){return this.idTensor.id}constructor(f,g,b,z=-1){this.tensors=f,this.elementShape=g,this.elementDtype=b,f?.forEach(B=>{if(b!==B.dtype)throw new Error(`Invalid data types; op elements ${b}, but list elements ${B.dtype}`);_r(g,B.shape,"TensorList shape mismatch: "),(0,de.keep)(B)}),this.idTensor=(0,de.scalar)(0),this.maxNumElements=z,(0,de.keep)(this.idTensor)}copy(){return new eo([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(f){this.tensors.forEach(g=>{(null==f||!f.has(g.id))&&g.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(f,g,b=-1){if(g!==this.elementDtype)throw new Error(`Invalid data types; op elements ${g}, but list elements ${this.elementDtype}`);if(-1!==b&&this.tensors.length!==b)throw new Error(`Operation expected a list with ${b} elements but got a list with ${this.tensors.length} elements.`);_r(f,this.elementShape,"TensorList shape mismatch: ");const z=Js(this.elementShape,this.tensors,f);return(0,de.tidy)(()=>{const B=this.tensors.map(ne=>(0,de.reshape)(ne,z));return(0,de.stack)(B,0)})}popBack(f,g){if(g!==this.elementDtype)throw new Error(`Invalid data types; op elements ${g}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const b=Js(this.elementShape,this.tensors,f),z=this.tensors.pop();return z.kept=!1,_r(z.shape,f,"TensorList shape mismatch: "),(0,de.reshape)(z,b)}pushBack(f){if(f.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${f.dtype}, but list elements ${this.elementDtype}`);if(_r(f.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,de.keep)(f),this.tensors.push(f)}resize(f){if(f<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${f}`);if(-1!==this.maxNumElements&&f>this.maxNumElements)throw new Error(`TensorListResize input size ${f} is greater maxNumElement ${this.maxNumElements}.`);const g=new eo([],this.elementShape,this.elementDtype,this.maxNumElements);g.tensors.length=f;for(let b=0;b<Math.min(this.tensors.length,f);++b)g.tensors[b]=this.tensors[b];return g}getItem(f,g,b){if(b!==this.elementDtype)throw new Error(`Invalid data types; op elements ${b}, but list elements ${this.elementDtype}`);if(f<0||f>this.tensors.length)throw new Error(`Trying to access element ${f} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[f])throw new Error(`element at index ${f} is null.`);_r(this.tensors[f].shape,g,"TensorList shape mismatch: ");const z=Js(this.elementShape,this.tensors,g);return(0,de.reshape)(this.tensors[f],z)}setItem(f,g){if(g.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${g.dtype}, but list elements ${this.elementDtype}`);if(f<0||-1!==this.maxNumElements&&f>=this.maxNumElements)throw new Error(`Trying to set element ${f} in a list with max ${this.maxNumElements} elements.`);_r(this.elementShape,g.shape,"TensorList shape mismatch: "),(0,de.keep)(g),null!=this.tensors[f]&&(this.tensors[f].kept=!1),this.tensors[f]=g}gather(f,g,b){if(g!==this.elementDtype)throw new Error(`Invalid data types; op elements ${g}, but list elements ${this.elementDtype}`);_r(this.elementShape,b,"TensorList shape mismatch: "),f=f.slice(0,this.size());const z=Js(this.elementShape,this.tensors,b);return 0===f.length?(0,de.tensor)([],[0].concat(z)):(0,de.tidy)(()=>{const B=f.map(ne=>(0,de.reshape)(this.tensors[ne],z));return(0,de.stack)(B,0)})}concat(f,g){if(f&&f!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${f}`);_r(this.elementShape,g,"TensorList shape mismatch: ");const b=Js(this.elementShape,this.tensors,g);return 0===this.size()?(0,de.tensor)([],[0].concat(b)):(0,de.tidy)(()=>{const z=this.tensors.map(B=>(0,de.reshape)(B,b));return(0,de.concat)(z,0)})}}const Yi=function(){var E=(0,Be.Z)(function*(f,g,b){switch(f.op){case"If":case"StatelessIf":{const z=S("thenBranch",f,g,b),B=S("elseBranch",f,g,b),ne=S("cond",f,g,b),J=S("args",f,g,b);return(yield ne.data())[0]?b.functionMap[z].executeFunctionAsync(J,b.tensorArrayMap,b.tensorListMap):b.functionMap[B].executeFunctionAsync(J,b.tensorArrayMap,b.tensorListMap)}case"While":case"StatelessWhile":{const z=S("body",f,g,b),B=S("cond",f,g,b),ne=S("args",f,g,b),J=yield b.functionMap[B].executeFunctionAsync(ne,b.tensorArrayMap,b.tensorListMap),Ie=ne.map(xt=>xt.id);let ht=yield J[0].data();J.forEach(xt=>{!xt.kept&&-1===Ie.indexOf(xt.id)&&xt.dispose()});let dt=ne;for(;ht[0];){const xt=dt;dt=yield b.functionMap[z].executeFunctionAsync(dt,b.tensorArrayMap,b.tensorListMap);const Tt=dt.map(ln=>ln.id);xt.forEach(ln=>{!ln.kept&&-1===Ie.indexOf(ln.id)&&-1===Tt.indexOf(ln.id)&&ln.dispose()});const Gt=yield b.functionMap[B].executeFunctionAsync(dt,b.tensorArrayMap,b.tensorListMap);ht=yield Gt[0].data(),Gt.forEach(ln=>{!ln.kept&&-1===Ie.indexOf(ln.id)&&-1===Tt.indexOf(ln.id)&&ln.dispose()})}return dt}case"LoopCond":return[At(S("pred",f,g,b))];case"Switch":{const z=S("pred",f,g,b);let B=S("data",f,g,b);return B.kept||(B=At(B)),(yield z.data())[0]?[void 0,B]:[B,void 0]}case"Merge":{const z=f.inputNames.find(B=>void 0!==ze(B,g,b));return z?[At(ze(z,g,b))]:void 0}case"Enter":{const z=S("frameName",f,g,b),B=S("tensor",f,g,b);return b.enterFrame(z),[At(B)]}case"Exit":{const z=S("tensor",f,g,b);return b.exitFrame(),[At(z)]}case"NextIteration":{const z=S("tensor",f,g,b);return b.nextIteration(),[At(z)]}case"TensorArrayV3":{const z=S("size",f,g,b),B=S("dtype",f,g,b),ne=S("elementShape",f,g,b),J=S("dynamicSize",f,g,b),Ie=S("clearAfterRead",f,g,b),ht=S("identicalElementShapes",f,g,b),dt=S("name",f,g,b),xt=new Ei(dt,B,z,ne,ht,J,Ie);return b.addTensorArray(xt),[xt.idTensor,(0,de.scalar)(1)]}case"TensorArrayWriteV3":{const z=S("tensorArrayId",f,g,b),B=S("index",f,g,b),ne=S("tensor",f,g,b),J=b.getTensorArray(z.id);return J.write(B,ne),[J.idTensor]}case"TensorArrayReadV3":{const z=S("tensorArrayId",f,g,b),B=S("index",f,g,b);return[b.getTensorArray(z.id).read(B)]}case"TensorArrayGatherV3":{const z=S("tensorArrayId",f,g,b),B=S("indices",f,g,b),ne=S("dtype",f,g,b);return[b.getTensorArray(z.id).gather(B,ne)]}case"TensorArrayScatterV3":{const z=S("tensorArrayId",f,g,b),B=S("indices",f,g,b),ne=S("tensor",f,g,b),J=b.getTensorArray(z.id);return J.scatter(B,ne),[J.idTensor]}case"TensorArrayConcatV3":{const z=S("tensorArrayId",f,g,b),B=b.getTensorArray(z.id),ne=S("dtype",f,g,b);return[B.concat(ne)]}case"TensorArraySplitV3":{const z=S("tensorArrayId",f,g,b),B=S("tensor",f,g,b),ne=S("lengths",f,g,b),J=b.getTensorArray(z.id);return J.split(ne,B),[J.idTensor]}case"TensorArraySizeV3":{const z=S("tensorArrayId",f,g,b),B=b.getTensorArray(z.id);return[(0,de.scalar)(B.size(),"int32")]}case"TensorArrayCloseV3":{const z=S("tensorArrayId",f,g,b),B=b.getTensorArray(z.id);return B.clearAndClose(),[B.idTensor]}case"TensorListSetItem":{const z=S("tensorListId",f,g,b),B=S("index",f,g,b),ne=S("tensor",f,g,b),J=b.getTensorList(z.id);return J.setItem(B,ne),[J.idTensor]}case"TensorListGetItem":{const z=S("tensorListId",f,g,b),B=S("index",f,g,b),ne=S("elementShape",f,g,b),J=S("elementDType",f,g,b);return[b.getTensorList(z.id).getItem(B,ne,J)]}case"TensorListScatterV2":case"TensorListScatter":{const z=S("indices",f,g,b),Ie=function Po(E,f,g,b){if(f.length!==E.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${f.length} vs. ${E.shape[0]}`);const z=Math.max(...f);if(null!=b&&-1!==b&&z>=b)throw new Error(`Max index must be < array size (${z}  vs. ${b})`);const B=new eo([],g,E.dtype,b),ne=(0,de.unstack)(E,0);return f.forEach((J,Ie)=>{B.setItem(J,ne[Ie])}),B}(S("tensor",f,g,b),z,S("elementShape",f,g,b),S("numElements",f,g,b));return b.addTensorList(Ie),[Ie.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const z=S("elementShape",f,g,b),B=S("elementDType",f,g,b);let ne;ne="TensorListReserve"===f.op?"numElements":"maxNumElements";const J=S(ne,f,g,b),ht=function Dr(E,f,g,b){return new eo([],E,f,b)}(z,B,0,"TensorListReserve"===f.op?-1:J);return b.addTensorList(ht),[ht.idTensor]}case"TensorListGather":{const z=S("tensorListId",f,g,b),B=S("indices",f,g,b),ne=S("elementShape",f,g,b),J=S("elementDType",f,g,b);return[b.getTensorList(z.id).gather(B,J,ne)]}case"TensorListStack":{const z=S("tensorListId",f,g,b),B=S("elementShape",f,g,b),ne=S("elementDType",f,g,b),J=S("numElements",f,g,b);return[b.getTensorList(z.id).stack(B,ne,J)]}case"TensorListFromTensor":{const J=function Di(E,f,g){const b=E.dtype;if(E.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${E.shape}`);if(E.dtype!==g)throw new Error(`Invalid data types; op elements ${E.dtype}, but list elements ${g}`);_r(E.shape.slice(1),f,"TensorList shape mismatch: ");const B=(0,de.unstack)(E);return new eo(B,f,b)}(S("tensor",f,g,b),S("elementShape",f,g,b),S("elementDType",f,g,b));return b.addTensorList(J),[J.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const z=S("tensorListId",f,g,b),B=b.getTensorList(z.id),ne=S("dtype",f,g,b),J=S("elementShape",f,g,b);return[B.concat(ne,J)]}case"TensorListPushBack":{const z=S("tensorListId",f,g,b),B=S("tensor",f,g,b),ne=b.getTensorList(z.id);return ne.pushBack(B),[ne.idTensor]}case"TensorListPopBack":{const z=S("tensorListId",f,g,b),B=S("elementShape",f,g,b),ne=S("elementDType",f,g,b);return[b.getTensorList(z.id).popBack(B,ne)]}case"TensorListSplit":{const z=S("tensor",f,g,b),B=S("elementShape",f,g,b),J=function hl(E,f,g){let b=0;const z=f.map(dt=>(b+=dt,b));if(b!==E.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${b}, and tensor's shape is: ${E.shape}`);const ne=Jo(E.shape.slice(1),g),J=0===b?0:E.size/b,Ie=(0,de.tidy)(()=>{const dt=[];E=(0,de.reshape)(E,[1,b,J]);for(let xt=0;xt<f.length;++xt)dt[xt]=(0,de.reshape)((0,de.slice)(E,[0,0===xt?0:z[xt-1],0],[1,f[xt],J]),ne);return E.dispose(),dt}),ht=new eo([],g,E.dtype,f.length);for(let dt=0;dt<Ie.length;dt++)ht.setItem(dt,Ie[dt]);return ht}(z,S("lengths",f,g,b),B);return b.addTensorList(J),[J.idTensor]}case"TensorListLength":{const z=S("tensorListId",f,g,b),B=b.getTensorList(z.id);return[(0,de.scalar)(B.size(),"int32")]}case"TensorListResize":{const z=S("tensorListId",f,g,b),B=S("size",f,g,b),J=b.getTensorList(z.id).resize(B);return b.addTensorList(J),[J.idTensor]}default:throw TypeError(`Node type ${f.op} is not implemented`)}});return function(g,b,z){return E.apply(this,arguments)}}();function $o(E,f,g){const[b,z]=S("fusedOps",E,f,g),B="biasadd"===b,ne=!B,J="prelu"===z,Ie="fusedbatchnorm"===b,ht=S("numArgs",E,f,g);if(B){if(J&&2!==ht)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!J&&B&&1!==ht)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(Ie)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const dt=S("strides",E,f,g),xt=_t(E,f,g),Tt=S("dataFormat",E,f,g).toUpperCase(),Gt=S("dilations",E,f,g);let[ln,Dt]=S("args",E,f,g);return ne&&(Dt=ln,ln=void 0),{stride:dt,pad:xt,dataFormat:Tt,dilations:Gt,biasArg:ln,preluArg:Dt,activationFunc:z,leakyreluAlpha:S("leakyreluAlpha",E,f,g)}}function hr(E,f,g){return{boxes:S("boxes",E,f,g),scores:S("scores",E,f,g),maxOutputSize:S("maxOutputSize",E,f,g),iouThreshold:S("iouThreshold",E,f,g),scoreThreshold:S("scoreThreshold",E,f,g),softNmsSigma:S("softNmsSigma",E,f,g)}}const ti=function(){var E=(0,Be.Z)(function*(f,g,b,z,B=ct){switch(f.op){case"NonMaxSuppressionV5":{const{boxes:ne,scores:J,maxOutputSize:Ie,iouThreshold:ht,scoreThreshold:dt,softNmsSigma:xt}=hr(f,g,b),Tt=yield B.image.nonMaxSuppressionWithScoreAsync(ne,J,Ie,ht,dt,xt);return[Tt.selectedIndices,Tt.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:ne,scores:J,maxOutputSize:Ie,iouThreshold:ht,scoreThreshold:dt}=hr(f,g,b),xt=S("padToMaxOutputSize",f,g,b),Tt=yield B.image.nonMaxSuppressionPaddedAsync(ne,J,Ie,ht,dt,xt);return[Tt.selectedIndices,Tt.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:ne,scores:J,maxOutputSize:Ie,iouThreshold:ht,scoreThreshold:dt}=hr(f,g,b);return[yield B.image.nonMaxSuppressionAsync(ne,J,Ie,ht,dt)]}case"Where":{const ne=B.cast(S("condition",f,g,b),"bool"),J=[yield B.whereAsync(ne)];return ne.dispose(),J}case"ListDiff":return B.setdiff1dAsync(S("x",f,g,b),S("y",f,g,b));default:throw TypeError(`Node type ${f.op} is not implemented`)}});return function(g,b,z,B){return E.apply(this,arguments)}}();var Aa=O(316);class $s{get id(){return this.handle.id}constructor(f,g){this.keyDType=f,this.valueDType=g,this.handle=(0,de.scalar)(0),this.tensorMap=new Map,(0,de.keep)(this.handle)}clearAndClose(){this.tensorMap.forEach(f=>f.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Aa.i(this.size(),"int32")}import(f,g){var b=this;return(0,Be.Z)(function*(){b.checkKeyAndValueTensor(f,g);const z=yield f.data();return b.tensorMap.forEach(B=>B.dispose()),b.tensorMap.clear(),(0,de.tidy)(()=>{const B=(0,de.unstack)(g),ne=z.length,J=B.length;de.util.assert(ne===J,()=>`The number of elements doesn't match, keys has ${ne} elements, the values has ${J} elements.`);for(let Ie=0;Ie<ne;Ie++){const ht=z[Ie],dt=B[Ie];(0,de.keep)(dt),b.tensorMap.set(ht,dt)}return b.handle})})()}find(f,g){var b=this;return(0,Be.Z)(function*(){b.checkKeyAndValueTensor(f,g);const z=yield f.data();return(0,de.tidy)(()=>{const B=[];for(let ne=0;ne<z.length;ne++){const Ie=b.findWithDefault(z[ne],g);B.push(Ie)}return(0,de.stack)(B)})})()}findWithDefault(f,g){return this.tensorMap.get(f)??g}checkKeyAndValueTensor(f,g){if(f.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${f.dtype}`);if(g.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${g.dtype}`)}}const fl=function(){var E=(0,Be.Z)(function*(f,g,b,z){switch(f.op){case"HashTable":case"HashTableV2":{const B=z.getHashTableHandleByName(f.name);if(null!=B)return[B];{const ne=S("keyDType",f,g,b),J=S("valueDType",f,g,b),Ie=new $s(ne,J);return z.addHashTable(f.name,Ie),[Ie.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const B=S("tableHandle",f,g,b,z),ne=S("keys",f,g,b),J=S("values",f,g,b);return[yield z.getHashTableById(B.id).import(ne,J)]}case"LookupTableFind":case"LookupTableFindV2":{const B=S("tableHandle",f,g,b,z),ne=S("keys",f,g,b),J=S("defaultValue",f,g,b);return[yield z.getHashTableById(B.id).find(ne,J)]}case"LookupTableSize":case"LookupTableSizeV2":{const B=S("tableHandle",f,g,b,z);return[z.getHashTableById(B.id).tensorSize()]}default:throw TypeError(`Node type ${f.op} is not implemented`)}});return function(g,b,z,B){return E.apply(this,arguments)}}();function si(E,f,g,b,z=de.tidy){const B=((ne,J,Ie)=>{switch(ne.category){case"arithmetic":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"BiasAdd":case"AddV2":case"Add":return[b.add(S("a",E,f,g),S("b",E,f,g))];case"AddN":return[b.addN(S("tensors",E,f,g))];case"FloorMod":case"Mod":return[b.mod(S("a",E,f,g),S("b",E,f,g))];case"Mul":return[b.mul(S("a",E,f,g),S("b",E,f,g))];case"RealDiv":case"Div":return[b.div(S("a",E,f,g),S("b",E,f,g))];case"DivNoNan":return[b.divNoNan(S("a",E,f,g),S("b",E,f,g))];case"FloorDiv":return[b.floorDiv(S("a",E,f,g),S("b",E,f,g))];case"Sub":return[b.sub(S("a",E,f,g),S("b",E,f,g))];case"Minimum":return[b.minimum(S("a",E,f,g),S("b",E,f,g))];case"Maximum":return[b.maximum(S("a",E,f,g),S("b",E,f,g))];case"Pow":return[b.pow(S("a",E,f,g),S("b",E,f,g))];case"SquaredDifference":return[b.squaredDifference(S("a",E,f,g),S("b",E,f,g))];default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"basic_math":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"Abs":case"ComplexAbs":return[b.abs(S("x",E,f,g))];case"Acos":return[b.acos(S("x",E,f,g))];case"Acosh":return[b.acosh(S("x",E,f,g))];case"Asin":return[b.asin(S("x",E,f,g))];case"Asinh":return[b.asinh(S("x",E,f,g))];case"Atan":return[b.atan(S("x",E,f,g))];case"Atan2":return[b.atan2(S("x",E,f,g),S("y",E,f,g))];case"Atanh":return[b.atanh(S("x",E,f,g))];case"Ceil":return[b.ceil(S("x",E,f,g))];case"Complex":return[b.complex(S("real",E,f,g),S("imag",E,f,g))];case"Cos":return[b.cos(S("x",E,f,g))];case"Cosh":return[b.cosh(S("x",E,f,g))];case"Elu":return[b.elu(S("x",E,f,g))];case"Erf":return[b.erf(S("x",E,f,g))];case"Exp":return[b.exp(S("x",E,f,g))];case"Expm1":return[b.expm1(S("x",E,f,g))];case"Floor":return[b.floor(S("x",E,f,g))];case"Log":return[b.log(S("x",E,f,g))];case"Log1p":return[b.log1p(S("x",E,f,g))];case"Imag":return[b.imag(S("x",E,f,g))];case"Neg":return[b.neg(S("x",E,f,g))];case"Reciprocal":return[b.reciprocal(S("x",E,f,g))];case"Real":return[b.real(S("x",E,f,g))];case"Relu":return[b.relu(S("x",E,f,g))];case"Round":return[b.round(S("x",E,f,g))];case"Selu":return[b.selu(S("x",E,f,g))];case"Sigmoid":return[b.sigmoid(S("x",E,f,g))];case"Sin":return[b.sin(S("x",E,f,g))];case"Sign":return[b.sign(S("x",E,f,g))];case"Sinh":return[b.sinh(S("x",E,f,g))];case"Softplus":return[b.softplus(S("x",E,f,g))];case"Sqrt":return[b.sqrt(S("x",E,f,g))];case"Square":return[b.square(S("x",E,f,g))];case"Tanh":return[b.tanh(S("x",E,f,g))];case"Tan":return[b.tan(S("x",E,f,g))];case"ClipByValue":return[b.clipByValue(S("x",E,f,g),S("clipValueMin",E,f,g),S("clipValueMax",E,f,g))];case"Relu6":return[b.relu6(S("x",E,f,g))];case"Rsqrt":return[b.rsqrt(ze(E.inputNames[0],f,g))];case"LeakyRelu":return[b.leakyRelu(S("x",E,f,g),S("alpha",E,f,g))];case"Prelu":return[b.prelu(S("x",E,f,g),S("alpha",E,f,g))];case"IsNan":return[b.isNaN(ze(E.inputNames[0],f,g))];case"IsInf":return[b.isInf(ze(E.inputNames[0],f,g))];case"IsFinite":return[b.isFinite(ze(E.inputNames[0],f,g))];default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"control":return Yi(ne,J,Ie);case"convolution":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"Conv1D":{const z=S("stride",E,f,g),B=S("pad",E,f,g),ne=S("dataFormat",E,f,g).toUpperCase(),J=S("dilation",E,f,g);return[b.conv1d(S("x",E,f,g),S("filter",E,f,g),z,B,ne,J)]}case"Conv2D":{const z=S("strides",E,f,g),B=_t(E,f,g),ne=S("dataFormat",E,f,g).toUpperCase(),J=S("dilations",E,f,g);return[b.conv2d(S("x",E,f,g),S("filter",E,f,g),[z[1],z[2]],B,ne,[J[1],J[2]])]}case"_FusedConv2D":{const{stride:z,pad:B,dataFormat:ne,dilations:J,biasArg:Ie,preluArg:ht,activationFunc:dt,leakyreluAlpha:xt}=$o(E,f,g);return[b.fused.conv2d({x:S("x",E,f,g),filter:S("filter",E,f,g),strides:[z[1],z[2]],pad:B,dataFormat:ne,dilations:[J[1],J[2]],bias:Ie,activation:dt,preluActivationWeights:ht,leakyreluAlpha:xt})]}case"FusedDepthwiseConv2dNative":{const{stride:z,pad:B,dataFormat:ne,dilations:J,biasArg:Ie,preluArg:ht,activationFunc:dt,leakyreluAlpha:xt}=$o(E,f,g);return[b.fused.depthwiseConv2d({x:S("x",E,f,g),filter:S("filter",E,f,g),strides:[z[1],z[2]],pad:B,dataFormat:ne,dilations:[J[1],J[2]],bias:Ie,activation:dt,preluActivationWeights:ht,leakyreluAlpha:xt})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const z=S("outputShape",E,f,g),B=S("strides",E,f,g),ne=_t(E,f,g);return[b.conv2dTranspose(S("x",E,f,g),S("filter",E,f,g),z,[B[1],B[2]],ne)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const z=S("strides",E,f,g),B=_t(E,f,g),ne=S("dilations",E,f,g),J=S("dataFormat",E,f,g).toUpperCase();return[b.depthwiseConv2d(S("input",E,f,g),S("filter",E,f,g),[z[1],z[2]],B,J,[ne[1],ne[2]])]}case"Conv3D":{const z=S("strides",E,f,g),B=S("pad",E,f,g),ne=S("dataFormat",E,f,g).toUpperCase(),J=S("dilations",E,f,g);return[b.conv3d(S("x",E,f,g),S("filter",E,f,g),[z[1],z[2],z[3]],B,ne,[J[1],J[2],J[3]])]}case"AvgPool":{const z=S("strides",E,f,g),B=S("pad",E,f,g),ne=S("kernelSize",E,f,g);return[b.avgPool(S("x",E,f,g),[ne[1],ne[2]],[z[1],z[2]],B)]}case"MaxPool":{const z=S("strides",E,f,g),B=S("pad",E,f,g),ne=S("kernelSize",E,f,g);return[b.maxPool(S("x",E,f,g),[ne[1],ne[2]],[z[1],z[2]],B)]}case"MaxPoolWithArgmax":{const z=S("strides",E,f,g),B=S("pad",E,f,g),ne=S("kernelSize",E,f,g),J=S("includeBatchInIndex",E,f,g),{result:Ie,indexes:ht}=b.maxPoolWithArgmax(S("x",E,f,g),[ne[1],ne[2]],[z[1],z[2]],B,J);return[Ie,ht]}case"AvgPool3D":{const z=S("strides",E,f,g),B=S("pad",E,f,g),ne=S("kernelSize",E,f,g);return[b.avgPool3d(S("x",E,f,g),[ne[1],ne[2],ne[3]],[z[1],z[2],z[3]],B)]}case"MaxPool3D":{const z=S("strides",E,f,g),B=S("pad",E,f,g),ne=S("kernelSize",E,f,g);return[b.maxPool3d(S("x",E,f,g),[ne[1],ne[2],ne[3]],[z[1],z[2],z[3]],B)]}case"Dilation2D":{const z=S("strides",E,f,g),B=S("pad",E,f,g),ne=S("dilations",E,f,g),J=z[1],Ie=z[2],ht=ne[1],dt=ne[2];return[b.dilation2d(S("x",E,f,g),S("filter",E,f,g),[J,Ie],B,[ht,dt],"NHWC")]}default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"creation":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"Fill":{const z=S("shape",E,f,g),B=S("dtype",E,f,g),ne=S("value",E,f,g);return[b.fill(z,ne,B)]}case"LinSpace":{const z=S("start",E,f,g),B=S("stop",E,f,g),ne=S("num",E,f,g);return[b.linspace(z,B,ne)]}case"Multinomial":{const z=S("logits",E,f,g),B=S("numSamples",E,f,g),ne=S("seed",E,f,g);return[b.multinomial(z,B,ne)]}case"OneHot":{const z=S("indices",E,f,g),B=S("depth",E,f,g),ne=S("onValue",E,f,g),J=S("offValue",E,f,g),Ie=S("dtype",E,f,g);return[b.oneHot(z,B,ne,J,Ie)]}case"Ones":return[b.ones(S("shape",E,f,g),S("dtype",E,f,g))];case"OnesLike":return[b.onesLike(S("x",E,f,g))];case"RandomStandardNormal":return[b.randomStandardNormal(S("shape",E,f,g),S("dtype",E,f,g),S("seed",E,f,g))];case"RandomUniform":return[b.randomUniform(S("shape",E,f,g),S("minval",E,f,g),S("maxval",E,f,g),S("dtype",E,f,g))];case"RandomUniformInt":return[b.randomUniformInt(S("shape",E,f,g),S("minval",E,f,g),S("maxval",E,f,g),S("seed",E,f,g))];case"Range":{const z=S("start",E,f,g),B=S("stop",E,f,g),ne=S("step",E,f,g);return[b.range(z,B,ne,S("dtype",E,f,g))]}case"TruncatedNormal":{const z=S("shape",E,f,g),B=S("mean",E,f,g),ne=S("stdDev",E,f,g),J=S("seed",E,f,g);return[b.truncatedNormal(z,B,ne,S("dtype",E,f,g),J)]}case"Zeros":return[b.zeros(S("shape",E,f,g),S("dtype",E,f,g))];case"ZerosLike":return[b.zerosLike(S("x",E,f,g))];default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"dynamic":return ti(ne,J,Ie);case"evaluation":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"LowerBound":{const z=S("sortedSequence",E,f,g),B=S("values",E,f,g);return[b.lowerBound(z,B)]}case"TopKV2":{const z=S("x",E,f,g),B=S("k",E,f,g),ne=S("sorted",E,f,g),J=b.topk(z,B,ne);return[J.values,J.indices]}case"UpperBound":{const z=S("sortedSequence",E,f,g),B=S("values",E,f,g);return[b.upperBound(z,B)]}case"Unique":{const z=S("x",E,f,g),B=b.unique(z);return[B.values,B.indices]}case"UniqueV2":{const z=S("x",E,f,g),B=S("axis",E,f,g),ne=b.unique(z,B);return[ne.values,ne.indices]}default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"image":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"ResizeBilinear":{const z=S("images",E,f,g),B=S("size",E,f,g),ne=S("alignCorners",E,f,g),J=S("halfPixelCenters",E,f,g);return[b.image.resizeBilinear(z,[B[0],B[1]],ne,J)]}case"ResizeNearestNeighbor":{const z=S("images",E,f,g),B=S("size",E,f,g),ne=S("alignCorners",E,f,g),J=S("halfPixelCenters",E,f,g);return[b.image.resizeNearestNeighbor(z,[B[0],B[1]],ne,J)]}case"CropAndResize":{const z=S("image",E,f,g),B=S("boxes",E,f,g),ne=S("boxInd",E,f,g),J=S("cropSize",E,f,g),Ie=S("method",E,f,g),ht=S("extrapolationValue",E,f,g);return[b.image.cropAndResize(z,B,ne,J,Ie,ht)]}case"ImageProjectiveTransformV3":{const z=S("images",E,f,g),B=S("transforms",E,f,g),ne=S("outputShape",E,f,g),J=S("fillValue",E,f,g),Ie=S("interpolation",E,f,g),ht=S("fillMode",E,f,g);return[b.image.transform(z,B,Ie.toLowerCase(),ht.toLowerCase(),J,ne)]}default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"graph":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"Const":return f[E.name];case"PlaceholderWithDefault":const z=S("default",E,f,g);return[ze(E.name,f,g)||z];case"Placeholder":return[ze(E.name,f,g)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[At(S("x",E,f,g))];case"IdentityN":return S("x",E,f,g).map(dt=>At(dt));case"Shape":return[b.tensor1d(S("x",E,f,g).shape,"int32")];case"ShapeN":return S("x",E,f,g).map(dt=>b.tensor1d(dt.shape));case"Size":return[b.scalar(S("x",E,f,g).size,"int32")];case"Rank":return[b.scalar(S("x",E,f,g).rank,"int32")];case"NoOp":return[b.scalar(1)];case"Print":const ne=S("x",E,f,g),J=S("data",E,f,g),Ie=S("message",E,f,g),ht=S("summarize",E,f,g);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(Ie);for(let dt=0;dt<J.length;dt++)console.log(Array.prototype.slice.call(J[dt].dataSync()).slice(0,ht));return[ne];default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"logical":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"Equal":return[b.equal(S("a",E,f,g),S("b",E,f,g))];case"NotEqual":return[b.notEqual(S("a",E,f,g),S("b",E,f,g))];case"Greater":return[b.greater(S("a",E,f,g),S("b",E,f,g))];case"GreaterEqual":return[b.greaterEqual(S("a",E,f,g),S("b",E,f,g))];case"Less":return[b.less(S("a",E,f,g),S("b",E,f,g))];case"LessEqual":return[b.lessEqual(S("a",E,f,g),S("b",E,f,g))];case"LogicalAnd":return[b.logicalAnd(S("a",E,f,g),S("b",E,f,g))];case"LogicalNot":return[b.logicalNot(S("a",E,f,g))];case"LogicalOr":return[b.logicalOr(S("a",E,f,g),S("b",E,f,g))];case"Select":case"SelectV2":return[b.where(S("condition",E,f,g),S("a",E,f,g),S("b",E,f,g))];case"BitwiseAnd":return[b.bitwiseAnd(S("a",E,f,g),S("b",E,f,g))];default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"matrices":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[b.matMul(S("a",E,f,g),S("b",E,f,g),S("transposeA",E,f,g),S("transposeB",E,f,g))];case"Einsum":return[b.einsum(S("equation",E,f,g),...S("tensors",E,f,g))];case"Transpose":return[b.transpose(S("x",E,f,g),S("perm",E,f,g))];case"_FusedMatMul":const[z,B]=S("fusedOps",E,f,g),ne="biasadd"===z,J="prelu"===B,Ie=S("numArgs",E,f,g),ht=S("leakyreluAlpha",E,f,g);if(ne){if(J&&2!==Ie)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!J&&1!==Ie)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[dt,xt]=S("args",E,f,g);return[b.fused.matMul({a:S("a",E,f,g),b:S("b",E,f,g),transposeA:S("transposeA",E,f,g),transposeB:S("transposeB",E,f,g),bias:dt,activation:B,preluActivationWeights:xt,leakyreluAlpha:ht})];case"MatrixBandPart":return[b.linalg.bandPart(S("a",E,f,g),S("numLower",E,f,g),S("numUpper",E,f,g))];default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"normalization":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"EuclideanNorm":return[b.euclideanNorm(S("x",E,f,g),S("axis",E,f,g),S("keepDims",E,f,g))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[b.batchNorm(S("x",E,f,g),S("mean",E,f,g),S("variance",E,f,g),S("offset",E,f,g),S("scale",E,f,g),S("epsilon",E,f,g))];case"LRN":return[b.localResponseNormalization(S("x",E,f,g),S("radius",E,f,g),S("bias",E,f,g),S("alpha",E,f,g),S("beta",E,f,g))];case"Softmax":return[b.softmax(S("x",E,f,g))];case"LogSoftmax":return[b.logSoftmax(S("x",E,f,g))];default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"ragged":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"RaggedGather":{const{outputNestedSplits:z,outputDenseValues:B}=b.raggedGather(S("paramsNestedSplits",E,f,g),S("paramsDenseValues",E,f,g),S("indices",E,f,g),S("outputRaggedRank",E,f,g));return z.concat(B)}case"RaggedRange":{const{rtNestedSplits:z,rtDenseValues:B}=b.raggedRange(S("starts",E,f,g),S("limits",E,f,g),S("splits",E,f,g));return[z,B]}case"RaggedTensorToTensor":return[b.raggedTensorToTensor(S("shape",E,f,g),S("values",E,f,g),S("defaultValue",E,f,g),S("rowPartitionTensors",E,f,g),S("rowPartitionTypes",E,f,g))];default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"reduction":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"Max":{const J=S("axis",E,f,g),Ie=S("keepDims",E,f,g);return[b.max(S("x",E,f,g),J,Ie)]}case"Mean":{const J=S("axis",E,f,g),Ie=S("keepDims",E,f,g);return[b.mean(S("x",E,f,g),J,Ie)]}case"Min":{const J=S("axis",E,f,g),Ie=S("keepDims",E,f,g);return[b.min(S("x",E,f,g),J,Ie)]}case"Sum":{const J=S("axis",E,f,g),Ie=S("keepDims",E,f,g);return[b.sum(S("x",E,f,g),J,Ie)]}case"All":{const J=S("axis",E,f,g),Ie=S("keepDims",E,f,g);return[b.all(S("x",E,f,g),J,Ie)]}case"Any":{const J=S("axis",E,f,g),Ie=S("keepDims",E,f,g);return[b.any(S("x",E,f,g),J,Ie)]}case"ArgMax":{const J=S("axis",E,f,g);return[b.argMax(S("x",E,f,g),J)]}case"ArgMin":{const J=S("axis",E,f,g);return[b.argMin(S("x",E,f,g),J)]}case"Prod":{const J=S("axis",E,f,g),Ie=S("keepDims",E,f,g);return[b.prod(S("x",E,f,g),J,Ie)]}case"Cumprod":{const J=S("axis",E,f,g),Ie=S("exclusive",E,f,g),ht=S("reverse",E,f,g);return[b.cumprod(S("x",E,f,g),J,Ie,ht)]}case"Cumsum":{const J=S("axis",E,f,g),Ie=S("exclusive",E,f,g),ht=S("reverse",E,f,g);return[b.cumsum(S("x",E,f,g),J,Ie,ht)]}case"Bincount":const z=S("x",E,f,g),B=S("weights",E,f,g),ne=S("size",E,f,g);return[b.bincount(z,B,ne)];case"DenseBincount":{const J=S("x",E,f,g),Ie=S("weights",E,f,g),ht=S("size",E,f,g),dt=S("binaryOutput",E,f,g);return[b.denseBincount(J,Ie,ht,dt)]}default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"slice_join":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"ConcatV2":case"Concat":{const z=S("n",E,f,g),B=S("axis",E,f,g);let ne=S("tensors",E,f,g);return ne=ne.slice(0,z),[b.concat(ne,B)]}case"Gather":{const z=S("x",E,f,g),B=S("indices",E,f,g);return[b.gather(z,b.cast(B,"int32"),0)]}case"GatherV2":{const z=S("axis",E,f,g),B=S("batchDims",E,f,g),ne=S("x",E,f,g),J=S("indices",E,f,g);return[b.gather(ne,b.cast(J,"int32"),z,B)]}case"Reverse":{const z=S("dims",E,f,g),B=[];for(let J=0;J<z.length;J++)z[J]&&B.push(J);const ne=S("x",E,f,g);return[b.reverse(ne,B)]}case"ReverseV2":{const z=S("axis",E,f,g),B=S("x",E,f,g);return[b.reverse(B,z)]}case"Slice":{const z=S("begin",E,f,g),B=S("size",E,f,g);return[b.slice(S("x",E,f,g),z,B)]}case"StridedSlice":{const z=S("begin",E,f,g),B=S("end",E,f,g),ne=S("strides",E,f,g),J=S("beginMask",E,f,g),Ie=S("endMask",E,f,g),ht=S("ellipsisMask",E,f,g),dt=S("newAxisMask",E,f,g),xt=S("shrinkAxisMask",E,f,g),Tt=S("x",E,f,g);return[b.stridedSlice(Tt,z,B,ne,J,Ie,ht,dt,xt)]}case"Pack":return(0,de.tidy)(()=>{const z=S("axis",E,f,g),B=S("tensors",E,f,g),ne=B[0].shape,J=b.squeeze(B[0]).shape,Ie=B.map(ht=>{const dt=de.util.arraysEqual(ht.shape,ne);if(!dt&&!de.util.arraysEqual(b.squeeze(ht).shape,J))throw new Error("the input tensors shape does not match");return dt?ht:b.reshape(ht,ne)});return[b.stack(Ie,z)]});case"Unpack":{const z=S("axis",E,f,g),B=S("tensor",E,f,g);return b.unstack(B,z)}case"Tile":{const z=S("reps",E,f,g);return[b.tile(S("x",E,f,g),z)]}case"Split":case"SplitV":{const z=S("axis",E,f,g),B=S("numOrSizeSplits",E,f,g),ne=S("x",E,f,g);return b.split(ne,B,z)}case"ScatterNd":{const z=S("indices",E,f,g),B=S("values",E,f,g),ne=S("shape",E,f,g);return[b.scatterND(z,B,ne)]}case"GatherNd":{const z=S("x",E,f,g),B=S("indices",E,f,g);return[b.gatherND(z,B)]}case"SparseToDense":{const z=S("sparseIndices",E,f,g),B=S("outputShape",E,f,g),ne=S("sparseValues",E,f,g),J=S("defaultValue",E,f,g);return[b.sparseToDense(z,ne,B,ne.dtype===J.dtype?J:b.cast(J,ne.dtype))]}case"TensorScatterUpdate":{const z=S("indices",E,f,g),B=S("values",E,f,g),ne=S("tensor",E,f,g);return[b.tensorScatterUpdate(ne,z,B)]}default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"sparse":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"SparseFillEmptyRows":{const{outputIndices:z,outputValues:B,emptyRowIndicator:ne,reverseIndexMap:J}=b.sparse.sparseFillEmptyRows(S("indices",E,f,g),S("values",E,f,g),S("denseShape",E,f,g),S("defaultValue",E,f,g));return[z,B,ne,J]}case"SparseReshape":{const{outputIndices:z,outputShape:B}=b.sparse.sparseReshape(S("inputIndices",E,f,g),S("inputShape",E,f,g),S("newShape",E,f,g));return[z,B]}case"SparseSegmentMean":return[b.sparse.sparseSegmentMean(S("data",E,f,g),S("indices",E,f,g),S("segmentIds",E,f,g))];case"SparseSegmentSum":return[b.sparse.sparseSegmentSum(S("data",E,f,g),S("indices",E,f,g),S("segmentIds",E,f,g))];default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"spectral":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"FFT":return[b.fft(S("x",E,f,g))];case"IFFT":return[b.ifft(S("x",E,f,g))];case"RFFT":return[b.rfft(S("x",E,f,g))];case"IRFFT":return[b.irfft(S("x",E,f,g))];default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"string":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"StaticRegexReplace":return[b.string.staticRegexReplace(S("input",E,f,g),S("pattern",E,f,g),S("rewrite",E,f,g),S("replaceGlobal",E,f,g))];case"StringNGrams":{const{nGrams:z,nGramsSplits:B}=b.string.stringNGrams(S("data",E,f,g),S("dataSplits",E,f,g),S("separator",E,f,g),S("nGramWidths",E,f,g),S("leftPad",E,f,g),S("rightPad",E,f,g),S("padWidth",E,f,g),S("preserveShortSequences",E,f,g));return[z,B]}case"StringSplit":{const{indices:z,values:B,shape:ne}=b.string.stringSplit(S("input",E,f,g),S("delimiter",E,f,g),S("skipEmpty",E,f,g));return[z,B,ne]}case"StringToHashBucketFast":return[b.string.stringToHashBucketFast(S("input",E,f,g),S("numBuckets",E,f,g))];default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"transformation":return z(()=>((E,f,g,b=ct)=>{switch(E.op){case"Cast":return[b.cast(S("x",E,f,g),S("dtype",E,f,g))];case"ExpandDims":{const z=S("axis",E,f,g);return[b.expandDims(S("x",E,f,g),z)]}case"Squeeze":{const z=S("axis",E,f,g);return[b.squeeze(S("x",E,f,g),z)]}case"Reshape":return[b.reshape(S("x",E,f,g),S("shape",E,f,g))];case"EnsureShape":return[b.ensureShape(S("x",E,f,g),S("shape",E,f,g))];case"MirrorPad":return[b.mirrorPad(S("x",E,f,g),S("padding",E,f,g),S("mode",E,f,g))];case"PadV2":case"Pad":return[b.pad(S("x",E,f,g),S("padding",E,f,g),S("constantValue",E,f,g))];case"SpaceToBatchND":{const z=S("blockShape",E,f,g),B=S("paddings",E,f,g);return[b.spaceToBatchND(S("x",E,f,g),z,B)]}case"BatchToSpaceND":{const z=S("blockShape",E,f,g),B=S("crops",E,f,g);return[b.batchToSpaceND(S("x",E,f,g),z,B)]}case"DepthToSpace":{const z=S("blockSize",E,f,g),B=S("dataFormat",E,f,g).toUpperCase();return[b.depthToSpace(S("x",E,f,g),z,B)]}case"BroadcastTo":return[b.broadcastTo(S("x",E,f,g),S("shape",E,f,g))];case"BroadcastArgs":return[b.broadcastArgs(S("s0",E,f,g),S("s1",E,f,g))];default:throw TypeError(`Node type ${E.op} is not implemented`)}})(ne,J,Ie));case"hash_table":return fl(ne,J,Ie,b);case"custom":const ht=he(ne.op);if(ht&&ht.customExecutor)return ht.customExecutor(new ul(ne,J,Ie));throw TypeError(`Custom op ${ne.op} is not registered.`);default:throw TypeError(`Unknown op '${ne.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(E,f,g);return de.util.isPromise(B)?B.then(ne=>[].concat(ne)):[].concat(B)}class qe{constructor(f={},g={},b={},z={},B){this.weightMap=f,this.tensorArrayMap=g,this.tensorListMap=b,this.functionMap=z,this.parseNodeNameCache=B,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(f,g){return{id:f,frameName:g,iterationId:0}}set currentContext(f){this.contexts!==f&&(this.contexts=f,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const f=[];for(let g=0;g<this.contexts.length-1;g++){const b=this.contexts.slice(0,this.contexts.length-g);f.push(this.contextIdforContexts(b))}f.push(""),this._currentContextIds=f}contextIdforContexts(f){return f?f.map(g=>0===g.id&&0===g.iterationId?"":`${g.frameName}-${g.iterationId}`).join("/"):""}enterFrame(f){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,f)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const f=Object.assign({},this.contexts[this.contexts.length-1]);f.iterationId+=1,f.id=this.lastId,this.contexts.splice(-1,1,f),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(f){return this.weightMap[f]}addTensorArray(f){this.tensorArrayMap[f.id]=f}getTensorArray(f){return this.tensorArrayMap[f]}addTensorList(f){this.tensorListMap[f.id]=f}getTensorList(f){return this.tensorListMap[f]}dispose(f){for(const g in this.tensorArrayMap)this.tensorArrayMap[g].clearAndClose(f);for(const g in this.tensorListMap)this.tensorListMap[g].clearAndClose(f)}}function oi(E,f,g,b){const z=new Set,B=[];let ne=null,J=null;const Ie=new Set,ht=new Set(Object.keys(E).map(Tt=>ke(Tt)[0]));b=b||[];const dt=new Set(b.map(Tt=>ke(Tt.name)[0])),xt=[...f];for(;xt.length>0;){const Tt=xt.pop();if((Vs(Tt)||Ra(Tt)||gn(Tt))&&null==ne&&(ne=Tt,J=ne.children.map(Gt=>Gt.name).filter(Gt=>z.has(Gt))),z.add(Tt.name),null==g[Tt.name]&&!ht.has(Tt.name)&&!dt.has(Tt.name)){if(0===Tt.inputs.length){B.push(Tt.name);continue}Tt.inputs.forEach(Gt=>{Ie.has(Gt.name)||(Ie.add(Gt.name),xt.push(Gt))})}}return{inputs:E,outputs:f,usedNodes:z,missingInputs:B,dynamicNode:ne,syncInputs:J}}class Ti extends Error{constructor(f){super(`NodesExecutionOrderError: ${f}`)}}const Vo=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),xr=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),ec=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Vs(E){return Vo.has(E.op)}function Ra(E){return xr.has(E.op)}function gn(E){return ec.has(E.op)}class ai{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(f){const g=Object.keys(f).map(b=>f[b].map(z=>z.id));this._weightIds=[].concat(...g),this._weightMap=f}set resourceManager(f){this._resourceManager=f}get inputs(){return this._inputs.map(f=>({name:f.name,shape:f.attrParams.shape?f.attrParams.shape.value:void 0,dtype:f.attrParams.dtype?f.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(f=>({name:f.name,shape:f.attrParams.shape?f.attrParams.shape.value:void 0,dtype:f.attrParams.dtype?f.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(f=>f.signatureKey||f.name)}get outputNodes(){return this._outputs.map(f=>{const g=f.signatureKey||f.name;return f.defaultOutput?`${g}:${f.defaultOutput}`:g})}get functions(){return Object.keys(this._functions).reduce((f,g)=>(f[g]=this._functions[g].signature,f),{})}constructor(f,g){this.graph=f,this.parent=g,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=f.outputs,this._inputs=f.inputs,this._initNodes=f.initNodes,this._signature=f.signature,this._functions=f.functions,null!=f.functions&&Object.keys(f.functions).forEach(b=>{this._functionExecutorMap[b]=new ai(f.functions[b],this)})}getCompilationKey(f,g){const b=f.map(B=>B.name).sort(),z=g.map(B=>B.name).sort();return b.join(this.SEPARATOR)+"--"+z.join(this.SEPARATOR)}compile(f,g){const b=oi(f,g,this.weightMap,this._initNodes),{missingInputs:z,dynamicNode:B,syncInputs:ne}=b;if(null!=B)throw new Error(`This execution contains the node '${B.name}', which has the dynamic op '${B.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${ne}]`);if(z.length>0){const ht=g.map(xt=>xt.name),dt=Object.keys(f);throw new Error(`Cannot compute the outputs [${ht}] from the provided inputs [${dt}]. Missing the following inputs: [${z}]`)}const J=function un(E,f){const{usedNodes:g,inputs:b}=f,ne=$t=>g.has("string"==typeof $t?$t:$t.name);function J($t){return[...new Map($t.map(pn=>[pn.name,pn])).values()]}const Ie=J([...Object.keys(b).map($t=>ke($t)[0]).map($t=>E.nodes[$t]),...E.weights,...E.initNodes||[]]).filter(ne),ht=J([...Ie,...Object.values(E.nodes)]).filter(ne),dt=new Map(ht.map($t=>[$t.name,$t])),xt={};for(const $t of ht){xt[$t.name]=xt[$t.name]||0;for(const pn of $t.children)ne(pn)||(xt[pn.name]=Number.POSITIVE_INFINITY),xt[pn.name]=(xt[pn.name]||0)+1}const Tt=Object.entries(xt).filter(([,$t])=>0===$t).map(([$t])=>$t),Gt=[...Tt];for(;Tt.length>0;){const $t=Tt.pop(),pn=dt.get($t);for(const Vn of pn.children.filter(ne))0==--xt[Vn.name]&&(Gt.push(Vn.name),Tt.push(Vn.name))}const Dt=function Bn(E,f){const g=new Map(E.map(ne=>[ne.name,ne])),b=f.map(ne=>ne.name),z=new Set(b);for(;b.length>0;){const ne=b.pop(),J=g.get(ne);for(const Ie of J.children)!g.has(Ie.name)||z.has(Ie.name)||(z.add(Ie.name),b.push(Ie.name))}return E.filter(ne=>z.has(ne.name))}(Gt.map($t=>dt.get($t)),Ie);return function Jl(E,f){const g=new Map(E.map((J,Ie)=>[J.name,Ie])),b=new Set(f.map(J=>J.name)),z=J=>b.has("string"==typeof J?J:J.name),B=new Set(E.map(J=>J.name)),ne=J=>B.has("string"==typeof J?J:J.name);for(const J of E){for(const Ie of J.children.filter(ne)){if(!g.has(Ie.name))throw new Ti(`Child ${Ie.name} of node ${J.name} is unreachable.`);if(g.get(J.name)>g.get(Ie.name))throw new Ti(`Node ${J.name} is scheduled to run after its child ${Ie.name}.`)}if(!z(J))for(const Ie of J.inputs){if(!g.has(Ie.name))throw new Ti(`Input ${Ie.name} of node ${J.name} is unreachable.`);if(g.get(Ie.name)>g.get(J.name))throw new Ti(`Node ${J.name} is scheduled to run before its input ${Ie.name}.`)}}}(Dt,Ie),Dt}(this.graph,b),Ie=function ii(E){const f=new Map(E.map((J,Ie)=>[J.name,Ie])),g=Number.MAX_SAFE_INTEGER,b=E.map((J,Ie)=>Vs(J)?g:Ie),z=J=>b[f.get(J.name)]??-1,B=E.map((J,Ie)=>J.children.map(z).reduce((ht,dt)=>Math.max(ht,dt),b[Ie])),ne=new Map;for(let J=0;J<E.length;++J){const Ie=B[J];if(Ie===g)continue;const ht=E[J],dt=E[Ie];ne.has(dt.name)||ne.set(dt.name,[]),ne.get(dt.name).push(ht)}return ne}(J);return{orderedNodes:J,nodeLiveUntilMap:Ie}}cloneAndKeepTensor(f){if(null==f)return null;const g=f.clone();return(0,de.keep)(g),g}cloneTensorList(f){return f?f.map(b=>this.cloneAndKeepTensor(b)):null}cloneTensorMap(f){return Object.fromEntries(Object.entries(f).map(([g,b])=>[g,this.cloneTensorList(b)]))}execute(f,g){this.disposeIntermediateTensors(),f=this.mapInputs(f);const b=Object.keys(f).sort();this.checkInputs(f),this.checkInputShapeAndType(f),g=this.mapOutputs(g),this.checkOutputs(g);const z=b.map(Tt=>this.graph.nodes[ke(Tt)[0]]),B=g.map(Tt=>ke(Tt)[0]),ne=new Set(B);let J=B.map(Tt=>this.graph.nodes[Tt]);0===J.length&&(J=this._outputs);const Ie=this.getCompilationKey(z,J);let ht=this.compiledMap.get(Ie);null==ht&&(ht=this.compile(f,J),this.compiledMap.set(Ie,ht));try{this.keepIntermediateTensors=(0,de.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(Tt){this.keepIntermediateTensors=!1,console.warn(Tt.message)}const dt={},xt={};return(0,de.tidy)(()=>{const Tt=new qe(this.weightMap,dt,xt,this.functionExecutorMap,this.parseNodeNameCache),Gt=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(f).forEach(pn=>{const[Vn,Us]=ke(pn,Tt),Is=[];Is[Us]=f[pn],Gt[Vn]=Is,this.keepIntermediateTensors&&(this.clonedTensorsMap[Vn]=this.cloneTensorList(Is))});const ln=this.getFrozenTensorIds(Gt),{orderedNodes:Dt,nodeLiveUntilMap:$t}=ht;for(const pn of Dt){if(Gt[pn.name])continue;const Vn=si(pn,Gt,Tt,this._resourceManager);if(de.util.isPromise(Vn))throw new Error(`The execution of the op '${pn.op}' returned a promise. Please use model.executeAsync() instead.`);Gt[pn.name]=Vn,this.keepIntermediateTensors&&(this.clonedTensorsMap[pn.name]=this.cloneTensorList(Vn)),this.checkTensorForDisposalWithNodeLiveUntilInfo(pn,Gt,Tt,ln,ne,$t.get(pn.name))}return null==this.parent&&Tt.dispose(ln),g.map(pn=>ze(pn,Gt,Tt))})}getFrozenTensorIds(f){const g=[].concat.apply([],Object.keys(f).map(b=>f[b]).map(b=>b.map(z=>z.id)));return new Set(g)}checkTensorForDisposal(f,g,b,z,B,ne,J){if(!Vs(g)&&!ne.has(f)){for(const Ie of b[f])null!=Ie&&(J[Ie.id]=(J[Ie.id]||0)+g.children.length);for(const Ie of g.inputs){if(Vs(Ie))continue;const ht=ye(Ie.name,b,z);if(null!=ht)for(const dt of ht){if(!dt||dt.kept||B.has(dt.id))continue;const xt=J[dt.id];1===xt?(dt.dispose(),delete J[dt.id]):null!=xt&&J[dt.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(f,g,b,z,B,ne){function J(Ie){return Vs(Ie)||B.has(Ie.name)}if(!Vs(f)&&null!=ne)for(const Ie of ne){if(J(Ie))continue;const ht=ye(Ie.name,g,b);for(const dt of ht)!dt||dt.kept||z.has(dt.id)||dt.dispose()}}executeAsync(f,g){var b=this;return(0,Be.Z)(function*(){return b._executeAsync(f,g)})()}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(f=>{for(const g of f)g&&!g.isDisposed&&g.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(f,g,b=!1,z={},B={}){var ne=this;return(0,Be.Z)(function*(){ne.disposeIntermediateTensors(),b||(f=ne.mapInputs(f),ne.checkInputs(f),ne.checkInputShapeAndType(f),g=ne.mapOutputs(g),ne.checkOutputs(g));try{ne.keepIntermediateTensors=(0,de.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(Gt){ne.keepIntermediateTensors=!1,console.warn(Gt.message)}const J=new qe(ne.weightMap,z,B,ne.functionExecutorMap,ne.parseNodeNameCache);ne.keepIntermediateTensors&&(ne.clonedTensorsMap=ne.cloneTensorMap(ne.weightMap));const Ie=yield ne.executeWithControlFlow(f,J,g,b),ht=g.map(Gt=>ze(Gt,Ie,J)),dt=ht.map(Gt=>Gt.id),xt=Object.keys(f).map(Gt=>f[Gt].id),Tt=new Set([...dt,...xt,...ne.weightIds]);return Object.values(Ie).forEach(Gt=>{Gt.forEach(ln=>{ln&&!ln.isDisposed&&!Tt.has(ln.id)&&ln.dispose()})}),null==ne.parent&&J.dispose(Tt),ht})()}executeFunctionAsync(f,g,b){var z=this;return(0,Be.Z)(function*(){const B=f.reduce((ne,J,Ie)=>(ne[z.inputs[Ie].name]=J,ne),{});return z._executeAsync(B,z.outputNodes,!0,g,b)})()}executeWithControlFlow(f,g,b,z){var B=this;return(0,Be.Z)(function*(){const ne=Object.keys(f),J=ne.map(be=>B.graph.nodes[ke(be)[0]]),Ie=b.map(be=>ke(be)[0]),ht=new Set(Ie);let dt=Ie.map(be=>B.graph.nodes[be]);0===dt.length&&(dt=B._outputs);const{usedNodes:xt,missingInputs:Tt,dynamicNode:Gt,syncInputs:ln}=oi(f,dt,B.weightMap,B._initNodes),Dt=[...J,...B.graph.weights,...B._initNodes||[]].map(be=>({node:be,contexts:g.currentContext})),$t=Object.assign({},B.weightMap);Object.keys(f).forEach(be=>{const[ms,Oa]=ke(be),Co=[];Co[Oa]=f[be],$t[ms]=Co});const pn={},Vn=B.getFrozenTensorIds($t),Us={};for(;Dt.length>0;){const be=B.processStack(J,Dt,g,$t,Us,Vn,ht,pn,xt);yield Promise.all(be)}null==Gt&&!z&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const Is=dt.filter(be=>!Vs(be)&&!ze(be.name,$t,g)).map(be=>be.name);if(Is.length>0){let be="";throw null!=Gt&&(be=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${ln}]`),new Error(`Cannot compute the outputs [${Is}] from the provided inputs [${ne}]. Consider providing the following inputs: [${Tt}]. ${be}`)}return $t})()}processStack(f,g,b,z,B,ne,J,Ie,ht){const dt=[];for(;g.length>0;){const xt=g.pop();b.currentContext=xt.contexts;let Tt="";if("Enter"===xt.node.op&&S("isConstant",xt.node,z,b)&&([Tt]=ve(xt.node.name,b)),null==z[xt.node.name]){const Gt=si(xt.node,z,b,this._resourceManager);Tt||([Tt]=ve(xt.node.name,b));const ln=b.currentContext;de.util.isPromise(Gt)?dt.push(Gt.then(Dt=>(z[Tt]=Dt,this.keepIntermediateTensors&&(this.clonedTensorsMap[Tt]=this.cloneTensorList(Dt)),b.currentContext=ln,this.checkTensorForDisposal(Tt,xt.node,z,b,ne,J,Ie),this.processChildNodes(xt.node,g,b,z,B,ht),Dt))):(z[Tt]=Gt,this.keepIntermediateTensors&&(this.clonedTensorsMap[Tt]=this.cloneTensorList(Gt)),this.checkTensorForDisposal(Tt,xt.node,z,b,ne,J,Ie),this.processChildNodes(xt.node,g,b,z,B,ht))}else this.processChildNodes(xt.node,g,b,z,B,ht)}return dt}processChildNodes(f,g,b,z,B,ne){f.children.forEach(J=>{const[Ie]=ve(J.name,b);B[Ie]||!ne.has(J.name)||("Merge"===J.op?J.inputNames.some(ht=>!!ze(ht,z,b))&&(B[Ie]=!0,g.push({contexts:b.currentContext,node:J})):J.inputNames.every(ht=>!!ze(ht,z,b))&&(B[Ie]=!0,g.push({contexts:b.currentContext,node:J})))})}dispose(){Object.keys(this.weightMap).forEach(f=>this.weightMap[f].forEach(g=>g.dispose()))}checkInputShapeAndType(f){Object.keys(f).forEach(g=>{const b=f[g],[z]=ke(g),B=this.graph.nodes[z];if(B.attrParams.shape&&B.attrParams.shape.value){const ne=B.attrParams.shape.value,J=ne.length===b.shape.length&&b.shape.every((Ie,ht)=>-1===ne[ht]||ne[ht]===Ie);de.util.assert(J,()=>`The shape of dict['${B.name}'] provided in model.execute(dict) must be [${ne}], but was [${b.shape}]`)}B.attrParams.dtype&&B.attrParams.dtype.value&&de.util.assert(b.dtype===B.attrParams.dtype.value,()=>`The dtype of dict['${B.name}'] provided in model.execute(dict) must be ${B.attrParams.dtype.value}, but was ${b.dtype}`)})}mapInputs(f){var g,b;const z={};for(const B in f){const ne=null===(b=null===(g=this._signature)||void 0===g?void 0:g.inputs)||void 0===b?void 0:b[B];null!=ne?z[ne.name]=f[B]:z[B]=f[B]}return z}checkInputs(f){const g=Object.keys(f).filter(b=>{const[z]=ke(b);return null==this.graph.nodes[z]});if(g.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${g}] that are not part of graph`)}mapOutputs(f){return f.map(g=>{var b,z;const B=null===(z=null===(b=this._signature)||void 0===b?void 0:b.outputs)||void 0===z?void 0:z[g];return null!=B?B.name:g},{})}checkOutputs(f){f.forEach(g=>{const[b]=ke(g);if(!this.graph.nodes[b])throw new Error(`The output '${g}' is not found in the graph`)})}}class ea{constructor(f={},g={}){this.hashTableNameToHandle=f,this.hashTableMap=g}addHashTable(f,g){this.hashTableNameToHandle[f]=g.handle,this.hashTableMap[g.id]=g}getHashTableHandleByName(f){return this.hashTableNameToHandle[f]}getHashTableById(f){return this.hashTableMap[f]}dispose(){for(const f in this.hashTableMap)this.hashTableMap[f].clearAndClose(),delete this.hashTableMap[f];for(const f in this.hashTableNameToHandle)this.hashTableNameToHandle[f].dispose(),delete this.hashTableNameToHandle[f]}}const Kn="?tfjs-format=file",ml="model.json";class Uo{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(f,g={},b=de.io){this.modelUrl=f,this.loadOptions=g,this.version="n/a",this.io=b,null==g&&(this.loadOptions={}),this.resourceManager=new ea}findIOHandler(){const f=this.modelUrl;if(null!=f.load)this.handler=f;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(f,this.loadOptions);else{const g=this.io.getLoadHandlers(f,this.loadOptions);if(0===g.length)g.push(this.io.browserHTTPRequest(f,this.loadOptions));else if(g.length>1)throw new Error(`Found more than one (${g.length}) load handlers for URL '${[f]}'`);this.handler=g[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const f=this.handler.load();return de.util.isPromise(f)?f.then(g=>this.loadSync(g)):this.loadSync(f)}loadSync(f){this.artifacts=f;const g=this.artifacts.modelTopology;let b=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const B=this.artifacts.userDefinedMetadata;null!=B.signature&&(b=B.signature),null!=B.structuredOutputKeys&&(this.structuredOutputKeys=B.structuredOutputKeys)}this.signature=b,this.version=`${g.versions.producer}.${g.versions.minConsumer}`;const z=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new ai(Zo.Instance.transformGraph(g,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(z),this.executor.resourceManager=this.resourceManager,null!=f.modelInitializer&&null!=f.modelInitializer.node){const B=Zo.Instance.transformGraph(f.modelInitializer);this.initializer=new ai(B),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=f.initializerSignature}return!0}save(f,g){var b=this;return(0,Be.Z)(function*(){if("string"==typeof f){const z=b.io.getSaveHandlers(f);if(0===z.length)throw new Error(`Cannot find any save handlers for URL '${f}'`);if(z.length>1)throw new Error(`Found more than one (${z.length}) save handlers for URL '${f}'`);f=z[0]}if(null==f.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return f.save(b.artifacts)})()}addStructuredOutputNames(f){if(this.structuredOutputKeys){const b={};return(f instanceof de.Tensor?[f]:f).forEach((z,B)=>b[this.structuredOutputKeys[B]]=z),b}return f}predict(f,g){const b=this.execute(f,this.outputNodes);return this.addStructuredOutputNames(b)}predictAsync(f,g){var b=this;return(0,Be.Z)(function*(){const z=yield b.executeAsync(f,b.outputNodes);return b.addStructuredOutputNames(z)})()}normalizeInputs(f){var g;if(!(f instanceof de.Tensor||Array.isArray(f))){const B=null===(g=this.signature)||void 0===g?void 0:g.inputs;if(null!=B)for(const ne in B){const J=B[ne];null!=J.resourceId&&(f[ne]=this.resourceIdToCapturedInput[J.resourceId])}return f}f=Array.isArray(f)?f:[f];const b=Object.keys(this.resourceIdToCapturedInput).length;if(f.length+b!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-b} non-resource placeholders, while there are ${f.length} input tensors provided.`);let z=0;return this.inputNodes.reduce((B,ne)=>{var J,Ie,ht;const dt=null===(ht=null===(Ie=null===(J=this.signature)||void 0===J?void 0:J.inputs)||void 0===Ie?void 0:Ie[ne])||void 0===ht?void 0:ht.resourceId;return B[ne]=null!=dt?this.resourceIdToCapturedInput[dt]:f[z++],B},{})}normalizeOutputs(f){return f=f||this.outputNodes,Array.isArray(f)?f:[f]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var f=this;return(0,Be.Z)(function*(){return null==f.initializer?[]:f.initializer.executeAsync({},null==f.initializerSignature?[]:Object.keys(f.initializerSignature.outputs))})()}setResourceIdToCapturedInput(f){if(this.resourceIdToCapturedInput={},this.initializerSignature){const g=this.initializerSignature.outputs,b=Object.keys(g);for(let z=0;z<b.length;z++)this.resourceIdToCapturedInput[g[b[z]].resourceId]=f[z]}}execute(f,g){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),f=this.normalizeInputs(f),g=this.normalizeOutputs(g);const b=this.executor.execute(f,g);return b.length>1?b:b[0]}executeAsync(f,g){var b=this;return(0,Be.Z)(function*(){null==b.resourceIdToCapturedInput&&b.setResourceIdToCapturedInput(yield b.executeInitializerGraphAsync()),f=b.normalizeInputs(f),g=b.normalizeOutputs(g);const z=yield b.executor.executeAsync(f,g);return z.length>1?z:z[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(f){return Object.keys(f).reduce((g,b)=>(g[b]=[f[b]],g),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&(0,de.dispose)(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function ta(E){return li.apply(this,arguments)}function li(){return(li=(0,Be.Z)(function*(E,f={},g=de.io){if(null==E)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==f&&(f={}),f.fromTFHub&&"string"==typeof E&&(E=function ts(E){return E.endsWith("/")||(E+="/"),`${E}${ml}${Kn}`}(E));const b=new Uo(E,f,g);return yield b.load(),b})).apply(this,arguments)}function gl(E){if(null==E)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let f;if(E instanceof Array){const[b,z]=E;if(!b)throw new Error("modelJSON must be the first element of the array");if(!(z&&z instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in b))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in b))throw new Error("Model JSON is missing 'weightsManifest'");const B=de.io.getWeightSpecs(b.weightsManifest),ne=de.io.getModelArtifactsForJSONSync(b,B,z);f=de.io.fromMemorySync(ne)}else if("load"in E)f=E;else{if(!("modelTopology"in E&&"weightSpecs"in E&&"weightData"in E))throw new Error("Unknown model format");f=de.io.fromMemorySync(E)}const g=new Uo(f);return g.load(),g}const En="4.5.0"},7872:(mt,Le,O)=>{"use strict";O.d(Le,{JL:()=>G,Zu:()=>q});class G{constructor(pe,ce){this.backend=pe,this.dataMover=ce,this.data=new WeakMap,this.dataIdsCount=0}get(pe){return this.data.has(pe)||this.dataMover.moveData(this.backend,pe),this.data.get(pe)}set(pe,ce){this.dataIdsCount++,this.data.set(pe,ce)}has(pe){return this.data.has(pe)}delete(pe){return this.dataIdsCount--,this.data.delete(pe)}numDataIds(){return this.dataIdsCount}}class q{refCount(pe){return P("refCount")}incRef(pe){return P("incRef")}timerAvailable(){return!0}time(pe){return P("time")}read(pe){return P("read")}readSync(pe){return P("readSync")}readToGPU(pe,ce){return P("readToGPU")}numDataIds(){return P("numDataIds")}disposeData(pe,ce){return P("disposeData")}write(pe,ce,X){return P("write")}move(pe,ce,X,ie,re){return P("move")}createTensorFromGPUData(pe,ce,X){return P("createTensorFromGPUData")}memory(){return P("memory")}floatPrecision(){return P("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return P("dispose")}}function P(U){throw new Error(`'${U}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},152:(mt,Le,O)=>{"use strict";function ue(I,se,Ae){const ge=function xe(I,se,Ae){return function q(I,se,Ae){let ge=0,Fe=I.length,ut=0,ot=!1;for(;ge<Fe;){ut=ge+(Fe-ge>>>1);const Mt=Ae(se,I[ut]);Mt>0?ge=ut+1:(Fe=ut,ot=!Mt)}return ot?ge:-ge-1}(I,se,Ae||G)}(I,se,Ae);I.splice(ge<0?-(ge+1):ge,0,se)}function G(I,se){return I>se?1:I<se?-1:0}function P(I,se,Ae,ge,Fe){return ce(I,se,Ae,ge,Fe,0)}function U(I,se,Ae,ge,Fe,ut){return ce(I,se,Ae,ge,Fe,0,!1,ut,!0)}function pe(I,se,Ae,ge,Fe,ut){return ce(I,se,Ae,ge,Fe,ut,!0)}function ce(I,se,Ae,ge,Fe,ut,ot=!1,Mt=!1,ct=!1){const de=[];for(let he=0;he<se.length;he++)se[he]>Fe&&de.push({score:se[he],boxIndex:he,suppressBeginIndex:0});de.sort(re);const nt=ut>0?-.5/ut:0,Be=[],Q=[];for(;Be.length<Ae&&de.length>0;){const he=de.pop(),{score:Re,boxIndex:S,suppressBeginIndex:ze}=he;if(Re<Fe)break;let ye=!1;for(let ve=Be.length-1;ve>=ze;--ve){const Me=X(I,S,Be[ve]);if(Me>=ge){ye=!0;break}if(he.score=he.score*ie(ge,nt,Me),he.score<=Fe)break}he.suppressBeginIndex=Be.length,ye||(he.score===Re?(Be.push(S),Q.push(he.score)):he.score>Fe&&ue(de,he,re))}const ae=Be.length,F=Ae-ae;Mt&&F>0&&(Be.push(...new Array(F).fill(0)),Q.push(...new Array(F).fill(0)));const ee={selectedIndices:Be};return ot&&(ee.selectedScores=Q),ct&&(ee.validOutputs=ae),ee}function X(I,se,Ae){const ge=I.subarray(4*se,4*se+4),Fe=I.subarray(4*Ae,4*Ae+4),ut=Math.min(ge[0],ge[2]),ot=Math.min(ge[1],ge[3]),Mt=Math.max(ge[0],ge[2]),ct=Math.max(ge[1],ge[3]),de=Math.min(Fe[0],Fe[2]),nt=Math.min(Fe[1],Fe[3]),Be=Math.max(Fe[0],Fe[2]),Q=Math.max(Fe[1],Fe[3]),ae=(Mt-ut)*(ct-ot),F=(Be-de)*(Q-nt);if(ae<=0||F<=0)return 0;const ee=Math.max(ut,de),he=Math.max(ot,nt),Re=Math.min(Mt,Be),S=Math.min(ct,Q),ze=Math.max(Re-ee,0)*Math.max(S-he,0);return ze/(ae+F-ze)}function ie(I,se,Ae){const ge=Math.exp(se*Ae*Ae);return Ae<=I?ge:0}function re(I,se){return I.score-se.score||I.score===se.score&&se.boxIndex-I.boxIndex}O.d(Le,{GP:()=>P,qP:()=>U,pA:()=>pe})},2842:(mt,Le,O)=>{"use strict";O.d(Le,{Z:()=>xe});var ue=O(8621);function xe(G,q){const P=[];for(let ce=0;ce<q.length;ce++)q[ce]&&P.push(ce);const U=(0,ue.f)(G,"int32"),pe=(0,ue.f)([P.length,G.length],"int32");for(let ce=0;ce<P.length;ce++){const X=U.indexToLoc(P[ce]);pe.values.set(X,ce*G.length)}return pe.toTensor()}},3738:(mt,Le,O)=>{"use strict";O.d(Le,{BV:()=>nt,wv:()=>de});var ue=O(5861),xe=O(7872),G=O(1777),q=O(6422),P=O(1070),U=O(9464),pe=O(5686),ce=O(8813),X=O(1396);class ie{constructor(ae,F){this.backendTimer=ae,this.logger=F,null==F&&(this.logger=new I)}profileKernel(ae,F,ee){let he;const Re=()=>{he=ee()};let S;const ze=ce.now();if(this.backendTimer.timerAvailable())S=this.backendTimer.time(Re);else{Re();for(const ve of he)ve.dataSync();S=Promise.resolve({kernelMs:ce.now()-ze})}if((0,G.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let ve=0;ve<he.length;ve++){const Me=he[ve];Me.data().then(ke=>{re(ke,Me.dtype,ae)})}return{kernelName:ae,outputs:he,inputs:F,timeMs:S.then(ve=>ve.kernelMs),extraInfo:S.then(ve=>null!=ve.getExtraProfileInfo?ve.getExtraProfileInfo():"")}}logKernelProfile(ae){const{kernelName:F,outputs:ee,timeMs:he,inputs:Re,extraInfo:S}=ae;ee.forEach(ze=>{Promise.all([ze.data(),he,S]).then(ye=>{this.logger.logKernelProfile(F,ze,ye[0],ye[1],Re,ye[2])})})}}function re(Q,ae,F){if("float32"!==ae)return!1;for(let ee=0;ee<Q.length;ee++){const he=Q[ee];if(isNaN(he)||!isFinite(he))return console.warn(`Found ${he} in the result of '${F}'`),!0}return!1}class I{logKernelProfile(ae,F,ee,he,Re,S){const ze="number"==typeof he?X.oj(`${he}ms`,9):he.error,ye=X.oj(ae,25),ve=F.rank,Me=F.size,ke=X.oj(F.shape.toString(),14);let we="";for(const _t in Re){const At=Re[_t];if(null!=At){const et=At.shape||F.shape,Kt=et.length;we+=`${_t}: ${Kt}D ${Kt>0?et:""} `}}console.log(`%c${ye}\t%c${ze}\t%c${ve}D ${ke}\t%c${Me}\t%c${we}\t%c${S}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var ge=O(708),Fe=O(7904);function ut(Q){return null!=Q.kernelName}class ot{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(ae=>ae.name)))}}}dispose(){for(const ae in this.registeredVariables)this.registeredVariables[ae].dispose()}}let Mt=(()=>{class Q{constructor(F){this.ENV=F,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ot}ready(){var F=this;return(0,ue.Z)(function*(){if(null!=F.pendingBackendInit)return F.pendingBackendInit.then(()=>{});if(null!=F.backendInstance)return;const ee=F.getSortedBackends();for(let he=0;he<ee.length;he++){const Re=ee[he];if(yield F.initializeBackend(Re).success)return void(yield F.setBackend(Re))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:F,asyncInit:ee}=this.initializeBackendsAndReturnBest();if(ee)throw new Error(`The highest priority backend '${F}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(F)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(F){if(!(F in this.registry)){if(!(F in this.registryFactory))return null;{const{asyncInit:ee}=this.initializeBackend(F);if(ee)return null}}return this.registry[F]}findBackendFactory(F){return F in this.registryFactory?this.registryFactory[F].factory:null}registerBackend(F,ee,he=1){return F in this.registryFactory?(pe.Z(`${F} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[F]={factory:ee,priority:he},!0)}setBackend(F){var ee=this;return(0,ue.Z)(function*(){if(null==ee.registryFactory[F])throw new Error(`Backend name '${F}' not found in registry`);if(ee.backendName=F,null==ee.registry[F]){ee.backendInstance=null;const{success:he,asyncInit:Re}=ee.initializeBackend(F);if(!(Re?yield he:he))return!1}return ee.backendInstance=ee.registry[F],ee.setupRegisteredKernels(),ee.profiler=new ie(ee.backendInstance),!0})()}setupRegisteredKernels(){(0,U.tr)(this.backendName).forEach(ee=>{null!=ee.setupFunc&&ee.setupFunc(this.backendInstance)})}disposeRegisteredKernels(F){(0,U.tr)(F).forEach(he=>{null!=he.disposeFunc&&he.disposeFunc(this.registry[F])})}initializeBackend(F){const ee=this.registryFactory[F];if(null==ee)throw new Error(`Cannot initialize backend ${F}, no registration found.`);try{const he=ee.factory();if(!he||he instanceof xe.Zu||"function"!=typeof he.then)return this.registry[F]=he,{success:!0,asyncInit:!1};{const Re=++this.pendingBackendInitId,S=he.then(ze=>!(Re<this.pendingBackendInitId||(this.registry[F]=ze,this.pendingBackendInit=null,0))).catch(ze=>(Re<this.pendingBackendInitId||(this.pendingBackendInit=null,pe.Z(`Initialization of backend ${F} failed`),pe.Z(ze.stack||ze.message)),!1));return this.pendingBackendInit=S,{success:S,asyncInit:!0}}}catch(he){return pe.Z(`Initialization of backend ${F} failed`),pe.Z(he.stack||he.message),{success:!1,asyncInit:!1}}}removeBackend(F){if(!(F in this.registryFactory))throw new Error(`${F} backend not found in registry`);this.backendName===F&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,F in this.registry&&(this.disposeRegisteredKernels(F),this.registry[F].dispose(),delete this.registry[F]),delete this.registryFactory[F],this.backendName===F&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((F,ee)=>this.registryFactory[ee].priority-this.registryFactory[F].priority)}initializeBackendsAndReturnBest(){const F=this.getSortedBackends();for(let ee=0;ee<F.length;ee++){const he=F[ee],{success:Re,asyncInit:S}=this.initializeBackend(he);if(S||Re)return{name:he,asyncInit:S}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(F,ee){const he=this.state.tensorInfo.get(ee),Re=he.backend,S=this.readSync(ee),ze=Re.refCount(ee);Re.disposeData(ee,!0),he.backend=F,F.move(ee,S,he.shape,he.dtype,ze),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(F,ee){let Re,he=null;if(null==ee){if("function"!=typeof F)throw new Error("Please provide a function to tidy()");ee=F}else{if("string"!=typeof F&&!(F instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof ee)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");he=F}return this.scopedRun(()=>this.startScope(he),()=>this.endScope(Re),()=>(Re=ee(),Re instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),Re))}scopedRun(F,ee,he){F();try{const Re=he();return ee(),Re}catch(Re){throw ee(),Re}}nextTensorId(){return Q.nextTensorId++}nextVariableId(){return Q.nextVariableId++}clone(F){const ee=nt.runKernel(P.iJz,{x:F});return this.addTapeNode(this.state.activeScope.name,{x:F},[ee],ze=>({x:()=>nt.runKernel(P.RFZ,{x:ze},{dtype:"float32"})}),[],{}),ee}runKernel(F,ee,he){if(null==(0,U.pI)(F,this.backendName))throw new Error(`Kernel '${F}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:F,inputs:ee,attrs:he})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(F,ee,he){const Re=this.backend.numDataIds();let S=0;he.forEach(ve=>{S+="complex64"===ve.dtype?3:1});const ye=Re-ee-S-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(ye>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${ye} data ids) after running '${F}'`)}runKernelFunc(F){let ee,he=[];const Re=this.isTapeOn(),S=this.state.numBytes,ze=this.state.numTensors;let ye,ve;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const Me=ut(F)?F.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(ut(F)){const{kernelName:et,inputs:Kt,attrs:dn}=F,nn=(0,U.pI)(et,this.backendName);X.hu(null!=nn,()=>`Cannot find registered kernel '${et}' for backend '${this.backendName}'`),ye=()=>{const Vt=this.backend.numDataIds();ve=nn.kernelFunc({inputs:Kt,attrs:dn,backend:this.backend});const rn=Array.isArray(ve)?ve:[ve];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(et,Vt,rn);const gt=rn.map(cn=>null!=cn.rank?cn:this.makeTensorFromTensorInfo(cn));if(Re){const cn=this.getTensorsForGradient(et,Kt,gt);he=this.saveTensorsForBackwardMode(cn)}return gt}}else{const{forwardFunc:et}=F,Kt=dn=>{Re&&(he=dn.map(nn=>this.keep(this.clone(nn))))};ye=()=>{const dn=this.backend.numDataIds();ve=this.tidy(()=>et(this.backend,Kt));const nn=Array.isArray(ve)?ve:[ve];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(Me,dn,nn),nn}}const{inputs:ke,attrs:we}=F,_t=ut(F)?null:F.backwardsFunc;let At;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(At=this.profiler.profileKernel(Me,ke,()=>ye()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(At),ee=At.outputs):ee=ye()}),Re&&this.addTapeNode(Me,ke,ee,_t,he,we),this.state.profiling&&this.state.activeProfile.kernels.push({name:Me,bytesAdded:this.state.numBytes-S,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-ze,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(ke).map(et=>null!=ke[et]?ke[et].shape:null),outputShapes:ee.map(et=>et.shape),kernelTimeMs:At.timeMs,extraInfo:At.extraInfo}),Array.isArray(ve)?ee:ee[0]}saveTensorsForBackwardMode(F){return F.map(he=>this.keep(this.clone(he)))}getTensorsForGradient(F,ee,he){const Re=(0,U.uk)(F);if(null!=Re){const S=Re.inputsToSave||[],ze=Re.outputsToSave||[];let ye;Re.saveAllInputs?(X.hu(Array.isArray(ee),()=>"saveAllInputs is true, expected inputs to be an array."),ye=Object.keys(ee).map(Me=>ee[Me])):ye=S.map(Me=>ee[Me]);const ve=he.filter((Me,ke)=>ze[ke]);return ye.concat(ve)}return[]}makeTensor(F,ee,he,Re){if(null==F)throw new Error("Values passed to engine.makeTensor() are null");Re=Re||this.backend;let S=F;"string"===(he=he||"float32")&&X.HD(F[0])&&(S=F.map(ve=>ce.encodeString(ve)));const ze=Re.write(S,ee,he),ye=new ge.es(ee,he,ze,this.nextTensorId());if(this.trackTensor(ye,Re),"string"===he){const ve=this.state.tensorInfo.get(ze),Me=(0,X.Ub)(S);this.state.numBytes+=Me-ve.bytes,ve.bytes=Me}return ye}makeTensorFromDataId(F,ee,he,Re){return this.makeTensorFromTensorInfo({dataId:F,shape:ee,dtype:he=he||"float32"},Re)}makeTensorFromTensorInfo(F,ee){const{dataId:he,shape:Re,dtype:S}=F,ze=new ge.es(Re,S,he,this.nextTensorId());return this.trackTensor(ze,ee),ze}makeVariable(F,ee=!0,he,Re){he=he||this.nextVariableId().toString(),null!=Re&&Re!==F.dtype&&(F=F.cast(Re));const S=new ge._w(F,ee,he,this.nextTensorId());if(null!=this.state.registeredVariables[S.name])throw new Error(`Variable with name ${S.name} was already registered`);return this.state.registeredVariables[S.name]=S,this.incRef(S,this.backend),S}trackTensor(F,ee){this.state.numTensors++,"string"===F.dtype&&this.state.numStringTensors++;let he=0;"complex64"!==F.dtype&&"string"!==F.dtype&&(he=F.size*X.bT(F.dtype)),this.state.numBytes+=he,this.state.tensorInfo.has(F.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(F.dataId,{backend:ee||this.backend,dtype:F.dtype,shape:F.shape,bytes:he})),F instanceof ge._w||this.track(F)}incRef(F,ee){this.trackTensor(F,ee),this.backend.incRef(F.dataId)}removeDataId(F,ee){this.state.tensorInfo.has(F)&&this.state.tensorInfo.get(F).backend===ee&&(this.state.tensorInfo.delete(F),this.state.numDataBuffers--)}disposeTensor(F){if(!this.state.tensorInfo.has(F.dataId))return;const ee=this.state.tensorInfo.get(F.dataId);if(this.state.numTensors--,"string"===F.dtype&&(this.state.numStringTensors--,this.state.numBytes-=ee.bytes),"complex64"!==F.dtype&&"string"!==F.dtype){const he=F.size*X.bT(F.dtype);this.state.numBytes-=he}ee.backend.disposeData(F.dataId)&&this.removeDataId(F.dataId,ee.backend)}disposeVariables(){for(const F in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[F])}disposeVariable(F){this.disposeTensor(F),null!=this.state.registeredVariables[F.name]&&delete this.state.registeredVariables[F.name]}memory(){const F=this.backend.memory();return F.numTensors=this.state.numTensors,F.numDataBuffers=this.state.numDataBuffers,F.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(F.unreliable=!0,null==F.reasons&&(F.reasons=[]),F.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),F}profile(F){var ee=this;return(0,ue.Z)(function*(){ee.state.profiling=!0;const he=ee.state.numBytes,Re=ee.state.numTensors;ee.state.activeProfile.kernels=[],ee.state.activeProfile.result=yield F(),ee.state.profiling=!1,ee.state.activeProfile.peakBytes=Math.max(...ee.state.activeProfile.kernels.map(S=>S.totalBytesSnapshot)),ee.state.activeProfile.newBytes=ee.state.numBytes-he,ee.state.activeProfile.newTensors=ee.state.numTensors-Re;for(const S of ee.state.activeProfile.kernels)S.kernelTimeMs=yield S.kernelTimeMs,S.extraInfo=yield S.extraInfo;return ee.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(F,ee,he,Re,S,ze){const ye={id:this.state.nextTapeNodeId++,kernelName:F,inputs:ee,outputs:he,saved:S},ve=(0,U.uk)(F);null!=ve&&(Re=ve.gradFunc),null!=Re&&(ye.gradient=Me=>(Me=Me.map((ke,we)=>{if(null==ke){const _t=he[we],At=X.wT(_t.size,_t.dtype);return this.makeTensor(At,_t.shape,_t.dtype)}return ke}),Re(Me.length>1?Me:Me[0],S,ze))),this.state.activeTape.push(ye)}keep(F){return F.kept=!0,F}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(F){const ee={track:[],name:"unnamed scope",id:this.state.nextScopeId++};F&&(ee.name=F),this.state.scopeStack.push(ee),this.state.activeScope=ee}endScope(F){const ee=(0,Fe.getTensorsInContainer)(F),he=new Set(ee.map(S=>S.id));for(let S=0;S<this.state.activeScope.track.length;S++){const ze=this.state.activeScope.track[S];!ze.kept&&!he.has(ze.id)&&ze.dispose()}const Re=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],ee.forEach(S=>{!S.kept&&S.scopeId===Re.id&&this.track(S)})}gradients(F,ee,he,Re=!1){if(X.hu(ee.length>0,()=>"gradients() received an empty list of xs."),null!=he&&"float32"!==he.dtype)throw new Error(`dy must have 'float32' dtype, but has '${he.dtype}'`);const S=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",F));X.hu(S instanceof ge.es,()=>"The result y returned by f() must be a tensor.");const ze=function se(Q,ae,F){const ee={},he={};for(let ye=0;ye<ae.length;ye++)ee[ae[ye].id]=!0;for(let ye=0;ye<Q.length;ye++){const ve=Q[ye],Me=ve.inputs;for(const ke in Me){const we=Me[ke];let _t=!1;for(let At=0;At<ae.length;At++)if(ee[we.id]){ve.outputs.forEach(et=>ee[et.id]=!0),_t=!0,he[ve.id]=!0;break}if(_t)break}}const Re={};Re[F.id]=!0;const S={};for(let ye=Q.length-1;ye>=0;ye--){const ve=Q[ye],Me=ve.inputs;for(let ke=0;ke<ve.outputs.length;ke++)if(Re[ve.outputs[ke].id]){for(const we in Me)Re[Me[we].id]=!0,S[ve.id]=!0;break}}const ze=[];for(let ye=0;ye<Q.length;ye++){const ve=Q[ye];if(he[ve.id]&&S[ve.id]){const Me={};for(const we in ve.inputs){const _t=ve.inputs[we];ee[_t.id]&&(Me[we]=_t)}const ke=Object.assign({},ve);ke.inputs=Me,ke.outputs=ve.outputs,ze.push(ke)}}return ze}(this.state.activeTape,ee,S);if(!Re&&0===ze.length&&ee.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const ye={};ye[S.id]=he??function ct(Q){const ae=(0,X.p8)((0,X.NA)(Q),"float32");return nt.makeTensor(ae,Q,"float32")}(S.shape),function Ae(Q,ae,F,ee){for(let he=ae.length-1;he>=0;he--){const Re=ae[he],S=[];if(Re.outputs.forEach(ye=>{const ve=Q[ye.id];S.push(null!=ve?ve:null)}),null==Re.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${Re.kernelName}.`);const ze=Re.gradient(S);for(const ye in Re.inputs){if(!(ye in ze))throw new Error(`Cannot backprop through input ${ye}. Available gradients found: ${Object.keys(ze)}.`);const ve=F(()=>ze[ye]());if("float32"!==ve.dtype)throw new Error(`Error in gradient for op ${Re.kernelName}. The gradient of input ${ye} must have 'float32' dtype, but has '${ve.dtype}'`);const Me=Re.inputs[ye];if(!X.cO(ve.shape,Me.shape))throw new Error(`Error in gradient for op ${Re.kernelName}. The gradient of input '${ye}' has shape '${ve.shape}', which does not match the shape of the input '${Me.shape}'`);if(null==Q[Me.id])Q[Me.id]=ve;else{const ke=Q[Me.id];Q[Me.id]=ee(ke,ve),ke.dispose()}}}}(ye,ze,Me=>this.tidy(Me),Be);const ve=ee.map(Me=>ye[Me.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(Me=>{for(const ke of Me.saved)ke.dispose()}),this.state.activeTape=null),{value:S,grads:ve}})}customGrad(F){return X.hu(X.mf(F),()=>"The f passed in customGrad(f) must be a function."),(...ee)=>{let he;X.hu(ee.every(ye=>ye instanceof ge.es),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const Re={};return ee.forEach((ye,ve)=>{Re[ve]=ye}),this.runKernelFunc({forwardFunc:(ye,ve)=>(he=F(...ee,ve),X.hu(he.value instanceof ge.es,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),X.hu(X.mf(he.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),he.value),backwardsFunc:(ye,ve)=>{const Me=he.gradFunc(ye,ve),ke=Array.isArray(Me)?Me:[Me];X.hu(ke.length===ee.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),X.hu(ke.every(_t=>_t instanceof ge.es),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const we={};return ke.forEach((_t,At)=>{we[At]=()=>_t}),we},inputs:Re})}}readSync(F){return this.state.tensorInfo.get(F).backend.readSync(F)}read(F){return this.state.tensorInfo.get(F).backend.read(F)}readToGPU(F,ee){return this.state.tensorInfo.get(F).backend.readToGPU(F,ee)}time(F){var ee=this;return(0,ue.Z)(function*(){const he=(0,ce.now)(),Re=yield ee.backend.time(F);return Re.wallMs=(0,ce.now)()-he,Re})()}track(F){return null!=this.state.activeScope&&(F.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(F)),F}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ot;for(const F in this.registry)this.disposeRegisteredKernels(F),this.registry[F].dispose(),delete this.registry[F];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return Q.nextTensorId=0,Q.nextVariableId=0,Q})();function de(){const Q=(0,q.D)();if(null==Q._tfengine){const ae=new G.qA(Q);Q._tfengine=new Mt(ae)}return(0,G.iG)(Q._tfengine.ENV),(0,ge.Vi)(()=>Q._tfengine),Q._tfengine}const nt=de();function Be(Q,ae){return nt.runKernel(P.mm_,{a:Q,b:ae})}},1777:(mt,Le,O)=>{"use strict";O.d(Le,{OB:()=>ce,Vi:()=>X,iG:()=>ie,qA:()=>q});var ue=O(5861),xe=O(1396);const G="tfjsflags";class q{constructor(I){this.global=I,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=P,this.populateURLFlags()}setPlatform(I,se){null!=this.platform&&(ce().getBool("IS_TEST")||ce().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${I}.`)),this.platformName=I,this.platform=se}registerFlag(I,se,Ae){if(this.flagRegistry[I]={evaluationFn:se,setHook:Ae},null!=this.urlFlags[I]){const ge=this.urlFlags[I];ce().getBool("IS_TEST")||ce().getBool("PROD")||console.warn(`Setting feature override from URL ${I}: ${ge}.`),this.set(I,ge)}}getAsync(I){var se=this;return(0,ue.Z)(function*(){return I in se.flags||(se.flags[I]=yield se.evaluateFlag(I)),se.flags[I]})()}get(I){if(I in this.flags)return this.flags[I];const se=this.evaluateFlag(I);if((0,xe.tI)(se))throw new Error(`Flag ${I} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[I]=se,this.flags[I]}getNumber(I){return this.get(I)}getBool(I){return this.get(I)}getString(I){return this.get(I)}getFlags(){return this.flags}get features(){return this.flags}set(I,se){if(null==this.flagRegistry[I])throw new Error(`Cannot set flag ${I} as it has not been registered.`);this.flags[I]=se,null!=this.flagRegistry[I].setHook&&this.flagRegistry[I].setHook(se)}evaluateFlag(I){if(null==this.flagRegistry[I])throw new Error(`Cannot evaluate flag '${I}': no evaluation function found.`);return this.flagRegistry[I].evaluationFn()}setFlags(I){this.flags=Object.assign({},I)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const I=this.getQueryParams(this.global.location.search);G in I&&I[G].split(",").forEach(Ae=>{const[ge,Fe]=Ae.split(":");this.urlFlags[ge]=function pe(re,I){const se=I.toLowerCase();return"true"===se||"false"===se?"true"===se:""+ +se===se?+se:I}(0,Fe)})}}function P(re){const I={};return re.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(se,...Ae)=>(function U(re,I,se){re[decodeURIComponent(I)]=decodeURIComponent(se||"")}(I,Ae[0],Ae[1]),Ae.join("="))),I}function ce(){return X}let X=null;function ie(re){X=re}},6422:(mt,Le,O)=>{"use strict";let ue;function xe(){if(null==ue){let P;if(typeof window<"u")P=window;else if(typeof global<"u")P=global;else if(typeof process<"u")P=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");P=self}ue=P}return ue}function q(P,U){const pe=function G(){const P=xe();return null==P._tfGlobals&&(P._tfGlobals=new Map),P._tfGlobals}();if(pe.has(P))return pe.get(P);{const ce=U();return pe.set(P,ce),pe.get(P)}}O.d(Le,{D:()=>xe,R:()=>q})},9370:(mt,Le,O)=>{"use strict";O.d(Le,{B9:()=>Ae,CQ:()=>ut,Cd:()=>ot,Cn:()=>ge,G4:()=>P,MX:()=>ce,N5:()=>I,N8:()=>X,N_:()=>Mt,R:()=>U,SR:()=>ie,VY:()=>ae,XV:()=>Fe,cF:()=>pe,cj:()=>ct,jq:()=>Be,lu:()=>se,sq:()=>re,x3:()=>de,y3:()=>Q,ze:()=>nt});var ue=O(3738),xe=O(1777),G=O(708),q=O(7904);function P(){(0,xe.OB)().set("PROD",!0)}function U(){(0,xe.OB)().set("DEBUG",!0)}function pe(){(0,xe.OB)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function ce(F){(0,xe.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(F+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function X(){ue.BV.disposeVariables()}function ie(){return ue.BV}function re(){return ue.BV.memory()}function I(F){return ue.BV.profile(F)}function se(F,ee){return ue.BV.tidy(F,ee)}function Ae(F){(0,q.getTensorsInContainer)(F).forEach(he=>he.dispose())}function ge(F){return ue.BV.keep(F)}function Fe(F){return ue.BV.time(F)}function ut(F){return ue.BV.setBackend(F)}function ot(){return ue.BV.ready()}function Mt(){return ue.BV.backendName}function ct(F){ue.BV.removeBackend(F)}function de(F){return ue.BV.findBackend(F)}function nt(F){return ue.BV.findBackendFactory(F)}function Be(F,ee,he=1){return ue.BV.registerBackend(F,ee,he)}function Q(){return ue.BV.backend}function ae(F,ee){(0,xe.OB)().setPlatform(F,ee)}(0,G.FZ)(ce)},1335:(mt,Le,O)=>{"use strict";O.d(Le,{UQ:()=>P,cb:()=>ie,fN:()=>ce,h7:()=>pe,pn:()=>X,ti:()=>U});var ue=O(3738),xe=O(708),G=O(9608),q=O(1396);function P(I){return q.hu(q.mf(I),()=>"The f passed in grad(f) must be a function"),(se,Ae)=>{const ge=(0,G._1)(se,"x","tf.grad","string_or_numeric"),Fe=null!=Ae?(0,G._1)(Ae,"dy","tf.grad"):null;return ue.BV.tidy(()=>{const{value:ut,grads:ot}=ue.BV.gradients(()=>I(ge),[ge],Fe);return null!=Fe&&q.k5(ut.shape,Fe.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),re(ot),ot[0]})}}function U(I){return q.hu(q.mf(I),()=>"The f passed in grads(f) must be a function"),(se,Ae)=>{q.hu(Array.isArray(se),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const ge=(0,G.sI)(se,"args","tf.grads","string_or_numeric"),Fe=null!=Ae?(0,G._1)(Ae,"dy","tf.grads"):null;return ue.BV.tidy(()=>{const{value:ut,grads:ot}=ue.BV.gradients(()=>I(...ge),ge,Fe);return null!=Fe&&q.k5(ut.shape,Fe.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),re(ot),ot})}}function pe(I){return q.hu(q.mf(I),()=>"The f passed in valueAndGrad(f) must be a function"),(se,Ae)=>{q.hu(se instanceof xe.es,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),q.hu(null==Ae||Ae instanceof xe.es,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:ge,value:Fe}=ue.BV.gradients(()=>I(se),[se],Ae);return re(ge),{grad:ge[0],value:Fe}}}function ce(I){return q.hu(q.mf(I),()=>"The f passed in valueAndGrads(f) must be a function"),(se,Ae)=>{q.hu(Array.isArray(se)&&se.every(Fe=>Fe instanceof xe.es),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),q.hu(null==Ae||Ae instanceof xe.es,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const ge=ue.BV.gradients(()=>I(...se),se,Ae);return null!=Ae&&q.k5(ge.value.shape,Ae.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),re(ge.grads),ge}}function X(I,se){q.hu(q.mf(I),()=>"The f passed in variableGrads(f) must be a function"),q.hu(null==se||Array.isArray(se)&&se.every(de=>de instanceof xe._w),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const Ae=null!=se;if(!Ae){se=[];for(const de in ue.BV.registeredVariables)se.push(ue.BV.registeredVariables[de])}const ge=Ae?se.filter(de=>!de.trainable):null,Fe=se.length;se=se.filter(de=>de.trainable),q.hu(se.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${Fe} variables is trainable.`);const{value:ot,grads:Mt}=ue.BV.gradients(I,se,null,!0);q.hu(Mt.some(de=>null!=de),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),q.hu(0===ot.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${ot.rank} tensor`);const ct={};return se.forEach((de,nt)=>{null!=Mt[nt]&&(ct[de.name]=Mt[nt])}),ge?.forEach(de=>ct[de.name]=null),{value:ot,grads:ct}}function ie(I){return ue.BV.customGrad(I)}function re(I){if(I.filter(Ae=>null==Ae).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},3798:(mt,Le,O)=>{"use strict";O.r(Le),O.d(Le,{Abs:()=>be.SYM,Acos:()=>be.VGw,Acosh:()=>be.SpW,AdadeltaOptimizer:()=>on,AdagradOptimizer:()=>Jn,AdamOptimizer:()=>Fn,AdamaxOptimizer:()=>ri,Add:()=>be.mm_,AddN:()=>be.Xze,All:()=>be.oT6,Any:()=>be.IKK,ArgMax:()=>be.sJF,ArgMin:()=>be.aJk,Asin:()=>be.M2y,Asinh:()=>be.qw7,Atan:()=>be.jMg,Atan2:()=>be.QCc,Atanh:()=>be.Oyi,AvgPool:()=>be.JhU,AvgPool3D:()=>be._k9,AvgPool3DGrad:()=>be.IMb,AvgPoolGrad:()=>be.ROF,BatchMatMul:()=>be.XLW,BatchToSpaceND:()=>be.zws,Bincount:()=>be.zvY,BitwiseAnd:()=>be.hCO,BroadcastArgs:()=>be.eEB,BroadcastTo:()=>be.Ly9,Cast:()=>be.RFZ,Ceil:()=>be.gJX,ClipByValue:()=>be.xnO,Complex:()=>be.Zz9,ComplexAbs:()=>be.yj2,Concat:()=>be.Eh3,Conv2D:()=>be.mhS,Conv2DBackpropFilter:()=>be.wUP,Conv2DBackpropInput:()=>be.wm,Conv3D:()=>be.x12,Conv3DBackpropFilterV2:()=>be.o2y,Conv3DBackpropInputV2:()=>be.ik2,Cos:()=>be.mc4,Cosh:()=>be.TR1,CropAndResize:()=>be.VcC,Cumprod:()=>be.Byc,Cumsum:()=>be.iHb,DataStorage:()=>la.JL,DenseBincount:()=>be.QRR,DepthToSpace:()=>be.T0n,DepthwiseConv2dNative:()=>be.cie,DepthwiseConv2dNativeBackpropFilter:()=>be.sL$,DepthwiseConv2dNativeBackpropInput:()=>be.y7R,Diag:()=>be.$w,Dilation2D:()=>be.p4S,Dilation2DBackpropFilter:()=>be.Vn9,Dilation2DBackpropInput:()=>be.ekb,ENV:()=>ot.Vi,Einsum:()=>be.$g6,Elu:()=>be.SX0,EluGrad:()=>be.HEU,Environment:()=>ot.qA,Equal:()=>be.hdR,Erf:()=>be.Omj,Exp:()=>be.NEP,ExpandDims:()=>be.YFo,Expm1:()=>be.Y0y,FFT:()=>be.vwp,Fill:()=>be.deh,FlipLeftRight:()=>be.Uyb,Floor:()=>be.OR,FloorDiv:()=>be.jeX,FromPixels:()=>be.eBW,FusedBatchNorm:()=>be.sHE,FusedConv2D:()=>be._V0,FusedDepthwiseConv2D:()=>be.luS,GatherNd:()=>be.q1x,GatherV2:()=>be.qi_,Greater:()=>be.iZT,GreaterEqual:()=>be.Acj,IFFT:()=>be.Qg5,Identity:()=>be.iJz,Imag:()=>be.J_u,IsFinite:()=>be.avt,IsInf:()=>be.iWB,IsNan:()=>be.r7n,KernelBackend:()=>la.Zu,LRN:()=>be.eZ0,LRNGrad:()=>be.Hhh,LeakyRelu:()=>be.J$2,Less:()=>be.vtC,LessEqual:()=>be.CAk,LinSpace:()=>be.e7N,Log:()=>be.ZbH,Log1p:()=>be.kU,LogSoftmax:()=>be.qCd,LogicalAnd:()=>be.PYm,LogicalNot:()=>be.VfG,LogicalOr:()=>be.MZg,LogicalXor:()=>be.w6g,LowerBound:()=>be.qIC,MatrixBandPart:()=>be.J7O,Max:()=>be.YoZ,MaxPool:()=>be.mTV,MaxPool3D:()=>be.OAf,MaxPool3DGrad:()=>be.OU7,MaxPoolGrad:()=>be.OV7,MaxPoolWithArgmax:()=>be.vFR,Maximum:()=>be.BMI,Mean:()=>be.q2K,Min:()=>be.c17,Minimum:()=>be.q8u,MirrorPad:()=>be.jQs,Mod:()=>be.Vbg,MomentumOptimizer:()=>si,Multinomial:()=>be.NZg,Multiply:()=>be.wYn,Neg:()=>be.kuV,NonMaxSuppressionV3:()=>be.uv1,NonMaxSuppressionV4:()=>be.cye,NonMaxSuppressionV5:()=>be.W0H,NotEqual:()=>be.yQU,OP_SCOPE_SUFFIX:()=>De.zvA,OneHot:()=>be.we_,OnesLike:()=>be.qWM,Optimizer:()=>qn,OptimizerConstructors:()=>ad,Pack:()=>be.QiL,PadV2:()=>be.lyA,Pool:()=>be.Kgp,Pow:()=>be.pe_,Prelu:()=>be.o0g,Prod:()=>be.DlI,RMSPropOptimizer:()=>qe,RaggedGather:()=>be.dDz,RaggedRange:()=>be.CQl,RaggedTensorToTensor:()=>be.BiW,Range:()=>be.e6w,Rank:()=>vl.yw,Real:()=>be.xJR,RealDiv:()=>be.oHH,Reciprocal:()=>be.$HU,Reduction:()=>Uh.I,Relu:()=>be.qkr,Relu6:()=>be.SbG,Reshape:()=>be.HZH,ResizeBilinear:()=>be._Yw,ResizeBilinearGrad:()=>be.zbQ,ResizeNearestNeighbor:()=>be.dpD,ResizeNearestNeighborGrad:()=>be.Hmb,Reverse:()=>be.mKl,RotateWithOffset:()=>be.b9H,Round:()=>be.e07,Rsqrt:()=>be.bV0,SGDOptimizer:()=>Ma,ScatterNd:()=>be.xQA,SearchSorted:()=>be.nr8,Select:()=>be.PhF,Selu:()=>be.oFR,Sigmoid:()=>be.a5O,Sign:()=>be.i5y,Sin:()=>be.RQH,Sinh:()=>be.wYB,Slice:()=>be.p2w,Softmax:()=>be.Gcp,Softplus:()=>be.MRv,SpaceToBatchND:()=>be.TQc,SparseFillEmptyRows:()=>be.O3z,SparseReshape:()=>be.nhH,SparseSegmentMean:()=>be.w3H,SparseSegmentSum:()=>be.ZjV,SparseToDense:()=>be.D2d,SplitV:()=>be.L8s,Sqrt:()=>be.FKq,Square:()=>be.bK0,SquaredDifference:()=>be._tC,StaticRegexReplace:()=>be.e0R,Step:()=>be.h8e,StridedSlice:()=>be.jQk,StringNGrams:()=>be._JP,StringSplit:()=>be.s1s,StringToHashBucketFast:()=>be.XkS,Sub:()=>be.Tr8,Sum:()=>be.GBy,Tan:()=>be.sEM,Tanh:()=>be.MIZ,Tensor:()=>$s.es,TensorBuffer:()=>$s.YD,TensorScatterUpdate:()=>be.SIB,Tile:()=>be.n9L,TopK:()=>be.cWu,Transform:()=>be.wx7,Transpose:()=>be.G3Y,Unique:()=>be.kpP,Unpack:()=>be.ToN,UnsortedSegmentSum:()=>be.Qvg,UpperBound:()=>be.XDQ,Variable:()=>$s._w,ZerosLike:()=>be.RuY,_FusedMatMul:()=>be.usg,abs:()=>De.WnP,acos:()=>De.Khb,acosh:()=>De.__u,add:()=>De.IHx,addN:()=>De.QBD,all:()=>De.$6P,any:()=>De.YjB,argMax:()=>De.NqF,argMin:()=>De.vHJ,asin:()=>De.ZRM,asinh:()=>De.VfV,atan:()=>De.z4N,atan2:()=>De.fvJ,atanh:()=>De.C80,avgPool:()=>De.wS1,avgPool3d:()=>De.uR5,backend:()=>Yt.y3,backend_util:()=>ie,basicLSTMCell:()=>De.zEQ,batchNorm:()=>De.tgs,batchNorm2d:()=>De.Dxk,batchNorm3d:()=>De.JY5,batchNorm4d:()=>De.p3b,batchToSpaceND:()=>De.E4h,bincount:()=>De.yE8,bitwiseAnd:()=>De.ycw,booleanMaskAsync:()=>De.anm,broadcastArgs:()=>De.XsQ,broadcastTo:()=>De.UFq,broadcast_util:()=>Is,browser:()=>P,buffer:()=>De.f3b,cast:()=>De.pju,ceil:()=>De.mDi,clipByValue:()=>De.iUl,clone:()=>De.d9v,complex:()=>De.PYB,concat:()=>De.zoF,concat1d:()=>De.gME,concat2d:()=>De.Izb,concat3d:()=>De.MNy,concat4d:()=>De.ZaL,conv1d:()=>De.PAt,conv2d:()=>De.Tek,conv2dTranspose:()=>De.bc,conv3d:()=>De.pdZ,conv3dTranspose:()=>De.$QV,copyRegisteredKernels:()=>ms.T3,cos:()=>De.mCk,cosh:()=>De.f9Y,cosineWindow:()=>De.mew,cumprod:()=>De.$Gn,cumsum:()=>De.zbp,customGrad:()=>Bs.cb,denseBincount:()=>De.ppE,deprecationWarn:()=>Yt.MX,depthToSpace:()=>De.nTT,depthwiseConv2d:()=>De.B10,device_util:()=>ue,diag:()=>De.Ka3,dilation2d:()=>De.WmZ,disableDeprecationWarnings:()=>Yt.cF,dispose:()=>Yt.B9,disposeVariables:()=>Yt.N8,div:()=>De.hiC,divNoNan:()=>De.NTj,dot:()=>De.AKD,dropout:()=>De.rvX,einsum:()=>De.WYO,elu:()=>De.pyx,enableDebugMode:()=>Yt.R,enableProdMode:()=>Yt.G4,enclosingPowerOfTwo:()=>De.GRh,engine:()=>Yt.SR,ensureShape:()=>De.EDe,env:()=>ot.OB,equal:()=>De.DgJ,erf:()=>De.qNN,euclideanNorm:()=>De.d2q,exp:()=>De.Qqt,expandDims:()=>De.dt4,expm1:()=>De.t$B,eye:()=>De.iyy,fft:()=>De.kp_,fill:()=>De.hlL,findBackend:()=>Yt.x3,findBackendFactory:()=>Yt.ze,floor:()=>De.GWj,floorDiv:()=>De.qPi,fused:()=>De.imm,gather:()=>De.Iqj,gatherND:()=>De.dbB,gather_util:()=>U,getBackend:()=>Yt.N_,getGradient:()=>ms.uk,getKernel:()=>ms.pI,getKernelsForBackend:()=>ms.tr,grad:()=>Bs.UQ,grads:()=>Bs.ti,greater:()=>De.pjt,greaterEqual:()=>De.brS,ifft:()=>De.Sxn,imag:()=>De.asL,image:()=>De.BHj,inTopKAsync:()=>De.V3u,io:()=>G,irfft:()=>De.wx0,isFinite:()=>De.xVT,isInf:()=>De.UWc,isNaN:()=>De.i2d,keep:()=>Yt.Cn,kernel_impls:()=>re,leakyRelu:()=>De.hi7,less:()=>De.d9m,lessEqual:()=>De.zN1,linalg:()=>De.$r2,linspace:()=>De.SX3,localResponseNormalization:()=>De.G9k,log:()=>De.cM7,log1p:()=>De.Krr,logSigmoid:()=>De.e_t,logSoftmax:()=>De.CmS,logSumExp:()=>De.l_t,logicalAnd:()=>De.HvI,logicalNot:()=>De.hJK,logicalOr:()=>De.K5V,logicalXor:()=>De.egP,losses:()=>De.MB5,lowerBound:()=>De.eab,matMul:()=>De.OI3,math:()=>q,max:()=>De.Fp7,maxPool:()=>De._sB,maxPool3d:()=>De.YQQ,maxPoolWithArgmax:()=>De.Ip$,maximum:()=>De.gWQ,mean:()=>De.J69,memory:()=>Yt.sq,meshgrid:()=>De.ry_,min:()=>De.VV$,minimum:()=>De.LTh,mirrorPad:()=>De.VdP,mod:()=>De.wQq,moments:()=>De.Gi7,movingAverage:()=>De.p_,mul:()=>De.dC7,multiRNNCell:()=>De.rq4,multinomial:()=>De.SJ_,neg:()=>De.W76,nextFrame:()=>Hh,norm:()=>De.KOy,notEqual:()=>De.Quu,oneHot:()=>De.lfX,ones:()=>De.iUs,onesLike:()=>De.JpU,op:()=>De.op,outerProduct:()=>De.N2O,pad:()=>De.vku,pad1d:()=>De.pNR,pad2d:()=>De.koy,pad3d:()=>De.t1L,pad4d:()=>De.lGY,pool:()=>De.d_R,pow:()=>De.sQ3,prelu:()=>De.AL3,print:()=>De.S0v,prod:()=>De.WVs,profile:()=>Yt.N5,raggedGather:()=>De.$gW,raggedRange:()=>De.VT$,raggedTensorToTensor:()=>De.N89,rand:()=>De.TN_,randomGamma:()=>De.wzB,randomNormal:()=>De.nGf,randomStandardNormal:()=>De.ruB,randomUniform:()=>De.LGj,randomUniformInt:()=>De.pe5,range:()=>De.w6H,ready:()=>Yt.Cd,real:()=>De.kwC,reciprocal:()=>De.M25,registerBackend:()=>Yt.jq,registerGradient:()=>ms.Li,registerKernel:()=>ms.wC,relu:()=>De.UYe,relu6:()=>De.btT,removeBackend:()=>Yt.cj,reshape:()=>De.XLQ,reverse:()=>De.GYS,reverse1d:()=>De.SDf,reverse2d:()=>De.diP,reverse3d:()=>De.sx7,reverse4d:()=>De.mG2,rfft:()=>De.QEs,round:()=>De.NMM,rsqrt:()=>De.bp0,scalar:()=>De.iD$,scatterND:()=>De.snQ,scatter_util:()=>Ke,searchSorted:()=>De.zcT,selu:()=>De.U8D,separableConv2d:()=>De.U_I,serialization:()=>xe,setBackend:()=>Yt.CQ,setPlatform:()=>Yt.VY,setdiff1dAsync:()=>De.ODp,sigmoid:()=>De.XD2,sign:()=>De.Xxe,signal:()=>De.tdS,sin:()=>De.O$l,sinh:()=>De.R_K,slice:()=>De.tPi,slice1d:()=>De.jZU,slice2d:()=>De.SmN,slice3d:()=>De.CnO,slice4d:()=>De.p0P,slice_util:()=>pe,softmax:()=>De.XAC,softplus:()=>De.Wvh,spaceToBatchND:()=>De.fBT,sparse:()=>De.rVs,sparseToDense:()=>De.ers,spectral:()=>De.uN7,split:()=>De.Vl2,sqrt:()=>De._b3,square:()=>De.h62,squaredDifference:()=>De.$i,squeeze:()=>De.L9e,stack:()=>De.knu,step:()=>De.Nbs,stridedSlice:()=>De.NXj,string:()=>De.Z_8,sub:()=>De.luU,sum:()=>De.Smz,sumOutType:()=>vl.z4,tan:()=>De.ORZ,tanh:()=>De.AEp,tensor:()=>De.XeE,tensor1d:()=>De.RRF,tensor2d:()=>De.odF,tensor3d:()=>De.wOQ,tensor4d:()=>De.yXz,tensor5d:()=>De.Bfx,tensor6d:()=>De.xZs,tensorScatterUpdate:()=>De.Pg0,tensor_util:()=>sc,test_util:()=>ce,tidy:()=>Yt.lu,tile:()=>De.Gg6,time:()=>Yt.XV,topk:()=>De.hg7,train:()=>zh,transpose:()=>De.p4s,truncatedNormal:()=>De.Xu6,unique:()=>De.Two,unregisterGradient:()=>ms.bt,unregisterKernel:()=>ms.nE,unsortedSegmentSum:()=>De.pUJ,unstack:()=>De.HHK,upcastType:()=>vl.x8,upperBound:()=>De.GaM,util:()=>gn,valueAndGrad:()=>Bs.h7,valueAndGrads:()=>Bs.fN,variable:()=>De.VD$,variableGrads:()=>Bs.pn,version_core:()=>ac,where:()=>De.arb,whereAsync:()=>De.itS,zeros:()=>De.lls,zerosLike:()=>De.P84});var ue={};O.r(ue),O.d(ue,{isBrowser:()=>ut,isMobile:()=>Fe,mockIsMobile:()=>ge});var xe={};O.r(xe),O.d(xe,{Serializable:()=>pr,SerializationMap:()=>fs,registerClass:()=>Qi});var G={};O.r(G),O.d(G,{browserFiles:()=>Ra,browserHTTPRequest:()=>B,concatenateArrayBuffers:()=>Me,copyModel:()=>hl,decodeWeights:()=>he,encodeWeights:()=>F,fromMemory:()=>ht,fromMemorySync:()=>dt,getLoadHandlers:()=>Ge,getModelArtifactsForJSON:()=>At,getModelArtifactsForJSONSync:()=>_t,getModelArtifactsInfoForJSON:()=>Kt,getSaveHandlers:()=>Se,getWeightSpecs:()=>dn,http:()=>z,isHTTPScheme:()=>g,listModels:()=>eo,loadWeights:()=>ta,moveModel:()=>ql,registerLoadRouter:()=>Rn,registerSaveRouter:()=>wi,removeModel:()=>Dr,weightsLoaderFactory:()=>gl,withSaveHandler:()=>xt,withSaveHandlerSync:()=>Tt});var q={};O.r(q),O.d(q,{confusionMatrix:()=>Us});var P={};O.r(P),O.d(P,{fromPixels:()=>Ai,fromPixelsAsync:()=>Lh,toPixels:()=>Fa});var U={};O.r(U),O.d(U,{prepareAndValidate:()=>nu});var pe={};O.r(pe),O.d(pe,{assertParamsValid:()=>bl,computeFlatOffset:()=>rc,computeOutShape:()=>_l,getNormalizedAxes:()=>ci,isSliceContinous:()=>su,maskToAxes:()=>ru,parseSliceParams:()=>sd,sliceInfo:()=>ui,startForAxis:()=>zn,startIndicesWithElidedDims:()=>ro,stopForAxis:()=>Pa,stopIndicesWithElidedDims:()=>gs,stridesForAxis:()=>zs,stridesWithElidedDims:()=>Un});var ce={};O.r(ce),O.d(ce,{TEST_EPSILON_FLOAT16:()=>au,createVideoElement:()=>$a,encodeStrings:()=>ki,expectArrayBuffersEqual:()=>ns,expectArraysClose:()=>lu,expectArraysEqual:()=>Bh,expectNumbersClose:()=>id,expectPromiseToFail:()=>od,expectValuesInRange:()=>ic,play:()=>Vh,testEpsilon:()=>ra});var X={};O.r(X),O.d(X,{collectGatherOpShapeInfo:()=>em,computeOutShape:()=>pc,segOpComputeOptimalWindowSize:()=>aa});var ie={};O.r(ie),O.d(ie,{ERF_A1:()=>so,ERF_A2:()=>sa,ERF_A3:()=>ss,ERF_A4:()=>Ba,ERF_A5:()=>Cr,ERF_P:()=>fr,PARALLELIZE_THRESHOLD:()=>Ri,RowPartitionType:()=>It,SELU_SCALE:()=>vn,SELU_SCALEALPHA:()=>Bt,applyActivation:()=>La.QH,assertAndGetBroadcastShape:()=>Is.assertAndGetBroadcastShape,assertAxesAreInnerMostDims:()=>Mi.lB,assertParamsConsistent:()=>Wh,assignToTypedArray:()=>Rr,axesAreInnerMostDims:()=>Mi.YB,calculateShapes:()=>Ke.calculateShapes,checkEinsumDimSizes:()=>uc,checkPadOnDimRoundingMode:()=>wo.m,combineLocations:()=>Mi.Vh,combineRaggedTensorToTensorShapes:()=>As,complexWithEvenIndex:()=>xl,complexWithOddIndex:()=>ud,computeConv2DInfo:()=>wo.Ix,computeConv3DInfo:()=>wo.jw,computeDefaultPad:()=>wo.aO,computeDilation2DInfo:()=>wo.Rf,computeOptimalWindowSize:()=>Gr,computeOutAndReduceShapes:()=>Mi.kz,computeOutShape:()=>Zn,computePool2DInfo:()=>wo.Xw,computePool3DInfo:()=>wo.pl,convertConv2DDataFormat:()=>wo.sl,decodeEinsumEquation:()=>Eo,eitherStridesOrDilationsAreOne:()=>wo.jT,expandShapeToKeepDim:()=>Mi.rv,exponent:()=>Ua,exponents:()=>Cl,fromStringArrayToUint8:()=>pu,fromUint8ToStringArray:()=>Xh,getAxesPermutation:()=>Mi.Q3,getBroadcastDims:()=>Is.getBroadcastDims,getComplexWithIndex:()=>Va,getEinsumComputePath:()=>Pn,getEinsumPermutation:()=>cc,getFusedBiasGradient:()=>La.pf,getFusedDyActivation:()=>La.Fr,getImageCenter:()=>ld,getInnerMostAxes:()=>Mi.sY,getPermuted:()=>lc,getRaggedRank:()=>rs,getReductionAxes:()=>Is.getReductionAxes,getReshaped:()=>cd,getReshapedPermuted:()=>jh,getRowPartitionTypesHelper:()=>jn,getSliceBeginCoords:()=>Gh,getSliceSize:()=>Pr,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>zo,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>dc,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>za,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Kh,getSparseReshapeInputOutputMismatchErrorMessage:()=>ks,getSparseReshapeInputOutputMultipleErrorMessage:()=>Hs,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>El,getSparseReshapeNegativeOutputDimErrorMessage:()=>Kr,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Do,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>hu,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>di,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>hc,getUndoAxesPermutation:()=>Mi.LJ,isIdentityPermutation:()=>$b,log:()=>oa.c,mergeRealAndImagArrays:()=>ia,prepareAndValidate:()=>nu,prepareSplitSize:()=>dd,segment_util:()=>X,shouldFuse:()=>La.uy,slice_util:()=>pe,splitRealAndImagArrays:()=>yn,stridesOrDilationsArePositive:()=>wo.U3,tupleValuesAreOne:()=>wo.I0,upcastType:()=>vl.x8,validateDefaultValueShape:()=>Ns,validateInput:()=>Ke.validateInput,validateUpdateShape:()=>Ke.validateUpdateShape,warn:()=>oa.Z});var re={};O.r(re),O.d(re,{nonMaxSuppressionV3Impl:()=>hd.GP,nonMaxSuppressionV4Impl:()=>hd.qP,nonMaxSuppressionV5Impl:()=>hd.pA,whereImpl:()=>tm.Z});var I=O(3738);let Ae;function ge(R){Ae=R}function Fe(R){if(void 0!==Ae)return Ae;if(R||function se(){return typeof navigator<"u"&&null!=navigator}()){if(R||(R=navigator),"ReactNative"===R.product)return!0;const x=R.userAgent||R.vendor||(typeof window<"u"?window.opera:"");return x?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(x)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(x.substr(0,4)):R.userAgentData&&R.userAgentData.mobile}return!1}function ut(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}var ot=O(1777);const Mt=(0,ot.OB)();Mt.registerFlag("DEBUG",()=>!1,R=>{R&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Mt.registerFlag("IS_BROWSER",()=>ut()),Mt.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),Mt.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Mt.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),Mt.registerFlag("PROD",()=>!1),Mt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Mt.getBool("DEBUG")),Mt.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Mt.registerFlag("IS_TEST",()=>!1),Mt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Mt.getBool("DEBUG")),Mt.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Mt.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Mt.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var ct=O(5861),de=O(9907),nt=O(1973),Be=O(1396);const Q={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},ae=4;function F(R,x){return ee.apply(this,arguments)}function ee(){return ee=(0,ct.Z)(function*(R,x){const M=[],L=[],H=Array.isArray(R)?R.map(me=>me.name):Object.keys(R);for(let me=0;me<H.length;++me){const Te=H[me],Xe=Array.isArray(R)?R[me].tensor:R[Te];if("float32"!==Xe.dtype&&"int32"!==Xe.dtype&&"bool"!==Xe.dtype&&"string"!==Xe.dtype&&"complex64"!==Xe.dtype)throw new Error(`Unsupported dtype in weight '${Te}': ${Xe.dtype}`);const Ze={name:Te,shape:Xe.shape,dtype:Xe.dtype};if("string"===Xe.dtype){const St=new Promise(function(){var Qe=(0,ct.Z)(function*(Je){const Nt=yield Xe.bytes(),zt=Nt.reduce((Xn,os)=>Xn+os.length,0)+ae*Nt.length,Jt=new Uint8Array(zt);let bn=0;for(let Xn=0;Xn<Nt.length;Xn++){const os=Nt[Xn],Zt=new Uint8Array(new Uint32Array([os.length]).buffer);Jt.set(Zt,bn),bn+=ae,Jt.set(os,bn),bn+=os.length}Je(Jt)});return function(Je){return Qe.apply(this,arguments)}}());L.push(St)}else L.push(Xe.data());null!=x&&(Ze.group=x),M.push(Ze)}return{data:Re(yield Promise.all(L)),specs:M}}),ee.apply(this,arguments)}function he(R,x){const M={};let L,H=0;for(const oe of x){const me=oe.name,Te=oe.dtype,Xe=oe.shape,Ze=(0,Be.NA)(Xe);let St;if("quantization"in oe){const Qe=oe.quantization;if("uint8"===Qe.dtype||"uint16"===Qe.dtype){if(!("min"in Qe)||!("scale"in Qe))throw new Error(`Weight ${oe.name} with quantization ${Qe.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==Qe.dtype)throw new Error(`Weight ${oe.name} has unknown quantization dtype ${Qe.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==Te)throw new Error(`Weight ${oe.name} is quantized with ${Qe.dtype} which only supports weights of type float32 not ${Te}.`)}const Je=Q[Qe.dtype],Nt=R.slice(H,H+Ze*Je),zt="uint8"===Qe.dtype?new Uint8Array(Nt):new Uint16Array(Nt);if("float32"===Te)if("uint8"===Qe.dtype||"uint16"===Qe.dtype){St=new Float32Array(zt.length);for(let Jt=0;Jt<zt.length;Jt++)St[Jt]=zt[Jt]*Qe.scale+Qe.min}else{if("float16"!==Qe.dtype)throw new Error(`Unsupported quantization type ${Qe.dtype} for weight type float32.`);void 0===L&&(L=gt()),St=L(zt)}else{if("int32"!==Te)throw new Error(`Unsupported dtype in weight '${me}': ${Te}`);if("uint8"!==Qe.dtype&&"uint16"!==Qe.dtype)throw new Error(`Unsupported quantization type ${Qe.dtype} for weight type int32.`);St=new Int32Array(zt.length);for(let Jt=0;Jt<zt.length;Jt++)St[Jt]=Math.round(zt[Jt]*Qe.scale+Qe.min)}H+=Ze*Je}else if("string"===Te){const Qe=(0,Be.NA)(oe.shape);St=[];for(let Je=0;Je<Qe;Je++){const Nt=new Uint32Array(R.slice(H,H+ae))[0];H+=ae;const zt=new Uint8Array(R.slice(H,H+Nt));St.push(zt),H+=Nt}}else{const Qe=Q[Te],Je=R.slice(H,H+Ze*Qe);if("float32"===Te)St=new Float32Array(Je);else if("int32"===Te)St=new Int32Array(Je);else if("bool"===Te)St=new Uint8Array(Je);else{if("complex64"!==Te)throw new Error(`Unsupported dtype in weight '${me}': ${Te}`);{St=new Float32Array(Je);const Nt=new Float32Array(St.length/2),zt=new Float32Array(St.length/2);for(let Xn=0;Xn<Nt.length;Xn++)Nt[Xn]=St[2*Xn],zt[Xn]=St[2*Xn+1];const Jt=(0,nt.X)(Nt,Xe,"float32"),bn=(0,nt.X)(zt,Xe,"float32");M[me]=(0,de.P)(Jt,bn),Jt.dispose(),bn.dispose()}}H+=Ze*Qe}"complex64"!==Te&&(M[me]=(0,nt.X)(St,Xe,Te))}return M}function Re(R){if(null===R)throw new Error(`Invalid input value: ${JSON.stringify(R)}`);let x=0;const M=[];R.forEach(oe=>{if(x+=oe.byteLength,M.push(oe.byteLength===oe.buffer.byteLength?oe:new oe.constructor(oe)),!(oe instanceof Float32Array||oe instanceof Int32Array||oe instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${oe.constructor.name}`)});const L=new Uint8Array(x);let H=0;return M.forEach(oe=>{L.set(new Uint8Array(oe.buffer),H),H+=oe.byteLength}),L.buffer}const S=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function ze(R){return S?Buffer.byteLength(R):new Blob([R]).size}function Me(R){if(1===R.length)return R[0];let x=0;R.forEach(H=>{x+=H.byteLength});const M=new Uint8Array(x);let L=0;return R.forEach(H=>{M.set(new Uint8Array(H),L),L+=H.byteLength}),M.buffer}function ke(R){for(R=R.trim();R.endsWith("/");)R=R.slice(0,R.length-1);const M=R.split("/");return M[M.length-1]}function we(R,x){const M={modelTopology:R.modelTopology,format:R.format,generatedBy:R.generatedBy,convertedBy:R.convertedBy,weightsManifest:x};return null!=R.signature&&(M.signature=R.signature),null!=R.userDefinedMetadata&&(M.userDefinedMetadata=R.userDefinedMetadata),null!=R.modelInitializer&&(M.modelInitializer=R.modelInitializer),null!=R.initializerSignature&&(M.initializerSignature=R.initializerSignature),null!=R.trainingConfig&&(M.trainingConfig=R.trainingConfig),M}function _t(R,x,M){const L={modelTopology:R.modelTopology,format:R.format,generatedBy:R.generatedBy,convertedBy:R.convertedBy};if(null!=R.trainingConfig&&(L.trainingConfig=R.trainingConfig),null!=R.weightsManifest){if(!x)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!M)throw new Error("modelJSON has weightsManifest but weightData is null");L.weightSpecs=x,L.weightData=M}return null!=R.signature&&(L.signature=R.signature),null!=R.userDefinedMetadata&&(L.userDefinedMetadata=R.userDefinedMetadata),null!=R.modelInitializer&&(L.modelInitializer=R.modelInitializer),null!=R.initializerSignature&&(L.initializerSignature=R.initializerSignature),L}function At(R,x){return et.apply(this,arguments)}function et(){return(et=(0,ct.Z)(function*(R,x){let M,L;return null!=R.weightsManifest&&([M,L]=yield x(R.weightsManifest)),_t(R,M,L)})).apply(this,arguments)}function Kt(R){if(R.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==R.modelTopology?0:ze(JSON.stringify(R.modelTopology)),weightSpecsBytes:null==R.weightSpecs?0:ze(JSON.stringify(R.weightSpecs)),weightDataBytes:null==R.weightData?0:R.weightData.byteLength}}function dn(R){const x=[];for(const M of R)x.push(...M.weights);return x}function gt(){const R=function nn(){const R=M=>{let L=M<<13,H=0;for(;!(8388608&L);)H-=8388608,L<<=1;return L&=-8388609,H+=947912704,L|H},x=new Uint32Array(2048);x[0]=0;for(let M=1;M<1024;M++)x[M]=R(M);for(let M=1024;M<2048;M++)x[M]=939524096+(M-1024<<13);return x}(),x=function Vt(){const R=new Uint32Array(64);R[0]=0,R[31]=1199570944,R[32]=2147483648,R[63]=3347054592;for(let x=1;x<31;x++)R[x]=x<<23;for(let x=33;x<63;x++)R[x]=2147483648+(x-32<<23);return R}(),M=function rn(){const R=new Uint32Array(64);for(let x=0;x<64;x++)R[x]=1024;return R[0]=R[32]=0,R}();return L=>{const H=new ArrayBuffer(4*L.length),oe=new Uint32Array(H);for(let me=0;me<L.length;me++){const Te=L[me];oe[me]=R[M[Te>>10]+(1023&Te)]+x[Te>>10]}return new Float32Array(H)}}class cn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==cn.instance&&(cn.instance=new cn),cn.instance}static registerSaveRouter(x){cn.getInstance().saveRouters.push(x)}static registerLoadRouter(x){cn.getInstance().loadRouters.push(x)}static getSaveHandlers(x){return cn.getHandlers(x,"save")}static getLoadHandlers(x,M){return cn.getHandlers(x,"load",M)}static getHandlers(x,M,L){const H=[];return("load"===M?cn.getInstance().loadRouters:cn.getInstance().saveRouters).forEach(me=>{const Te=me(x,L);null!==Te&&H.push(Te)}),H}}const wi=R=>cn.registerSaveRouter(R),Rn=R=>cn.registerLoadRouter(R),Se=R=>cn.getSaveHandlers(R),Ge=(R,x)=>cn.getLoadHandlers(R,x),rt="tensorflowjs",_n="models_store",Nn="model_info_store";function Mr(){if(!(0,ot.OB)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const R=typeof window>"u"?self:window,x=R.indexedDB||R.mozIndexedDB||R.webkitIndexedDB||R.msIndexedDB||R.shimIndexedDB;if(null==x)throw new Error("The current browser does not appear to support IndexedDB.");return x}function Zo(R){const x=R.result;x.createObjectStore(_n,{keyPath:"modelPath"}),x.createObjectStore(Nn,{keyPath:"modelPath"})}let _o=(()=>{class R{constructor(M){if(this.indexedDB=Mr(),null==M||!M)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=M}save(M){var L=this;return(0,ct.Z)(function*(){if(M.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return L.databaseAction(L.modelPath,M)})()}load(){var M=this;return(0,ct.Z)(function*(){return M.databaseAction(M.modelPath)})()}databaseAction(M,L){return new Promise((H,oe)=>{const me=this.indexedDB.open(rt,1);me.onupgradeneeded=()=>Zo(me),me.onsuccess=()=>{const Te=me.result;if(null==L){const Xe=Te.transaction(_n,"readonly"),St=Xe.objectStore(_n).get(this.modelPath);St.onsuccess=()=>{if(null==St.result)return Te.close(),oe(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));H(St.result.modelArtifacts)},St.onerror=Qe=>(Te.close(),oe(St.error)),Xe.oncomplete=()=>Te.close()}else{const Xe=Kt(L),Ze=Te.transaction(Nn,"readwrite");let Qe,Je,St=Ze.objectStore(Nn);try{Qe=St.put({modelPath:this.modelPath,modelArtifactsInfo:Xe})}catch(Nt){return oe(Nt)}Qe.onsuccess=()=>{Je=Te.transaction(_n,"readwrite");const Nt=Je.objectStore(_n);let zt;try{zt=Nt.put({modelPath:this.modelPath,modelArtifacts:L,modelArtifactsInfo:Xe})}catch(Jt){return oe(Jt)}zt.onsuccess=()=>H({modelArtifactsInfo:Xe}),zt.onerror=Jt=>{St=Ze.objectStore(Nn);const bn=St.delete(this.modelPath);bn.onsuccess=()=>(Te.close(),oe(zt.error)),bn.onerror=Xn=>(Te.close(),oe(zt.error))}},Qe.onerror=Nt=>(Te.close(),oe(Qe.error)),Ze.oncomplete=()=>{null==Je?Te.close():Je.oncomplete=()=>Te.close()}}},me.onerror=Te=>oe(me.error)})}}return R.URL_SCHEME="indexeddb://",R})();const Ea=R=>(0,ot.OB)().getBool("IS_BROWSER")&&!Array.isArray(R)&&R.startsWith(_o.URL_SCHEME)?function Si(R){return new _o(R)}(R.slice(_o.URL_SCHEME.length)):null;cn.registerSaveRouter(Ea),cn.registerLoadRouter(Ea);class Da{constructor(){this.indexedDB=Mr()}listModels(){var x=this;return(0,ct.Z)(function*(){return new Promise((M,L)=>{const H=x.indexedDB.open(rt,1);H.onupgradeneeded=()=>Zo(H),H.onsuccess=()=>{const oe=H.result,me=oe.transaction(Nn,"readonly"),Xe=me.objectStore(Nn).getAll();Xe.onsuccess=()=>{const Ze={};for(const St of Xe.result)Ze[St.modelPath]=St.modelArtifactsInfo;M(Ze)},Xe.onerror=Ze=>(oe.close(),L(Xe.error)),me.oncomplete=()=>oe.close()},H.onerror=oe=>L(H.error)})})()}removeModel(x){var M=this;return(0,ct.Z)(function*(){return x=function Gi(R){return R.startsWith(_o.URL_SCHEME)?R.slice(_o.URL_SCHEME.length):R}(x),new Promise((L,H)=>{const oe=M.indexedDB.open(rt,1);oe.onupgradeneeded=()=>Zo(oe),oe.onsuccess=()=>{const me=oe.result,Te=me.transaction(Nn,"readwrite"),Xe=Te.objectStore(Nn),Ze=Xe.get(x);let St;Ze.onsuccess=()=>{if(null==Ze.result)return me.close(),H(new Error(`Cannot find model with path '${x}' in IndexedDB.`));{const Qe=Xe.delete(x),Je=()=>{St=me.transaction(_n,"readwrite");const zt=St.objectStore(_n).delete(x);zt.onsuccess=()=>L(Ze.result.modelArtifactsInfo),zt.onerror=Jt=>H(Ze.error)};Qe.onsuccess=Je,Qe.onerror=Nt=>(Je(),me.close(),H(Ze.error))}},Ze.onerror=Qe=>(me.close(),H(Ze.error)),Te.oncomplete=()=>{null==St?me.close():St.oncomplete=()=>me.close()}},oe.onerror=me=>H(oe.error)})})()}}const ps="/",Ys="tensorflowjs_models",Ds="info",Ki="model_topology",cl="weight_specs",Xi="weight_data",Ta="model_metadata";function Qs(R){return{info:[Ys,R,Ds].join(ps),topology:[Ys,R,Ki].join(ps),weightSpecs:[Ys,R,cl].join(ps),weightData:[Ys,R,Xi].join(ps),modelMetadata:[Ys,R,Ta].join(ps)}}function qi(R){for(const x of Object.values(R))window.localStorage.removeItem(x)}function ul(R){const x=R.split(ps);if(x.length<3)throw new Error(`Invalid key format: ${R}`);return x.slice(1,x.length-1).join(ps)}let Qo=(()=>{class R{constructor(M){if(!(0,ot.OB)().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==M||!M)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=M,this.keys=Qs(this.modelPath)}save(M){var L=this;return(0,ct.Z)(function*(){if(M.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const H=JSON.stringify(M.modelTopology),oe=JSON.stringify(M.weightSpecs),me=Kt(M);try{return L.LS.setItem(L.keys.info,JSON.stringify(me)),L.LS.setItem(L.keys.topology,H),L.LS.setItem(L.keys.weightSpecs,oe),L.LS.setItem(L.keys.weightData,function ye(R){if(S)return Buffer.from(R).toString("base64");const x=new Uint8Array(R);let M="";for(let L=0,H=x.length;L<H;L++)M+=String.fromCharCode(x[L]);return btoa(M)}(M.weightData)),L.LS.setItem(L.keys.modelMetadata,JSON.stringify({format:M.format,generatedBy:M.generatedBy,convertedBy:M.convertedBy,signature:null!=M.signature?M.signature:void 0,userDefinedMetadata:null!=M.userDefinedMetadata?M.userDefinedMetadata:void 0,modelInitializer:null!=M.modelInitializer?M.modelInitializer:void 0,initializerSignature:null!=M.initializerSignature?M.initializerSignature:void 0,trainingConfig:null!=M.trainingConfig?M.trainingConfig:void 0})),{modelArtifactsInfo:me}}catch{throw qi(L.keys),new Error(`Failed to save model '${L.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${me.modelTopologyBytes}, weightSpecsBytes=${me.weightSpecsBytes}, weightDataBytes=${me.weightDataBytes}.`)}}})()}load(){var M=this;return(0,ct.Z)(function*(){const L=JSON.parse(M.LS.getItem(M.keys.info));if(null==L)throw new Error(`In local storage, there is no model with name '${M.modelPath}'`);if("JSON"!==L.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const H={},oe=JSON.parse(M.LS.getItem(M.keys.topology));if(null==oe)throw new Error(`In local storage, the topology of model '${M.modelPath}' is missing.`);H.modelTopology=oe;const me=JSON.parse(M.LS.getItem(M.keys.weightSpecs));if(null==me)throw new Error(`In local storage, the weight specs of model '${M.modelPath}' are missing.`);H.weightSpecs=me;const Te=M.LS.getItem(M.keys.modelMetadata);if(null!=Te){const Ze=JSON.parse(Te);H.format=Ze.format,H.generatedBy=Ze.generatedBy,H.convertedBy=Ze.convertedBy,null!=Ze.signature&&(H.signature=Ze.signature),null!=Ze.userDefinedMetadata&&(H.userDefinedMetadata=Ze.userDefinedMetadata),null!=Ze.modelInitializer&&(H.modelInitializer=Ze.modelInitializer),null!=Ze.initializerSignature&&(H.initializerSignature=Ze.initializerSignature),null!=Ze.trainingConfig&&(H.trainingConfig=Ze.trainingConfig)}const Xe=M.LS.getItem(M.keys.weightData);if(null==Xe)throw new Error(`In local storage, the binary weight values of model '${M.modelPath}' are missing.`);return H.weightData=function ve(R){if(S){const L=Buffer.from(R,"base64");return L.buffer.slice(L.byteOffset,L.byteOffset+L.byteLength)}const x=atob(R),M=new Uint8Array(x.length);for(let L=0;L<x.length;++L)M.set([x.charCodeAt(L)],L);return M.buffer}(Xe),H})()}}return R.URL_SCHEME="localstorage://",R})();const Zi=R=>(0,ot.OB)().getBool("IS_BROWSER")&&!Array.isArray(R)&&R.startsWith(Qo.URL_SCHEME)?function vo(R){return new Qo(R)}(R.slice(Qo.URL_SCHEME.length)):null;cn.registerSaveRouter(Zi),cn.registerLoadRouter(Zi);class dl{constructor(){(0,Be.hu)((0,ot.OB)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),(0,Be.hu)(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var x=this;return(0,ct.Z)(function*(){const M={},L=Ys+ps,H=ps+Ds;for(let oe=0;oe<x.LS.length;++oe){const me=x.LS.key(oe);me.startsWith(L)&&me.endsWith(H)&&(M[ul(me)]=JSON.parse(x.LS.getItem(me)))}return M})()}removeModel(x){var M=this;return(0,ct.Z)(function*(){const L=Qs(x=function Ce(R){return R.startsWith(Qo.URL_SCHEME)?R.slice(Qo.URL_SCHEME.length):R}(x));if(null==M.LS.getItem(L.info))throw new Error(`Cannot find model at path '${x}'`);const H=JSON.parse(M.LS.getItem(L.info));return qi(L),H})()}}const _r="://";class vr{constructor(){this.managers={}}static getInstance(){return null==vr.instance&&(vr.instance=new vr),vr.instance}static registerManager(x,M){(0,Be.hu)(null!=x,()=>"scheme must not be undefined or null."),x.endsWith(_r)&&(x=x.slice(0,x.indexOf(_r))),(0,Be.hu)(x.length>0,()=>"scheme must not be an empty string.");const L=vr.getInstance();(0,Be.hu)(null==L.managers[x],()=>`A model store manager is already registered for scheme '${x}'.`),L.managers[x]=M}static getManager(x){const M=vr.getInstance().managers[x];if(null==M)throw new Error(`Cannot find model manager for scheme '${x}'`);return M}static getSchemes(){return Object.keys(vr.getInstance().managers)}}function Js(R){if(-1===R.indexOf(_r))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${vr.getSchemes().join(",")}`);return{scheme:R.split(_r)[0],path:R.split(_r)[1]}}function Jo(R,x){return Ei.apply(this,arguments)}function Ei(){return(Ei=(0,ct.Z)(function*(R,x,M=!1){(0,Be.hu)(R!==x,()=>`Old path and new path are the same: '${R}'`);const L=cn.getLoadHandlers(R);(0,Be.hu)(L.length>0,()=>`Copying failed because no load handler is found for source URL ${R}.`),(0,Be.hu)(L.length<2,()=>`Copying failed because more than one (${L.length}) load handlers for source URL ${R}.`);const H=L[0],oe=cn.getSaveHandlers(x);(0,Be.hu)(oe.length>0,()=>`Copying failed because no save handler is found for destination URL ${x}.`),(0,Be.hu)(oe.length<2,()=>`Copying failed because more than one (${L.length}) save handlers for destination URL ${x}.`);const me=oe[0],Te=Js(R).scheme,Xe=Js(R).path,Ze=Te===Js(R).scheme,St=yield H.load();M&&Ze&&(yield vr.getManager(Te).removeModel(Xe));const Qe=yield me.save(St);return M&&!Ze&&(yield vr.getManager(Te).removeModel(Xe)),Qe.modelArtifactsInfo})).apply(this,arguments)}function eo(){return Di.apply(this,arguments)}function Di(){return(Di=(0,ct.Z)(function*(){const R=vr.getSchemes(),x={};for(const M of R){const L=yield vr.getManager(M).listModels();for(const H in L)x[M+_r+H]=L[H]}return x})).apply(this,arguments)}function Dr(R){return Po.apply(this,arguments)}function Po(){return(Po=(0,ct.Z)(function*(R){const x=Js(R);return vr.getManager(x.scheme).removeModel(x.path)})).apply(this,arguments)}function hl(R,x){return Yi.apply(this,arguments)}function Yi(){return(Yi=(0,ct.Z)(function*(R,x){return Jo(R,x,!1)})).apply(this,arguments)}function ql(R,x){return $o.apply(this,arguments)}function $o(){return($o=(0,ct.Z)(function*(R,x){return Jo(R,x,!0)})).apply(this,arguments)}var pl=O(1946);class Zl{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(x,M){return fetch(x,M)}now(){return performance.now()}encode(x,M){if("utf-8"!==M&&"utf8"!==M)throw new Error(`Browser's encoder only supports utf-8, but got ${M}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(x)}decode(x,M){return new TextDecoder(M).decode(x)}setTimeoutCustom(x,M){typeof window>"u"||!(0,ot.OB)().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(x,M):(this.functionRefs.push(x),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},M),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",L=>{L.source===window&&L.data.name===this.messageName&&(L.stopPropagation(),(0,this.functionRefs[L.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(x){return(0,pl.j)(x)}}if((0,ot.OB)().get("IS_BROWSER")){(0,ot.OB)().setPlatform("browser",new Zl);try{vr.registerManager(Qo.URL_SCHEME,new dl)}catch{}try{vr.registerManager(_o.URL_SCHEME,new Da)}catch{}}let ei;(0,ot.OB)().get("IS_NODE")&&!(0,ot.OB)().get("IS_BROWSER")&&(0,ot.OB)().setPlatform("node",new class Yl{constructor(){this.util=O(8628),this.textEncoder=new this.util.TextEncoder}fetch(x,M){return null!=(0,ot.OB)().global.fetch?(0,ot.OB)().global.fetch(x,M):(null==ei&&(ei=O(5410)),ei(x,M))}now(){const x=process.hrtime();return 1e3*x[0]+x[1]/1e6}encode(x,M){if("utf-8"!==M&&"utf8"!==M)throw new Error(`Node built-in encoder only supports utf-8, but got ${M}`);return this.textEncoder.encode(x)}decode(x,M){return 0===x.length?"":new this.util.TextDecoder(M).decode(x)}isTypedArray(x){return this.util.types.isFloat32Array(x)||this.util.types.isInt32Array(x)||this.util.types.isUint8Array(x)||this.util.types.isUint8ClampedArray(x)}});var Ql=O(8621),Lo=O(9734),Ia=O(4249),Aa=O(2174),$s=O(708);(0,I.wv)(),(0,$s.Vp)({buffer:Ql.f,cast:Lo.p,clone:Ia.d,print:Aa.S});var Yt=O(9370),Ln=O(6849),Ls=O(6635),Tn=O(8788),ni=O(5562),xo=O(4164),Ts=O(37),Bs=O(1335),Bo=O(316);class pr{getClassName(){return this.constructor.className}static fromConfig(x,M){return new x(M)}}class fs{constructor(){this.classNameMap={}}static getMap(){return null==fs.instance&&(fs.instance=new fs),fs.instance}static register(x){fs.getMap().classNameMap[x.className]=[x,x.fromConfig]}}function Qi(R){(0,Be.hu)(null!=R.className,()=>"Class being registered does not have the static className property defined."),(0,Be.hu)("string"==typeof R.className,()=>"className is required to be a string, but got type "+typeof R.className),(0,Be.hu)(R.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),fs.register(R)}class qn extends pr{minimize(x,M=!1,L){const{value:H,grads:oe}=this.computeGradients(x,L);if(null!=L){const me=L.map(Te=>({name:Te.name,tensor:oe[Te.name]}));this.applyGradients(me)}else this.applyGradients(oe);return(0,Yt.B9)(oe),M?H:(H.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(x,M){return(0,Bs.pn)(x,M)}dispose(){null!=this.iterations_&&(0,Yt.B9)(this.iterations_)}saveIterations(){var x=this;return(0,ct.Z)(function*(){return null==x.iterations_&&(x.iterations_=0),{name:"iter",tensor:(0,Bo.i)(x.iterations_,"int32")}})()}getWeights(){return(0,ct.Z)(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(x){var M=this;return(0,ct.Z)(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${M.getClassName()}`)})()}extractIterations(x){var M=this;return(0,ct.Z)(function*(){return M.iterations_=(yield x[0].tensor.data())[0],x.slice(1)})()}}Object.defineProperty(qn,Symbol.hasInstance,{value:R=>null!=R.minimize&&null!=R.computeGradients&&null!=R.applyGradients});class on extends qn{static get className(){return"Adadelta"}constructor(x,M,L=null){super(),this.learningRate=x,this.rho=M,this.epsilon=L,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==L&&(this.epsilon=I.BV.backend.epsilon())}applyGradients(x){(Array.isArray(x)?x.map(L=>L.name):Object.keys(x)).forEach((L,H)=>{const oe=I.BV.registeredVariables[L];null==this.accumulatedGrads[H]&&(this.accumulatedGrads[H]={originalName:`${L}/accum_grad`,variable:(0,Yt.lu)(()=>(0,Ts.P)(oe).variable(!1))}),null==this.accumulatedUpdates[H]&&(this.accumulatedUpdates[H]={originalName:`${L}/accum_var`,variable:(0,Yt.lu)(()=>(0,Ts.P)(oe).variable(!1))});const Te=Array.isArray(x)?x[H].tensor:x[L];if(null==Te)return;const Xe=this.accumulatedGrads[H].variable,Ze=this.accumulatedUpdates[H].variable;(0,Yt.lu)(()=>{const St=(0,Ln.I)((0,Tn.d)(Xe,this.rho),(0,Tn.d)((0,xo.h)(Te),1-this.rho)),Qe=(0,Tn.d)((0,Ls.h)((0,ni._)((0,Ln.I)(Ze,this.epsilon)),(0,ni._)((0,Ln.I)(Xe,this.epsilon))),Te),Je=(0,Ln.I)((0,Tn.d)(Ze,this.rho),(0,Tn.d)((0,xo.h)(Qe),1-this.rho));Xe.assign(St),Ze.assign(Je);const Nt=(0,Ln.I)((0,Tn.d)(Qe,-this.learningRate),oe);oe.assign(Nt)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,Yt.B9)(this.accumulatedGrads.map(x=>x.variable)),(0,Yt.B9)(this.accumulatedUpdates.map(x=>x.variable)))}getWeights(){var x=this;return(0,ct.Z)(function*(){const M=[...x.accumulatedGrads,...x.accumulatedUpdates];return[yield x.saveIterations()].concat(M.map(L=>({name:L.originalName,tensor:L.variable})))})()}setWeights(x){var M=this;return(0,ct.Z)(function*(){const L=(x=yield M.extractIterations(x)).length/2;M.accumulatedGrads=x.slice(0,L).map(oe=>({originalName:oe.name,variable:oe.tensor.variable(!1)})),M.accumulatedUpdates=x.slice(L,2*L).map(oe=>({originalName:oe.name,variable:oe.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(x,M){return new x(M.learningRate,M.rho,M.epsilon)}}var Na=O(8509);class Jn extends qn{static get className(){return"Adagrad"}constructor(x,M=.1){super(),this.learningRate=x,this.initialAccumulatorValue=M,this.accumulatedGrads=[]}applyGradients(x){(Array.isArray(x)?x.map(L=>L.name):Object.keys(x)).forEach((L,H)=>{const oe=I.BV.registeredVariables[L];null==this.accumulatedGrads[H]&&(this.accumulatedGrads[H]={originalName:`${L}/accumulator`,variable:(0,Yt.lu)(()=>(0,Na.h)(oe.shape,this.initialAccumulatorValue).variable(!1))});const me=Array.isArray(x)?x[H].tensor:x[L];if(null==me)return;const Te=this.accumulatedGrads[H].variable;(0,Yt.lu)(()=>{const Xe=(0,Ln.I)(Te,(0,xo.h)(me));Te.assign(Xe);const Ze=(0,Ln.I)((0,Tn.d)((0,Ls.h)(me,(0,ni._)((0,Ln.I)(Xe,I.BV.backend.epsilon()))),-this.learningRate),oe);oe.assign(Ze)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,Yt.B9)(this.accumulatedGrads.map(x=>x.variable))}getWeights(){var x=this;return(0,ct.Z)(function*(){return[yield x.saveIterations()].concat(x.accumulatedGrads.map(M=>({name:M.originalName,tensor:M.variable})))})()}setWeights(x){var M=this;return(0,ct.Z)(function*(){x=yield M.extractIterations(x),M.accumulatedGrads=x.map(H=>({originalName:H.name,variable:H.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(x,M){return new x(M.learningRate,M.initialAccumulatorValue)}}var Ji=O(9043),jr=O(8578);class Fn extends qn{static get className(){return"Adam"}constructor(x,M,L,H=null){super(),this.learningRate=x,this.beta1=M,this.beta2=L,this.epsilon=H,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,Yt.lu)(()=>{this.accBeta1=(0,Bo.i)(M).variable(),this.accBeta2=(0,Bo.i)(L).variable()}),null==H&&(this.epsilon=I.BV.backend.epsilon())}applyGradients(x){const M=Array.isArray(x)?x.map(L=>L.name):Object.keys(x);(0,Yt.lu)(()=>{const L=(0,jr.l)(1,this.accBeta1),H=(0,jr.l)(1,this.accBeta2);M.forEach((oe,me)=>{const Te=I.BV.registeredVariables[oe];null==this.accumulatedFirstMoment[me]&&(this.accumulatedFirstMoment[me]={originalName:`${oe}/m`,variable:(0,Yt.lu)(()=>(0,Ts.P)(Te).variable(!1))}),null==this.accumulatedSecondMoment[me]&&(this.accumulatedSecondMoment[me]={originalName:`${oe}/v`,variable:(0,Yt.lu)(()=>(0,Ts.P)(Te).variable(!1))});const Ze=Array.isArray(x)?x[me].tensor:x[oe];if(null==Ze)return;const St=this.accumulatedFirstMoment[me].variable,Qe=this.accumulatedSecondMoment[me].variable,Je=(0,Ln.I)((0,Tn.d)(St,this.beta1),(0,Tn.d)(Ze,1-this.beta1)),Nt=(0,Ln.I)((0,Tn.d)(Qe,this.beta2),(0,Tn.d)((0,xo.h)(Ze),1-this.beta2)),zt=(0,Ls.h)(Je,L),Jt=(0,Ls.h)(Nt,H);St.assign(Je),Qe.assign(Nt);const bn=(0,Ln.I)((0,Tn.d)((0,Ls.h)(zt,(0,Ln.I)((0,ni._)(Jt),this.epsilon)),-this.learningRate),Te);Te.assign(bn)}),this.accBeta1.assign((0,Tn.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,Tn.d)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,Yt.B9)(this.accumulatedFirstMoment.map(x=>x.variable)),null!=this.accumulatedSecondMoment&&(0,Yt.B9)(this.accumulatedSecondMoment.map(x=>x.variable))}getWeights(){var x=this;return(0,ct.Z)(function*(){const M=[...x.accumulatedFirstMoment,...x.accumulatedSecondMoment];return[yield x.saveIterations()].concat(M.map(L=>({name:L.originalName,tensor:L.variable})))})()}setWeights(x){var M=this;return(0,ct.Z)(function*(){x=yield M.extractIterations(x),(0,Yt.lu)(()=>{M.accBeta1.assign((0,Ji.s)(M.beta1,M.iterations_+1)),M.accBeta2.assign((0,Ji.s)(M.beta2,M.iterations_+1))});const L=x.length/2;M.accumulatedFirstMoment=x.slice(0,L).map(oe=>({originalName:oe.name,variable:oe.tensor.variable(!1)})),M.accumulatedSecondMoment=x.slice(L,2*L).map(oe=>({originalName:oe.name,variable:oe.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(x,M){return new x(M.learningRate,M.beta1,M.beta2,M.epsilon)}}var an=O(2519),ka=O(6825);class ri extends qn{static get className(){return"Adamax"}constructor(x,M,L,H=null,oe=0){super(),this.learningRate=x,this.beta1=M,this.beta2=L,this.epsilon=H,this.decay=oe,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,Yt.lu)(()=>{this.iteration=(0,Bo.i)(0).variable(),this.accBeta1=(0,Bo.i)(M).variable()}),null==H&&(this.epsilon=I.BV.backend.epsilon())}applyGradients(x){const M=Array.isArray(x)?x.map(L=>L.name):Object.keys(x);(0,Yt.lu)(()=>{const L=(0,jr.l)(1,this.accBeta1),H=(0,Ls.h)(-this.learningRate,(0,Ln.I)((0,Tn.d)(this.iteration,this.decay),1));M.forEach((oe,me)=>{const Te=I.BV.registeredVariables[oe];null==this.accumulatedFirstMoment[me]&&(this.accumulatedFirstMoment[me]={originalName:`${oe}/m`,variable:(0,Ts.P)(Te).variable(!1)}),null==this.accumulatedWeightedInfNorm[me]&&(this.accumulatedWeightedInfNorm[me]={originalName:`${oe}/v`,variable:(0,Ts.P)(Te).variable(!1)});const Ze=Array.isArray(x)?x[me].tensor:x[oe];if(null==Ze)return;const St=this.accumulatedFirstMoment[me].variable,Qe=this.accumulatedWeightedInfNorm[me].variable,Je=(0,Ln.I)((0,Tn.d)(St,this.beta1),(0,Tn.d)(Ze,1-this.beta1)),Nt=(0,Tn.d)(Qe,this.beta2),zt=(0,an.W)(Ze),Jt=(0,ka.g)(Nt,zt);St.assign(Je),Qe.assign(Jt);const bn=(0,Ln.I)((0,Tn.d)((0,Ls.h)(H,L),(0,Ls.h)(Je,(0,Ln.I)(Jt,this.epsilon))),Te);Te.assign(bn)}),this.iteration.assign((0,Ln.I)(this.iteration,1)),this.accBeta1.assign((0,Tn.d)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,Yt.B9)(this.accumulatedFirstMoment.map(x=>x.variable)),null!=this.accumulatedWeightedInfNorm&&(0,Yt.B9)(this.accumulatedWeightedInfNorm.map(x=>x.variable))}getWeights(){return(0,ct.Z)(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(x){return(0,ct.Z)(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(x,M){return new x(M.learningRate,M.beta1,M.beta2,M.epsilon,M.decay)}}class Ma extends qn{static get className(){return"SGD"}constructor(x){super(),this.learningRate=x,this.setLearningRate(x)}applyGradients(x){(Array.isArray(x)?x.map(L=>L.name):Object.keys(x)).forEach((L,H)=>{const oe=Array.isArray(x)?x[H].tensor:x[L];if(null==oe)return;const me=I.BV.registeredVariables[L];(0,Yt.lu)(()=>{const Te=(0,Ln.I)((0,Tn.d)(this.c,oe),me);me.assign(Te)})}),this.incrementIterations()}setLearningRate(x){this.learningRate=x,null!=this.c&&this.c.dispose(),this.c=(0,Yt.Cn)((0,Bo.i)(-x))}dispose(){this.c.dispose()}getWeights(){var x=this;return(0,ct.Z)(function*(){return[yield x.saveIterations()]})()}setWeights(x){var M=this;return(0,ct.Z)(function*(){if(0!==(x=yield M.extractIterations(x)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(x,M){return new x(M.learningRate)}}class si extends Ma{static get className(){return"Momentum"}constructor(x,M,L=!1){super(x),this.learningRate=x,this.momentum=M,this.useNesterov=L,this.accumulations=[],this.m=(0,Bo.i)(this.momentum)}applyGradients(x){(Array.isArray(x)?x.map(L=>L.name):Object.keys(x)).forEach((L,H)=>{const oe=I.BV.registeredVariables[L];null==this.accumulations[H]&&(this.accumulations[H]={originalName:`${L}/momentum`,variable:(0,Yt.lu)(()=>(0,Ts.P)(oe).variable(!1))});const me=this.accumulations[H].variable,Te=Array.isArray(x)?x[H].tensor:x[L];null!=Te&&(0,Yt.lu)(()=>{let Xe;const Ze=(0,Ln.I)((0,Tn.d)(this.m,me),Te);Xe=(0,Ln.I)((0,Tn.d)(this.c,this.useNesterov?(0,Ln.I)(Te,(0,Tn.d)(Ze,this.m)):Ze),oe),me.assign(Ze),oe.assign(Xe)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,Yt.B9)(this.accumulations.map(x=>x.variable))}setMomentum(x){this.momentum=x}getWeights(){var x=this;return(0,ct.Z)(function*(){return[yield x.saveIterations()].concat(x.accumulations.map(M=>({name:M.originalName,tensor:M.variable})))})()}setWeights(x){var M=this;return(0,ct.Z)(function*(){x=yield M.extractIterations(x),M.accumulations=x.map(H=>({originalName:H.name,variable:H.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(x,M){return new x(M.learningRate,M.momentum,M.useNesterov)}}class qe extends qn{static get className(){return"RMSProp"}constructor(x,M=.9,L=0,H=null,oe=!1){if(super(),this.learningRate=x,this.decay=M,this.momentum=L,this.epsilon=H,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=oe,null==H&&(this.epsilon=I.BV.backend.epsilon()),null==x)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(x){(Array.isArray(x)?x.map(L=>L.name):Object.keys(x)).forEach((L,H)=>{const oe=I.BV.registeredVariables[L];null==this.accumulatedMeanSquares[H]&&(this.accumulatedMeanSquares[H]={originalName:`${L}/rms`,variable:(0,Yt.lu)(()=>(0,Ts.P)(oe).variable(!1))}),null==this.accumulatedMoments[H]&&(this.accumulatedMoments[H]={originalName:`${L}/momentum`,variable:(0,Yt.lu)(()=>(0,Ts.P)(oe).variable(!1))}),null==this.accumulatedMeanGrads[H]&&this.centered&&(this.accumulatedMeanGrads[H]={originalName:`${L}/mg`,variable:(0,Yt.lu)(()=>(0,Ts.P)(oe).variable(!1))});const Te=Array.isArray(x)?x[H].tensor:x[L];if(null==Te)return;const Xe=this.accumulatedMeanSquares[H].variable,Ze=this.accumulatedMoments[H].variable;(0,Yt.lu)(()=>{const St=(0,Ln.I)((0,Tn.d)(Xe,this.decay),(0,Tn.d)((0,xo.h)(Te),1-this.decay));if(this.centered){const Qe=this.accumulatedMeanGrads[H].variable,Je=(0,Ln.I)((0,Tn.d)(Qe,this.decay),(0,Tn.d)(Te,1-this.decay)),Nt=(0,Ls.h)((0,Tn.d)(Te,this.learningRate),(0,ni._)((0,jr.l)(St,(0,Ln.I)((0,xo.h)(Je),this.epsilon)))),zt=(0,Ln.I)((0,Tn.d)(Ze,this.momentum),Nt);Xe.assign(St),Qe.assign(Je),Ze.assign(zt);const Jt=(0,jr.l)(oe,zt);oe.assign(Jt)}else{const Qe=(0,Ln.I)((0,Tn.d)(Xe,this.decay),(0,Tn.d)((0,xo.h)(Te),1-this.decay)),Je=(0,Ln.I)((0,Tn.d)(Ze,this.momentum),(0,Ls.h)((0,Tn.d)(Te,this.learningRate),(0,ni._)((0,Ln.I)(Qe,this.epsilon))));Xe.assign(Qe),Ze.assign(Je);const Nt=(0,jr.l)(oe,Je);oe.assign(Nt)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,Yt.B9)(this.accumulatedMeanSquares.map(x=>x.variable)),null!=this.accumulatedMeanGrads&&this.centered&&(0,Yt.B9)(this.accumulatedMeanGrads.map(x=>x.variable)),null!=this.accumulatedMoments&&(0,Yt.B9)(this.accumulatedMoments.map(x=>x.variable))}getWeights(){var x=this;return(0,ct.Z)(function*(){const M=[...x.accumulatedMeanSquares,...x.accumulatedMoments];return x.centered&&M.push(...x.accumulatedMeanGrads),[yield x.saveIterations()].concat(M.map(L=>({name:L.originalName,tensor:L.variable})))})()}setWeights(x){var M=this;return(0,ct.Z)(function*(){x=yield M.extractIterations(x);const L=M.centered?x.length/3:x.length/2,H=!1;M.accumulatedMeanSquares=x.slice(0,L).map(oe=>({originalName:oe.name,variable:oe.tensor.variable(H)})),M.accumulatedMoments=x.slice(L,2*L).map(oe=>({originalName:oe.name,variable:oe.tensor.variable(H)})),M.centered&&(M.accumulatedMeanGrads=x.slice(2*L,3*L).map(oe=>({originalName:oe.name,variable:oe.tensor.variable(H)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(x,M){return new x(M.learningRate,M.decay,M.momentum,M.epsilon,M.centered)}}const oi=[on,Jn,Fn,ri,si,qe,Ma];function ii(R){return new Promise(x=>setTimeout(x)).then(R)}let Vo=(()=>{class R{constructor(M){if(!(0,ot.OB)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");M.startsWith(R.URL_SCHEME)&&(M=M.slice(R.URL_SCHEME.length)),(null==M||0===M.length)&&(M="model"),this.modelJsonFileName=M+".json",this.weightDataFileName=M+".weights.bin"}save(M){var L=this;return(0,ct.Z)(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const H=window.URL.createObjectURL(new Blob([M.weightData],{type:"application/octet-stream"}));if(M.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const me=we(M,[{paths:["./"+L.weightDataFileName],weights:M.weightSpecs}]),Te=window.URL.createObjectURL(new Blob([JSON.stringify(me)],{type:"application/json"})),Xe=null==L.modelJsonAnchor?document.createElement("a"):L.modelJsonAnchor;if(Xe.download=L.modelJsonFileName,Xe.href=Te,yield ii(()=>Xe.dispatchEvent(new MouseEvent("click"))),null!=M.weightData){const Ze=null==L.weightDataAnchor?document.createElement("a"):L.weightDataAnchor;Ze.download=L.weightDataFileName,Ze.href=H,yield ii(()=>Ze.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Kt(M)}}})()}}return R.URL_SCHEME="downloads://",R})();class xr{constructor(x){if(null==x||x.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${x}`);this.jsonFile=x[0],this.weightsFiles=x.slice(1)}load(){var x=this;return(0,ct.Z)(function*(){return new Promise((M,L)=>{const H=new FileReader;H.onload=oe=>{const me=JSON.parse(oe.target.result),Te=me.modelTopology;if(null==Te)return void L(new Error(`modelTopology field is missing from file ${x.jsonFile.name}`));if(null==me.weightsManifest)return void L(new Error(`weightManifest field is missing from file ${x.jsonFile.name}`));if(0===x.weightsFiles.length)return void M({modelTopology:Te});const Ze=At(me,St=>x.loadWeights(St));M(Ze)},H.onerror=oe=>L(`Failed to read model topology and weights manifest JSON from file '${x.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),H.readAsText(x.jsonFile)})})()}loadWeights(x){const M=[],L=[];for(const me of x)M.push(...me.weights),L.push(...me.paths);const H=this.checkManifestAndWeightFiles(x),oe=L.map(me=>this.loadWeightsFile(me,H[me]));return Promise.all(oe).then(me=>[M,Me(me)])}loadWeightsFile(x,M){return new Promise((L,H)=>{const oe=new FileReader;oe.onload=me=>{L(me.target.result)},oe.onerror=me=>H(`Failed to weights data from file of path '${x}'.`),oe.readAsArrayBuffer(M)})}checkManifestAndWeightFiles(x){const M=[],L=this.weightsFiles.map(oe=>ke(oe.name)),H={};for(const oe of x)oe.paths.forEach(me=>{const Te=ke(me);if(-1!==M.indexOf(Te))throw new Error(`Duplicate file basename found in weights manifest: '${Te}'`);if(M.push(Te),-1===L.indexOf(Te))throw new Error(`Weight file with basename '${Te}' is not provided.`);H[me]=this.weightsFiles[L.indexOf(Te)]});if(M.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${M.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return H}}function Ra(R){return new xr(R)}cn.registerSaveRouter(R=>(0,ot.OB)().getBool("IS_BROWSER")&&!Array.isArray(R)&&R.startsWith(Vo.URL_SCHEME)?function Vs(R="model"){return new Vo(R)}(R.slice(Vo.URL_SCHEME.length)):null);var gn=O(8813);class ai{constructor(x){if(this.shards=[],this.previousShardIndex=0,x instanceof Array||(x=[x]),0===(x=x.map(L=>gn.isTypedArray(L)?L.buffer:L)).length)return;this.bufferUniformSize=x[0].byteLength;let M=0;for(let L=0;L<x.length;L++){const H=x[L];L!==x.length-1&&H.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const oe=M+H.byteLength;this.shards.push({buffer:H,start:M,end:oe}),M=oe}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(x=0,M=this.byteLength){if(x=isNaN(Number(x))?0:x,M=isNaN(Number(M))?0:M,x=Math.max(0,x),(M=Math.min(this.byteLength,M))<=x)return new ArrayBuffer(0);const L=this.findShardForByte(x);if(-1===L)throw new Error(`Could not find start shard for byte ${x}`);const oe=new ArrayBuffer(M-x),me=new Uint8Array(oe);let Te=0;for(let Xe=L;Xe<this.shards.length;Xe++){const Ze=this.shards[Xe],Qe=x+Te-Ze.start,Je=Te,zt=Math.min(M,Ze.end)-Ze.start,Jt=new Uint8Array(Ze.buffer.slice(Qe,zt));if(me.set(Jt,Je),Te+=Jt.length,M<Ze.end)break}return oe}findShardForByte(x){if(0===this.shards.length||x<0||x>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(x/this.bufferUniformSize),this.previousShardIndex;function M(H){return x<H.start?-1:x>=H.end?1:0}if(0===M(this.shards[this.previousShardIndex]))return this.previousShardIndex;const L=function ea(R,x){let M=0,L=R.length;for(;M<=L;){const H=Math.floor((L-M)/2)+M,oe=x(R[H]);if(0===oe)return H;oe<0?L=H:M=H+1}return-1}(this.shards,M);return-1===L?-1:(this.previousShardIndex=L,this.previousShardIndex)}}function Kn(R,x,M,L){(function me(Xe){(0,Be.hu)(null!=Xe&&Array.isArray(Xe)&&Xe.length>0,()=>"promises must be a none empty array")})(R),function Te(Xe,Ze){(0,Be.hu)(Xe>=0&&Xe<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${Xe}`),(0,Be.hu)(Ze>=0&&Ze<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${Ze}`),(0,Be.hu)(Ze>=Xe,()=>`startFraction must be no more than endFraction, but got startFraction ${Xe} and endFraction ${Ze}`)}(M=M??0,L=L??1);let H=0;return Promise.all(R.map(Xe=>(Xe.then(Ze=>{const St=M+ ++H/R.length*(L-M);return x(St),Ze}),Xe)))}function ml(R,x){return Uo.apply(this,arguments)}function Uo(){return(Uo=(0,ct.Z)(function*(R,x){null==x&&(x={});const M=null==x.fetchFunc?(0,ot.OB)().platform.fetch:x.fetchFunc,L=R.map(Qe=>M(Qe,x.requestInit,{isBinary:!0})),Te=(null==x.onProgress?yield Promise.all(L):yield Kn(L,x.onProgress,0,.5)).map(Qe=>Qe.arrayBuffer());return null==x.onProgress?yield Promise.all(Te):yield Kn(Te,x.onProgress,.5,1)})).apply(this,arguments)}function ta(R){return li.apply(this,arguments)}function li(){return(li=(0,ct.Z)(function*(R,x="",M,L){return gl(me=>ml(me,{requestInit:L}))(R,x,M)})).apply(this,arguments)}function gl(R){return function(){var x=(0,ct.Z)(function*(M,L="",H){const oe=M.map(()=>!1),me={},Te=null!=H?H.map(()=>!1):[],Xe=[];if(M.forEach((zt,Jt)=>{let bn=0;zt.weights.forEach(Xn=>{const Zt=Q["quantization"in Xn?Xn.quantization.dtype:Xn.dtype]*Be.NA(Xn.shape),is=()=>{oe[Jt]=!0,null==me[Jt]&&(me[Jt]=[]),me[Jt].push({manifestEntry:Xn,groupOffset:bn,sizeBytes:Zt})};null!=H?H.forEach((as,fu)=>{as===Xn.name&&(is(),Te[fu]=!0)}):is(),Xe.push(Xn.name),bn+=Zt})}),!Te.every(zt=>zt)){const zt=H.filter((Jt,bn)=>!Te[bn]);throw new Error(`Could not find weights in manifest with names: ${zt.join(", ")}. \nManifest JSON has weights with names: ${Xe.join(", ")}.`)}const Ze=oe.reduce((zt,Jt,bn)=>(Jt&&zt.push(bn),zt),[]),St=[];Ze.forEach(zt=>{M[zt].paths.forEach(Jt=>{const bn=L+(L.endsWith("/")?"":"/")+Jt;St.push(bn)})});const Qe=yield R(St),Je={};let Nt=0;return Ze.forEach(zt=>{const Jt=M[zt].paths.length,bn=new ai(Qe.slice(Nt,Nt+Jt));me[zt].forEach(os=>{const is=he(bn.slice(os.groupOffset,os.groupOffset+os.sizeBytes),[os.manifestEntry]);for(const as in is)Je[as]=is[as]}),Nt+=Jt}),Je});return function(M){return x.apply(this,arguments)}}()}let E=(()=>{class R{constructor(M,L){if(this.DEFAULT_METHOD="POST",null==L&&(L={}),this.weightPathPrefix=L.weightPathPrefix,this.onProgress=L.onProgress,this.weightUrlConverter=L.weightUrlConverter,null!=L.fetchFunc?((0,Be.hu)("function"==typeof L.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=L.fetchFunc):this.fetch=(0,ot.OB)().platform.fetch,(0,Be.hu)(null!=M&&M.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(M)&&(0,Be.hu)(2===M.length,()=>`URL paths for http must have a length of 2, (actual length is ${M.length}).`),this.path=M,null!=L.requestInit&&null!=L.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=L.requestInit||{}}save(M){var L=this;return(0,ct.Z)(function*(){if(M.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const H=Object.assign({method:L.DEFAULT_METHOD},L.requestInit);H.body=new FormData;const me=we(M,[{paths:["./model.weights.bin"],weights:M.weightSpecs}]);H.body.append("model.json",new Blob([JSON.stringify(me)],{type:"application/json"}),"model.json"),null!=M.weightData&&H.body.append("model.weights.bin",new Blob([M.weightData],{type:"application/octet-stream"}),"model.weights.bin");const Te=yield L.fetch(L.path,H);if(Te.ok)return{modelArtifactsInfo:Kt(M),responses:[Te]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${Te.status}.`)})()}load(){var M=this;return(0,ct.Z)(function*(){const L=yield M.fetch(M.path,M.requestInit);if(!L.ok)throw new Error(`Request to ${M.path} failed with status code ${L.status}. Please verify this URL points to the model JSON of the model to load.`);let H;try{H=yield L.json()}catch{let Xe=`Failed to parse model JSON of response from ${M.path}.`;throw M.path.endsWith(".pb")?Xe+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":Xe+=" Please make sure the server is serving valid JSON for this request.",new Error(Xe)}if(null==H.modelTopology&&null==H.weightsManifest)throw new Error(`The JSON from HTTP path ${M.path} contains neither model topology or manifest for weights.`);return At(H,Te=>M.loadWeights(Te))})()}loadWeights(M){var L=this;return(0,ct.Z)(function*(){const H=Array.isArray(L.path)?L.path[1]:L.path,[oe,me]=function f(R){const x=R.lastIndexOf("/"),M=R.lastIndexOf("?");return[R.substring(0,x)+"/",M>x?R.substring(M):""]}(H),Te=L.weightPathPrefix||oe,Xe=dn(M),Ze=[],St=[];for(const Je of M)for(const Nt of Je.paths)null!=L.weightUrlConverter?St.push(L.weightUrlConverter(Nt)):Ze.push(Te+Nt+me);return L.weightUrlConverter&&Ze.push(...yield Promise.all(St)),[Xe,Me(yield ml(Ze,{requestInit:L.requestInit,fetchFunc:L.fetch,onProgress:L.onProgress}))]})()}}return R.URL_SCHEME_REGEX=/^https?:\/\//,R})();function g(R){return null!=R.match(E.URL_SCHEME_REGEX)}const b=(R,x)=>{if(typeof fetch>"u"&&(null==x||null==x.fetchFunc))return null;{let M=!0;if(M=Array.isArray(R)?R.every(L=>g(L)):g(R),M)return z(R,x)}return null};function z(R,x){return new E(R,x)}function B(R,x){return z(R,x)}cn.registerSaveRouter(b),cn.registerLoadRouter(b);class ne{constructor(x){this.modelArtifacts=x}load(){return this.modelArtifacts}}class J{constructor(x){this.saveHandler=x}save(x){return this.saveHandler(x)}}class Ie{constructor(x){x.load&&(this.load=()=>Promise.resolve(x.load())),x.save&&(this.save=M=>Promise.resolve(x.save(M)))}}function ht(R,x,M,L){return new Ie(dt(...arguments))}function dt(R,x,M,L){return 1===arguments.length?null!=R.modelTopology||null!=R.weightSpecs?new ne(R):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ne({modelTopology:R})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ne({modelTopology:R,weightSpecs:x,weightData:M,trainingConfig:L}))}function xt(R){return new J(R)}function Tt(R){return new J(R)}var Gt=O(9608),ln=O(341),Dt=O(2738),$t=O(6721),pn=O(9540);const Us=(0,$t.op)({confusionMatrix_:function Vn(R,x,M){const L=(0,Gt._1)(R,"labels","confusionMatrix"),H=(0,Gt._1)(x,"predictions","confusionMatrix");Be.hu(null==M||M>0&&Number.isInteger(M),()=>`If provided, numClasses must be a positive integer, but got ${M}`),Be.hu(1===L.rank,()=>`Expected the rank of labels to be 1, but got ${L.rank}`),Be.hu(1===H.rank,()=>`Expected the rank of predictions to be 1, but got ${H.rank}`),Be.hu(L.shape[0]===H.shape[0],()=>`Mismatch in the number of examples: ${L.shape[0]} vs. ${H.shape[0]}. Labels and predictions should have the same number of elements.`),Be.hu(M>0&&Number.isInteger(M),()=>`numClasses is required to be a positive integer, but got ${M}`);const oe=(0,Dt.l)((0,Lo.p)(L,"int32"),M),me=(0,Dt.l)((0,Lo.p)(H,"int32"),M),Te=(0,pn.p)(oe),Xe=(0,ln.O)(Te,me);return(0,Lo.p)(Xe,"int32")}});var Is=O(258),be=O(1070),ms=O(9464),Oa=O(3157);let Co;function Ii(R,x=3){if(x>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==R)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let M=!1,L=!1,H=!1,oe=!1,me=!1,Te=!1;if(R.data instanceof Uint8Array)M=!0;else if(typeof ImageData<"u"&&R instanceof ImageData)L=!0;else if(typeof HTMLVideoElement<"u"&&R instanceof HTMLVideoElement)H=!0;else if(typeof HTMLImageElement<"u"&&R instanceof HTMLImageElement)oe=!0;else if(null!=R.getContext)me=!0;else{if(!(typeof ImageBitmap<"u"&&R instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${R.constructor.name}`);Te=!0}if(null!=(0,ms.pI)(be.eBW,I.BV.backendName))return I.BV.runKernel(be.eBW,{pixels:R},{numChannels:x});const[Ze,St]=H?[R.videoWidth,R.videoHeight]:[R.width,R.height];let Qe,Je;if(me)Qe=R.getContext("2d").getImageData(0,0,Ze,St).data;else if(L||M)Qe=R.data;else if(oe||H||Te){if(null==Co)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Co=new OffscreenCanvas(1,1).getContext("2d")}else Co=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Co.canvas.width=Ze,Co.canvas.height=St,Co.drawImage(R,0,0,Ze,St),Qe=Co.getImageData(0,0,Ze,St).data}if(4===x)Je=new Int32Array(Qe);else{const zt=Ze*St;Je=new Int32Array(zt*x);for(let Jt=0;Jt<zt;Jt++)for(let bn=0;bn<x;++bn)Je[Jt*x+bn]=Qe[4*Jt+bn]}return(0,Oa.w)(Je,[St,Ze,x],"int32")}function Lh(R){return nc.apply(this,arguments)}function nc(){return(nc=(0,ct.Z)(function*(R,x=3){let M=null;if((0,ot.OB)().getBool("WRAP_TO_IMAGEBITMAP")&&function $h(R){return function tc(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}()&&!(R instanceof ImageBitmap)&&function tu(R){return null!=R&&0!==R.width&&0!==R.height}(R)&&!function yl(R){return null!=R&&R.data instanceof Uint8Array}(R)}(R)){let L;try{L=yield createImageBitmap(R,{premultiplyAlpha:"none"})}catch{L=null}M=null!=L&&L.width===R.width&&L.height===R.height?L:R}else M=R;return Ii(M,x)})).apply(this,arguments)}function Fa(R,x){return na.apply(this,arguments)}function na(){return(na=(0,ct.Z)(function*(R,x){let M=(0,Gt._1)(R,"img","toPixels");if(!(R instanceof $s.es)){const Ze=M;M=(0,Lo.p)(Ze,"int32"),Ze.dispose()}if(2!==M.rank&&3!==M.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${M.rank}.`);const[L,H]=M.shape.slice(0,2),oe=2===M.rank?1:M.shape[2];if(oe>4||2===oe)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${oe}`);if("float32"!==M.dtype&&"int32"!==M.dtype)throw new Error(`Unsupported type for toPixels: ${M.dtype}. Please use float32 or int32 tensors.`);const me=yield M.data(),Te="float32"===M.dtype?255:1,Xe=new Uint8ClampedArray(H*L*4);for(let Ze=0;Ze<L*H;++Ze){const St=[0,0,0,255];for(let Je=0;Je<oe;Je++){const Nt=me[Ze*oe+Je];if("float32"===M.dtype){if(Nt<0||Nt>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${Nt}.`)}else if("int32"===M.dtype&&(Nt<0||Nt>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${Nt}.`);1===oe?(St[0]=Nt*Te,St[1]=Nt*Te,St[2]=Nt*Te):St[Je]=Nt*Te}const Qe=4*Ze;Xe[Qe+0]=Math.round(St[0]),Xe[Qe+1]=Math.round(St[1]),Xe[Qe+2]=Math.round(St[2]),Xe[Qe+3]=Math.round(St[3])}if(null!=x){x.width=H,x.height=L;const Ze=x.getContext("2d"),St=new ImageData(Xe,H,L);Ze.putImageData(St,0,0)}return M!==R&&M.dispose(),Xe})).apply(this,arguments)}const Ai=(0,$t.op)({fromPixels_:Ii});function nu(R,x){const M=R.shape.length,L=x.shape.length;if(M<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${M}.`);if(L<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${L}.`);if("int32"!==x.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${x.dtype}.`);if(x.shape[L-1]>M)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${x.shape[L-1]} vs. ${M}`);if(0===(0,Be.NA)(R.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${R.shape}.`);const H=x.shape,oe=H[H.length-1];let me=1;for(let Qe=0;Qe<H.length-1;++Qe)me*=H[Qe];const Te=R.shape,Xe=H.slice();Xe.pop();let Ze=1;for(let Qe=oe;Qe<M;++Qe)Ze*=Te[Qe],Xe.push(Te[Qe]);const St=[...(0,Be.e3)(R.shape).map(Qe=>Qe/Ze),1].slice(0,oe);return[Xe,me,Ze,St]}var Ke=O(2808);const no=-2,Ft=-1;function bl(R,x,M){const L=R.shape.length;Be.hu(L===x.length,()=>`Error in slice${L}D: Length of begin ${x} must match the rank of the array (${L}).`),Be.hu(L===M.length,()=>`Error in slice${L}D: Length of size ${M} must match the rank of the array (${L}).`);for(let H=0;H<L;++H)Be.hu(x[H]+M[H]<=R.shape[H],()=>`Error in slice${L}D: begin[${H}] + size[${H}] (${x[H]+M[H]}) would overflow input.shape[${H}] (${R.shape[H]})`)}function ru(R){const x=[];let M=0;for(;R>0;)1&R&&x.push(M),R/=2,M++;return x}function _l(R,x,M){const L=[];for(let H=0;H<R.length;H++)L[H]=Math.ceil((x[H]-R[H])/M[H]);return L}function Un(R,x,M,L){const H=[...R];for(let oe=H.length;oe<L.length;oe++)H.push(1);for(let oe=0;oe<M;oe++)0===oe?H[x]=1:(H.splice(x,0,1),H.pop());return H}function nd(R,x,M){return M<=R?M:M-(x-1)}function rd(R,x){const M=[];for(let L=0;L<R;L++)M.push(x+L);return M}function ci(R,x,M,L,H,oe,me,Te,Xe){const Ze=R.length;let St=new Array(Ze),Qe=new Array(Ze),Je=new Array(Ze);if(x.length&&M>0){const Nt=x[0],zt=M+1;St=ro(me,Nt,zt,L,R),Qe=gs(Te,Nt,zt,H,R),Je=Un(oe,Nt,zt,R)}else for(let Nt=0;Nt<Ze;Nt++)St[Nt]=zn(me,L,oe,R,Nt,Xe),Qe[Nt]=Pa(Te,H,oe,R,Nt,Xe),Je[Nt]=zs(oe,Nt,Xe);return{begin:St,end:Qe,strides:Je}}function ro(R,x,M,L,H){const oe=[...H],me=rd(M,x);for(let Te=0;Te<oe.length;Te++)if(me.indexOf(Te)>-1)oe[Te]=0;else{const Xe=nd(x,M,Te);let Ze=L[Xe];R&1<<Xe&&(Ze=0),oe[Te]=Ze}return oe}function gs(R,x,M,L,H){const oe=[...H],me=rd(M,x);for(let Te=0;Te<oe.length;Te++)if(me.indexOf(Te)>-1)oe[Te]=Number.MAX_SAFE_INTEGER;else{const Xe=nd(x,M,Te);let Ze=L[Xe];R&1<<Xe&&(Ze=Number.MAX_SAFE_INTEGER),oe[Te]=Ze}for(let Te=0;Te<oe.length;Te++)oe[Te]<0&&(oe[Te]+=H[Te]),oe[Te]=Be.uZ(0,oe[Te],H[Te]);return oe}function zs(R,x,M){let L=R[x];return(M&1<<x||null==L)&&(L=1),L}function zn(R,x,M,L,H,oe){let me=x[H];(R&1<<H||oe&1<<H||null==me)&&(me=(M[H]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const Xe=L[H];return me<0&&(me+=Xe),me=Be.uZ(0,me,Xe-1),me}function Pa(R,x,M,L,H,oe){let me=x[H];const Te=M[H]||1;(R&1<<H||oe&1<<H||null==me)&&(me=Te>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const Xe=L[H];return me<0&&(me+=Xe),me=Te>0?Be.uZ(0,me,Xe):Be.uZ(-1,me,Xe-1),me}function su(R,x,M){let L=M.length;for(let H=0;H<M.length;H++)if(M[H]>1){L=H;break}for(let H=L+1;H<M.length;H++)if(x[H]>0||M[H]!==R[H])return!1;return!0}function rc(R,x){let M=R.length>0?R[R.length-1]:1;for(let L=0;L<R.length-1;L++)M+=R[L]*x[L];return M}function sd(R,x,M){let L;const H=R.shape.length;let oe;return L="number"==typeof x?[x,...new Array(H-1).fill(0)]:x.length<H?x.concat(new Array(H-x.length).fill(0)):x.slice(),L.forEach(me=>{Be.hu(-1!==me,()=>"slice() does not support negative begin indexing.")}),oe=null==M?new Array(H).fill(-1):"number"==typeof M?[M,...new Array(H-1).fill(-1)]:M.length<H?M.concat(new Array(H-M.length).fill(-1)):M,oe=oe.map((me,Te)=>me>=0?me:(Be.hu(-1===me,()=>`Negative size values should be exactly -1 but got ${me} for the slice() size at index ${Te}.`),R.shape[Te]-L[Te])),[L,oe]}function ui(R,x,M,L,H,oe,me,Te,Xe){let Ze;if(null==L?(Ze=new Array(x.length),Ze.fill(1)):Ze=L,null!=me&&me&me-1)throw new Error("Multiple ellipses in slice is not allowed.");let St=!1;const Qe={dims:Ze.length,numAddAxisAfterEllipsis:0,begin:x.slice(),end:M.slice(),strides:Ze.slice(),beginMask:H,endMask:oe,ellipsisMask:me,newAxisMask:Te,shrinkAxisMask:Xe};for(let Zt=0;Zt<Qe.dims;Zt++)St&&1<<Zt&Te&&Qe.numAddAxisAfterEllipsis++,1<<Zt&me&&(St=!0);St||(Qe.ellipsisMask|=1<<Qe.dims,Qe.dims++);const Je={dims:R.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function Ni(R,x){x.beginMask=0,x.endMask=0,x.shrinkAxisMask=0;let M=0;x.beginValid=null!=R.begin,x.endValid=null!=R.end,x.begin=new Array(x.dims),x.end=new Array(x.dims),x.strides=new Array(x.dims),x.finalShapeGatherIndices=[],x.finalShapeGatherIndicesSparse=[],x.inputShapeGatherIndicesSparse=new Array(x.dims);for(let L=0;L<R.dims;L++)if(1<<L&R.ellipsisMask){const H=Math.min(x.dims-(R.dims-L)+1+R.numAddAxisAfterEllipsis,x.dims);for(;M<H;M++)x.begin[M]=0,x.end[M]=0,x.strides[M]=1,x.beginMask|=1<<M,x.endMask|=1<<M,x.finalShapeGatherIndices.push(M),x.finalShapeGatherIndicesSparse.push(-1),x.inputShapeGatherIndicesSparse[M]=L}else if(1<<L&R.newAxisMask)x.finalShapeGatherIndices.push(no),x.finalShapeGatherIndicesSparse.push(-1);else{if(M===x.begin.length)throw Error(`Index out of range using input dim ${M}; input has only ${x.dims} dims, ${x.begin.length}.`);null!=R.begin&&(x.begin[M]=R.begin[L]),null!=R.end&&(x.end[M]=R.end[L]),x.strides[M]=R.strides[L],R.beginMask&1<<L&&(x.beginMask|=1<<M),R.endMask&1<<L&&(x.endMask|=1<<M),R.shrinkAxisMask&1<<L?(x.finalShapeGatherIndices.push(Ft),x.finalShapeGatherIndicesSparse.push(-1),x.shrinkAxisMask|=1<<M):(x.finalShapeGatherIndices.push(M),x.finalShapeGatherIndicesSparse.push(L)),x.inputShapeGatherIndicesSparse[M]=L,M++}}(Qe,Je);let Nt=!0,zt=!0,Jt=!0;const bn=[],Xn=[];for(let Zt=0;Zt<R.length;++Zt){if(0===Je.strides[Zt])throw Error(`strides[${Zt}] must be non-zero`);const is=!!(Je.shrinkAxisMask&1<<Zt),as=R[Zt];if(-1===as){bn.push(is?1:-1);continue}const fu=[Je.beginMask&1<<Zt,Je.endMask&1<<Zt],pd=[Je.strides[Zt]>0?0:-1,Je.strides[Zt]>0?as:as-1];if(is&&Je.strides[Zt]<=0)throw Error("only stride 1 allowed on non-range indexing.");Jt=Jt&&1===Je.strides[Zt];const io=!!(Je.beginMask&1<<Zt&&Je.endMask&1<<Zt);if(Je.beginValid&&Je.endValid){if(is){const fd=Je.begin[Zt]<0?as+Je.begin[Zt]:Je.begin[Zt];if(Je.begin[Zt]=fd,Je.end[Zt]=Je.begin[Zt]+1,fd<0||fd>=as)throw Error(`slice index ${Je.begin[Zt]} of dimension ${Zt} out of bounds.`)}else Je.begin[Zt]=ou(Je.begin[Zt],0,Je.strides[Zt],as,fu,pd),Je.end[Zt]=ou(Je.end[Zt],1,Je.strides[Zt],as,fu,pd);const ca=1===Je.strides[Zt]&&0===Je.begin[Zt]&&Je.end[Zt]===as;Nt=Nt&&ca,zt=zt&&(0===Zt&&1===Je.strides[Zt]||ca)}else Nt=Nt&&1===Je.strides[Zt]&&io,zt=zt&&(0===Zt&&1===Je.strides[Zt]||io);let To,Tr=!1;if(Je.beginValid&&Je.endValid?(To=Je.end[Zt]-Je.begin[Zt],Tr=!0):is?(To=1,Tr=!0):io&&as>=0&&(To=Je.strides[Zt]<0?-as:as,Tr=!0),Tr){let ca;ca=0===To||To<0!=Je.strides[Zt]<0?0:Math.trunc(To/Je.strides[Zt])+(To%Je.strides[Zt]!=0?1:0),bn.push(ca)}else bn.push(-1)}for(let Zt=0;Zt<Je.finalShapeGatherIndices.length;++Zt){const is=Je.finalShapeGatherIndices[Zt];is>=0?Xn.push(bn[is]):is===no&&Xn.push(1)}return{finalShapeSparse:Xn.filter((Zt,is)=>Je.finalShapeGatherIndices[is]!==no),finalShape:Xn,isIdentity:Nt,sliceDim0:zt,isSimpleSlice:Jt,begin:Je.begin,end:Je.end,strides:Je.strides}}function ou(R,x,M,L,H,oe){if(H[x])return M>0?oe[x]:oe[x+1&1];{const me=R<0?L+R:R;return me<oe[0]?oe[0]:me>oe[1]?oe[1]:me}}var sc=O(7904);const iu=.001,au=.1;function lu(R,x,M){return null==M&&(M=ra()),oc(R,x,(L,H)=>cu(L,H,M))}function ra(){return 32===I.BV.backend.floatPrecision()?iu:au}function oc(R,x,M){let L=!0;if(((0,gn.isTypedArray)(R)||(0,gn.isTypedArray)(x))&&(L=!1),(0,gn.isTypedArray)(R)&&(0,gn.isTypedArray)(x)&&(L=!0),L){const me=R.constructor.name,Te=x.constructor.name;if(me!==Te)throw new Error(`Arrays are of different type. Actual: ${me}. Expected: ${Te}`)}if(Array.isArray(R)&&Array.isArray(x)){const me=(0,Gt.C)(R),Te=(0,Gt.C)(x);if(!(0,Be.cO)(me,Te))throw new Error(`Arrays have different shapes. Actual: [${me}]. Expected: [${Te}]`)}const H=(0,gn.isTypedArray)(R)?R:(0,gn.flatten)(R),oe=(0,gn.isTypedArray)(x)?x:(0,gn.flatten)(x);if(H.length!==oe.length)throw new Error(`Arrays have different lengths actual: ${H.length} vs expected: ${oe.length}.\nActual:   ${H}.\nExpected: ${oe}.`);for(let me=0;me<oe.length;++me){const Te=H[me],Xe=oe[me];if(!M(Te,Xe))throw new Error(`Arrays differ: actual[${me}] = ${Te}, expected[${me}] = ${Xe}.\nActual:   ${H}.\nExpected: ${oe}.`)}typeof expect<"u"&&expect().nothing()}function od(R,x){R().then(()=>x.fail(),()=>x()),typeof expect<"u"&&expect().nothing()}function Bh(R,x){const M="string"==typeof x||"number"==typeof x||"boolean"==typeof x?[x]:x;return(0,Be.HD)(R)||(0,Be.HD)(R[0])||(0,Be.HD)(x)||(0,Be.HD)(x[0])?oc(R,M,(L,H)=>L==H):oc(R,x,(L,H)=>cu(L,H,0))}function id(R,x,M){if(null==M&&(M=ra()),!cu(R,x,M))throw new Error(`Numbers differ: actual === ${R}, expected === ${x}`);typeof expect<"u"&&expect().nothing()}function cu(R,x,M){return!isFinite(R)&&!isFinite(x)||!(isNaN(R)||isNaN(x)||Math.abs(R-x)>M)}function ic(R,x,M){for(let L=0;L<R.length;L++)if(R[L]<x||R[L]>M)throw new Error(`Value out of range:${R[L]} low: ${x}, high: ${M}`)}function ns(R,x){const M=new Float32Array(R),L=new Float32Array(x);if(M.length!==L.length)throw new Error(`Expected ArrayBuffer to be of length ${L.length}, but it was ${M.length}`);for(let H=0;H<L.length;H++)if(M[H]!==L[H])throw new Error(`Expected ArrayBuffer value at ${H} to be ${L[H]} but got ${M[H]} instead`)}function ki(R){for(let x=0;x<R.length;x++){const M=R[x];Array.isArray(M)?ki(M):R[x]=(0,gn.encodeString)(M)}return R}function $a(R){const x=document.createElement("video");return"playsInline"in x&&(x.playsInline=!0),x.muted=!0,x.loop=!0,x.style.position="fixed",x.style.left="0px",x.style.top="0px",x.preload="auto",x.appendChild(R),new Promise(M=>{x.addEventListener("loadeddata",L=>M(x)),x.load()})}function Vh(R){return uu.apply(this,arguments)}function uu(){return(uu=(0,ct.Z)(function*(R){yield R.play(),"requestVideoFrameCallback"in R&&(yield new Promise(x=>{R.requestVideoFrameCallback(x)}))})).apply(this,arguments)}const ac="4.5.0";class ad{static sgd(x){return new Ma(x)}static momentum(x,M,L=!1){return new si(x,M,L)}static rmsprop(x,M=.9,L=0,H=null,oe=!1){return new qe(x,M,L,H,oe)}static adam(x=.001,M=.9,L=.999,H=null){return new Fn(x,M,L,H)}static adadelta(x=.001,M=.95,L=null){return new on(x,M,L)}static adamax(x=.002,M=.9,L=.999,H=null,oe=0){return new ri(x,M,L,H,oe)}static adagrad(x,M=.1){return new Jn(x,M)}}var vl=O(7770),De=O(3809),Uh=O(4761);const zh=ad,ys=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:R=>R();function Hh(){return new Promise(R=>ys(()=>R()))}var Mi=O(7745);function Wh(R,x){const M=R[0].length;R.forEach((H,oe)=>{Be.hu(H.length===M,()=>`Error in concat${M}D: rank of tensors[${oe}] must be the same as the rank of the rest (${M})`)}),Be.hu(x>=0&&x<M,()=>`Error in concat${M}D: axis must be between 0 and ${M-1}.`);const L=R[0];R.forEach((H,oe)=>{for(let me=0;me<M;me++)Be.hu(me===x||H[me]===L[me],()=>`Error in concat${M}D: Shape of tensors[${oe}] (${H}) does not match the shape of the rest (${L}) along the non-concatenated axis ${oe}.`)})}function Zn(R,x){const M=R[0].slice();for(let L=1;L<R.length;L++)M[x]+=R[L][x];return M}var wo=O(744),La=O(8868),It=(()=>((It=It||{})[It.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",It[It.VALUE_ROWIDS=1]="VALUE_ROWIDS",It[It.ROW_LENGTHS=2]="ROW_LENGTHS",It[It.ROW_SPLITS=3]="ROW_SPLITS",It[It.ROW_LIMITS=4]="ROW_LIMITS",It[It.ROW_STARTS=5]="ROW_STARTS",It))();function As(R,x,M){let L=new Array;if(null==M&&null==x)return L;if(null==x)for(;L.length<R+M.length;)L.push(-1);else L=x.slice();if(null==M)return L;if(R+M.length!==L.length)throw new Error(`rt input.shape and shape=${x} are incompatible: rt input.rank = ${R+M.length}, but shape.rank = ${L.length}`);for(let H=1;H<M.length;++H){const oe=M[H],me=L[L.length-M.length+H],Te=L[me];if(oe>=0)if(Te>=0){if(Te!==oe)throw new Error(`rt input.shape and shape=${x} are incompatible: rt input.shape[${H+R}] = ${oe} but shape[${H+R}] = ${Te}`)}else L[me]=oe}return L}function jn(R){const x={FIRST_DIM_SIZE:It.FIRST_DIM_SIZE,VALUE_ROWIDS:It.VALUE_ROWIDS,ROW_LENGTHS:It.ROW_LENGTHS,ROW_SPLITS:It.ROW_SPLITS,ROW_LIMITS:It.ROW_LIMITS,ROW_STARTS:It.ROW_STARTS},M=[];for(const L of R){if(!(L in x))break;M.push(x[L])}return M}function rs(R){return 0===R.length?0:R[0]===It.FIRST_DIM_SIZE?R.length-1:R.length}function Ns(R,x){if(null==R||null==x)return;const M=R.length,L=x.length;if(M>=L)throw new Error(`defaultValue.shape=${R} and ragged tensor flatValues.shape=${x}, are incompatible: defaultValue.rank = ${M} must be less than ragged tensor input flatValues.rank = ${L})`);for(let H=0;H<Math.min(M,L-1);++H){const oe=R[H],me=x[H+1];if(oe>=0&&me>=0&&1!==oe&&oe!==me)throw new Error(`defaultValue.shape=${R}, and ragged tensor input flatValues.shape=${x} are incompatible: defaultValue.shape[${H-R.length}] = ${oe} but ragged tensor input.flatValues.shape[${H-R.length}] = ${me}`)}}const Ri=30;function Gr(R){return R<=Ri?R:(0,Be.jP)(R,Math.floor(Math.sqrt(R)))}function ld(R,x,M){return[M*("number"==typeof R?R:R[0]),x*("number"==typeof R?R:R[1])]}function cd(R,x,M,L=!0){let H=[];if(L)H=H.concat(x.slice(0)),H.push(R[0]/M),H=H.concat(R.slice(1));else{H=H.concat(R[0]);const oe=x.length;for(let me=0;me<oe;++me)H=H.concat([R[me+1]/x[me],x[me]]);H=H.concat(R.slice(oe+1))}return H}function lc(R,x,M=!0){const L=[];if(M){L.push(x);for(let H=x+1;H<R;++H)H<=2*x?(L.push(H),L.push(H-(x+1))):L.push(H)}else{const H=[],oe=[];for(let me=1;me<R;++me)me>=2*x+1||me%2==1?oe.push(me):H.push(me);L.push(...H),L.push(0),L.push(...oe)}return L}function jh(R,x,M,L=!0){const H=[];H.push(L?R[0]/M:R[0]*M);for(let oe=1;oe<R.length;++oe)H.push(oe<=x.length?L?x[oe-1]*R[oe]:R[oe]/x[oe-1]:R[oe]);return H}function Gh(R,x){const M=[0];for(let L=0;L<x;++L)M.push(R[L][0]);return M}function Pr(R,x,M){const L=R.slice(0,1);for(let H=0;H<M;++H)L.push(R[H+1]-x[H][0]-x[H][1]);return L}const Bt=1.7580993408473768,vn=1.0507009873554805,fr=.3275911,so=.254829592,sa=-.284496736,ss=1.421413741,Ba=-1.453152027,Cr=1.061405429;var oa=O(5686);function ia(R,x){if(R.length!==x.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${R.length}, imag: ${x.length}.`);const M=new Float32Array(2*R.length);for(let L=0;L<M.length;L+=2)M[L]=R[L/2],M[L+1]=x[L/2];return M}function yn(R){const x=new Float32Array(R.length/2),M=new Float32Array(R.length/2);for(let L=0;L<R.length;L+=2)x[L/2]=R[L],M[L/2]=R[L+1];return{real:x,imag:M}}function xl(R){const x=Math.ceil(R.length/4),M=new Float32Array(x),L=new Float32Array(x);for(let H=0;H<R.length;H+=4)M[Math.floor(H/4)]=R[H],L[Math.floor(H/4)]=R[H+1];return{real:M,imag:L}}function ud(R){const x=Math.floor(R.length/4),M=new Float32Array(x),L=new Float32Array(x);for(let H=2;H<R.length;H+=4)M[Math.floor(H/4)]=R[H],L[Math.floor(H/4)]=R[H+1];return{real:M,imag:L}}function Va(R,x){return{real:R[2*x],imag:R[2*x+1]}}function Rr(R,x,M,L){R[2*L]=x,R[2*L+1]=M}function Cl(R,x){const M=new Float32Array(R/2),L=new Float32Array(R/2);for(let H=0;H<Math.ceil(R/2);H++){const oe=(x?2:-2)*Math.PI*(H/R);M[H]=Math.cos(oe),L[H]=Math.sin(oe)}return{real:M,imag:L}}function Ua(R,x,M){const L=(M?2:-2)*Math.PI*(R/x);return{real:Math.cos(L),imag:Math.sin(L)}}const oo="->",wl=/->/g,du=",",So="...";function Eo(R,x){const M=((R=R.replace(/\s/g,"")).length-R.replace(wl,"").length)/oo.length;if(M<1)throw new Error("Equations without an arrow are not supported.");if(M>1)throw new Error(`Equation must contain exactly one arrow ("${oo}").`);const[L,H]=R.split(oo);(0,Be.hu)(-1===L.indexOf(So),()=>`The ellipsis notation ("${So}") is not supported yet.`);const oe=L.split(du),me=oe.length;if(x!==me)throw new Error(`Expected ${me} input tensors, received ${x}`);if(me>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const Te=[];for(let Je=0;Je<H.length;++Je){const Nt=H[Je];if(!oe.some(zt=>-1!==zt.indexOf(Nt)))throw new Error(`Output subscripts contain the label ${Nt} not present in the input subscripts.`);-1===Te.indexOf(Nt)&&Te.push(Nt)}for(let Je=0;Je<L.length;++Je){const Nt=L[Je];-1===Te.indexOf(Nt)&&Nt!==du&&Te.push(Nt)}const Xe=new Array(oe.length);for(let Je=0;Je<me;++Je){if(new Set(oe[Je].split("")).size!==oe[Je].length)throw new Error(`Found duplicate axes in input component ${oe[Je]}. Support for duplicate axes in input is not implemented yet.`);Xe[Je]=[];for(let Nt=0;Nt<oe[Je].length;++Nt)Xe[Je].push(Te.indexOf(oe[Je][Nt]))}const Ze=Te.length,Qe=[];for(let Je=H.length;Je<Ze;++Je)Qe.push(Je);return{allDims:Te,summedDims:Qe,idDims:Xe}}function cc(R,x){let M=new Array(R);M.fill(-1);for(let H=0;H<x.length;++H)M[x[H]]=H;const L=[];for(let H=0;H<R;++H)-1===M[H]&&L.push(H);return M=M.filter(H=>-1!==H),{permutationIndices:M,expandDims:L}}function uc(R,x,M){const L=new Array(R);for(let H=0;H<M.length;++H){const oe=M[H].shape;for(let me=0;me<x[H].length;++me)void 0===L[x[H][me]]?L[x[H][me]]=oe[me]:(0,Be.hu)(L[x[H][me]]===oe[me],()=>`Expected dimension ${L[x[H][me]]} at axis ${me} of input shaped ${JSON.stringify(oe)}, but got dimension ${oe[me]}`)}}function Pn(R,x){const M=R,L=[];let H=0;0===R.length&&M.push(-1),H=R.length+1;for(let me=0;me<H;++me)L.push([]);const oe=[];for(let me=0;me<M.length;++me){const Xe=Sl(x,M[me]);for(const Ze of Xe)-1===oe.indexOf(Ze)&&(L[me].push(Ze),oe.push(Ze))}return{path:M,steps:L}}function $b(R){return R.every((x,M)=>x===M)}function Sl(R,x){const M=[];for(let L=0;L<R.length;++L)(0===R[L].length||-1!==R[L].indexOf(x)||-1===x)&&M.push(L);return M}function dd(R,x,M=0){let L=[];if("number"==typeof x)(0,Be.hu)(R.shape[M]%x==0,()=>"Number of splits must evenly divide the axis."),L=new Array(x).fill(R.shape[M]/x);else{const H=x.reduce((me,Te)=>(-1===Te&&(me+=1),me),0);(0,Be.hu)(H<=1,()=>"There should be only one negative value in split array.");const oe=x.indexOf(-1);if(-1!==oe){const me=x.reduce((Te,Xe)=>Xe>0?Te+Xe:Te);x[oe]=R.shape[M]-me}(0,Be.hu)(R.shape[M]===x.reduce((me,Te)=>me+Te),()=>"The sum of sizes must match the size of the axis dimension."),L=x}return L}function zo(R){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${R}`}function dc(R,x){return`indices(${R}, 0) is invalid: ${x} < 0`}function za(R,x,M){return`indices(${R}, 0) is invalid: ${x} >= ${M}`}function El(R,x){return`only one output dimension may be -1, not both ${R} and ${x}`}function Kr(R,x){return`size ${R} must be non-negative, not ${x}`}function Kh(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Hs(R,x){return`Input to reshape is a SparseTensor with ${(0,Be.NA)(R)}\n  dense values, but the requested shape requires a multiple of ${(0,Be.NA)(x)}. inputShape=${R} outputShape= ${x}`}function ks(R,x){return`Input to reshape is a tensor with ${(0,Be.NA)(R)} dense values, but the requested shape has ${(0,Be.NA)(x)}. inputShape=${R} outputShape=${x}`}function hu(){return"segment ids must be >= 0"}function di(){return"segment ids are not increasing"}function hc(R,x){return`Segment id ${R} out of range [0, ${x}), possibly because segmentIds input is not sorted.`}function Do(R,x,M){return`Bad: indices[${R}] == ${x} out of range [0, ${M})`}function aa(R,x){let L,M=!1;for(R<=Ri?(L=R,M=!0):L=(0,Be.jP)(R,Math.floor(Math.sqrt(R)));!M;)L>x||L===R?M=!0:L=(0,Be.jP)(R,L+1);return L}function pc(R,x,M){const L=[],H=R.length;for(let oe=0;oe<H;oe++)L.push(oe!==x?R[oe]:M);return L}function em(R,x,M,L){const H=x.shape.length,oe=R.shape.length;if(0!==L&&(L<-H||L>H))throw new Error(`Expect batchDims in the range of [-${H}, ${H}], but got ${L}`);if(L<0&&(L+=H),L>oe)throw new Error(`batchDims (${L}) must be less than rank(x) (\n    ${oe}).`);if(M<L)throw new Error(`batchDims (${L}) must be less than or equal to axis (${M}).`);for(let Qe=0;Qe<L;++Qe)if(R.shape[Qe]!==x.shape[Qe])throw new Error(`x.shape[${Qe}]: ${R.shape[Qe]} should be equal to indices.shape[${Qe}]: ${x.shape[Qe]}.`);const me=R.shape[M],Te=[];let Xe=1,Ze=1,St=1;for(let Qe=0;Qe<L;++Qe)Te.push(R.shape[Qe]),Xe*=R.shape[Qe];for(let Qe=L;Qe<M;Qe++)Te.push(R.shape[Qe]),Ze*=R.shape[Qe];for(let Qe=L;Qe<H;Qe++)Te.push(x.shape[Qe]);for(let Qe=M+1;Qe<oe;Qe++)Te.push(R.shape[Qe]),St*=R.shape[Qe];return{batchSize:Xe,sliceSize:St,outerSize:Ze,dimSize:me,outputShape:Te}}function Xh(R){try{return R.map(x=>(0,gn.decodeString)(x))}catch(x){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${x}`)}}function pu(R){return R.map(x=>(0,gn.encodeString)(x))}var hd=O(152),tm=O(2842),la=O(7872);!function un(){for(const R of oi)Qi(R)}()},1070:(mt,Le,O)=>{"use strict";O.d(Le,{$HU:()=>Ji,$g6:()=>Rt,$w:()=>wi,Acj:()=>Xi,BMI:()=>$o,BiW:()=>on,Byc:()=>et,CAk:()=>vo,CQl:()=>qn,D2d:()=>E,DlI:()=>fs,Eh3:()=>S,FKq:()=>ea,G3Y:()=>ln,GBy:()=>Kn,Gcp:()=>ta,HEU:()=>Nn,HZH:()=>Fn,Hhh:()=>hl,Hmb:()=>ka,IKK:()=>pe,IMb:()=>ot,J$2:()=>Qo,J7O:()=>Yi,J_u:()=>Qs,JhU:()=>ge,Kgp:()=>Bs,L8s:()=>Uo,Ly9:()=>Be,M2y:()=>ie,MIZ:()=>dt,MRv:()=>ai,MZg:()=>Ei,NEP:()=>Mr,NZg:()=>Ia,O3z:()=>li,OAf:()=>Ps,OR:()=>Da,OU7:()=>ei,OV7:()=>Zl,Omj:()=>Er,Oyi:()=>se,PYm:()=>Js,PhF:()=>ii,QCc:()=>Ae,QRR:()=>nn,Qg5:()=>Yo,QiL:()=>xo,Qvg:()=>pn,RFZ:()=>ae,ROF:()=>Fe,RQH:()=>ec,RuY:()=>Us,SIB:()=>Ti,SX0:()=>_n,SYM:()=>ue,SbG:()=>si,SpW:()=>G,T0n:()=>Vt,TQc:()=>ml,TR1:()=>At,ToN:()=>$t,Tr8:()=>Ie,Uyb:()=>Gi,VGw:()=>xe,Vbg:()=>Lo,VcC:()=>dn,VfG:()=>Jo,Vn9:()=>Ge,W0H:()=>Ls,XDQ:()=>Vn,XLW:()=>Mt,XkS:()=>J,Xze:()=>P,Y0y:()=>_o,YFo:()=>Zo,YoZ:()=>ql,ZbH:()=>_r,ZjV:()=>En,Zz9:()=>he,_JP:()=>B,_V0:()=>Co,_Yw:()=>ri,_k9:()=>ut,_tC:()=>f,a5O:()=>gn,aJk:()=>X,avt:()=>qi,b9H:()=>ms,bK0:()=>g,bV0:()=>un,c17:()=>to,cWu:()=>Tt,cie:()=>rn,cye:()=>Ln,dDz:()=>Qi,deh:()=>Si,dpD:()=>an,e07:()=>oi,e0R:()=>b,e6w:()=>Na,e7N:()=>dl,eBW:()=>be,eEB:()=>Q,eZ0:()=>Po,ekb:()=>Se,gJX:()=>F,h8e:()=>Is,hCO:()=>nt,hdR:()=>Yn,i5y:()=>Ra,iHb:()=>Kt,iJz:()=>Ta,iWB:()=>ul,iZT:()=>cl,ik2:()=>we,jMg:()=>I,jQk:()=>z,jQs:()=>Ql,jeX:()=>ps,kU:()=>vr,kpP:()=>Dt,kuV:()=>$s,luS:()=>Ii,lyA:()=>Ts,mKl:()=>qe,mTV:()=>pl,mc4:()=>_t,mhS:()=>ze,mm_:()=>q,n9L:()=>xt,nhH:()=>gl,nr8:()=>Jl,o0g:()=>pr,o2y:()=>ke,oFR:()=>Vo,oHH:()=>rt,oT6:()=>U,p2w:()=>xr,p4S:()=>Rn,pe_:()=>Bo,q1x:()=>Ki,q2K:()=>ti,q8u:()=>Yl,qCd:()=>Di,qIC:()=>Dr,qWM:()=>Tn,qi_:()=>Ds,qkr:()=>jr,qw7:()=>re,r7n:()=>Ce,s1s:()=>ne,sEM:()=>ht,sHE:()=>Ys,sJF:()=>ce,sL$:()=>gt,usg:()=>Oa,uv1:()=>Yt,vFR:()=>hr,vtC:()=>Zi,vwp:()=>Ea,w3H:()=>ts,w6g:()=>eo,wUP:()=>ye,wYB:()=>Vs,wYn:()=>Aa,we_:()=>ni,wm:()=>ve,wx7:()=>Gt,x12:()=>Me,xJR:()=>Jn,xQA:()=>Bn,xnO:()=>ee,y7R:()=>cn,yQU:()=>fl,yj2:()=>Re,zbQ:()=>Ma,zvY:()=>de,zws:()=>ct});const ue="Abs",xe="Acos",G="Acosh",q="Add",P="AddN",U="All",pe="Any",ce="ArgMax",X="ArgMin",ie="Asin",re="Asinh",I="Atan",se="Atanh",Ae="Atan2",ge="AvgPool",Fe="AvgPoolGrad",ut="AvgPool3D",ot="AvgPool3DGrad",Mt="BatchMatMul",ct="BatchToSpaceND",de="Bincount",nt="BitwiseAnd",Be="BroadcastTo",Q="BroadcastArgs",ae="Cast",F="Ceil",ee="ClipByValue",he="Complex",Re="ComplexAbs",S="Concat",ze="Conv2D",ye="Conv2DBackpropFilter",ve="Conv2DBackpropInput",Me="Conv3D",ke="Conv3DBackpropFilterV2",we="Conv3DBackpropInputV2",_t="Cos",At="Cosh",et="Cumprod",Kt="Cumsum",dn="CropAndResize",nn="DenseBincount",Vt="DepthToSpace",rn="DepthwiseConv2dNative",gt="DepthwiseConv2dNativeBackpropFilter",cn="DepthwiseConv2dNativeBackpropInput",wi="Diag",Rn="Dilation2D",Se="Dilation2DBackpropInput",Ge="Dilation2DBackpropFilter",rt="RealDiv",Rt="Einsum",_n="Elu",Nn="EluGrad",Er="Erf",Yn="Equal",Mr="Exp",Zo="ExpandDims",_o="Expm1",Ea="FFT",Si="Fill",Gi="FlipLeftRight",Da="Floor",ps="FloorDiv",Ys="FusedBatchNorm",Ds="GatherV2",Ki="GatherNd",cl="Greater",Xi="GreaterEqual",Ta="Identity",Yo="IFFT",Qs="Imag",qi="IsFinite",ul="IsInf",Ce="IsNan",Qo="LeakyRelu",Zi="Less",vo="LessEqual",dl="LinSpace",_r="Log",vr="Log1p",Js="LogicalAnd",Jo="LogicalNot",Ei="LogicalOr",eo="LogicalXor",Di="LogSoftmax",Dr="LowerBound",Po="LRN",hl="LRNGrad",Yi="MatrixBandPart",ql="Max",$o="Maximum",pl="MaxPool",Zl="MaxPoolGrad",Ps="MaxPool3D",ei="MaxPool3DGrad",hr="MaxPoolWithArgmax",ti="Mean",to="Min",Yl="Minimum",Ql="MirrorPad",Lo="Mod",Ia="Multinomial",Aa="Multiply",$s="Neg",fl="NotEqual",Yt="NonMaxSuppressionV3",Ln="NonMaxSuppressionV4",Ls="NonMaxSuppressionV5",Tn="OnesLike",ni="OneHot",xo="Pack",Ts="PadV2",Bs="Pool",Bo="Pow",pr="Prelu",fs="Prod",Qi="RaggedGather",qn="RaggedRange",on="RaggedTensorToTensor",Na="Range",Jn="Real",Ji="Reciprocal",jr="Relu",Fn="Reshape",an="ResizeNearestNeighbor",ka="ResizeNearestNeighborGrad",ri="ResizeBilinear",Ma="ResizeBilinearGrad",si="Relu6",qe="Reverse",oi="Round",un="Rsqrt",Bn="ScatterNd",Ti="TensorScatterUpdate",Jl="SearchSorted",ii="Select",Vo="Selu",xr="Slice",ec="Sin",Vs="Sinh",Ra="Sign",gn="Sigmoid",ai="Softplus",ea="Sqrt",Kn="Sum",ml="SpaceToBatchND",Uo="SplitV",ta="Softmax",li="SparseFillEmptyRows",gl="SparseReshape",ts="SparseSegmentMean",En="SparseSegmentSum",E="SparseToDense",f="SquaredDifference",g="Square",b="StaticRegexReplace",z="StridedSlice",B="StringNGrams",ne="StringSplit",J="StringToHashBucketFast",Ie="Sub",ht="Tan",dt="Tanh",xt="Tile",Tt="TopK",Gt="Transform",ln="Transpose",Dt="Unique",$t="Unpack",pn="UnsortedSegmentSum",Vn="UpperBound",Us="ZerosLike",Is="Step",be="FromPixels",ms="RotateWithOffset",Oa="_FusedMatMul",Co="FusedConv2D",Ii="FusedDepthwiseConv2D"},9464:(mt,Le,O)=>{"use strict";O.d(Le,{Li:()=>ie,T3:()=>se,bt:()=>I,nE:()=>re,pI:()=>U,tr:()=>ce,uk:()=>pe,wC:()=>X});var ue=O(1777),xe=O(6422),G=O(5686);const q=(0,xe.R)("kernelRegistry",()=>new Map),P=(0,xe.R)("gradRegistry",()=>new Map);function U(ge,Fe){const ut=Ae(ge,Fe);return q.get(ut)}function pe(ge){return P.get(ge)}function ce(ge){const Fe=q.entries(),ut=[];for(;;){const{done:ot,value:Mt}=Fe.next();if(ot)break;const[ct,de]=Mt,[nt]=ct.split("_");nt===ge&&ut.push(de)}return ut}function X(ge){const{kernelName:Fe,backendName:ut}=ge,ot=Ae(Fe,ut);q.has(ot)&&G.Z(`The kernel '${Fe}' for backend '${ut}' is already registered`),q.set(ot,ge)}function ie(ge){const{kernelName:Fe}=ge;P.has(Fe)&&(0,ue.OB)().getBool("DEBUG")&&G.Z(`Overriding the gradient for '${Fe}'`),P.set(Fe,ge)}function re(ge,Fe){const ut=Ae(ge,Fe);if(!q.has(ut))throw new Error(`The kernel '${ge}' for backend '${Fe}' is not registered`);q.delete(ut)}function I(ge){if(!P.has(ge))throw new Error(`The gradient '${ge}' for backend is not registered`);P.delete(ge)}function se(ge,Fe){ce(ge).forEach(ot=>{X(Object.assign({},ot,{backendName:Fe}))})}function Ae(ge,Fe){return`${Fe}_${ge}`}},5686:(mt,Le,O)=>{"use strict";O.d(Le,{Z:()=>xe,c:()=>G});var ue=O(1777);function xe(...q){(0,ue.OB)().getBool("IS_TEST")||(0,ue.OB)().getBool("PROD")||console.warn(...q)}function G(...q){(0,ue.OB)().getBool("IS_TEST")||(0,ue.OB)().getBool("PROD")||console.log(...q)}},2519:(mt,Le,O)=>{"use strict";O.d(Le,{W:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({abs_:function P(pe){const ce=(0,G._1)(pe,"x","abs");return ue.BV.runKernel("complex64"===ce.dtype?xe.yj2:xe.SYM,{x:ce})}})},6849:(mt,Le,O)=>{"use strict";O.d(Le,{I:()=>pe});var ue=O(3738),xe=O(1070),G=O(7904),q=O(9608);const pe=(0,O(6721).op)({add_:function U(ce,X){let ie=(0,q._1)(ce,"a","add"),re=(0,q._1)(X,"b","add");return[ie,re]=(0,G.makeTypesMatch)(ie,re),ue.BV.runKernel(xe.mm_,{a:ie,b:re})}})},7745:(mt,Le,O)=>{"use strict";O.d(Le,{LJ:()=>ce,Q3:()=>pe,Vh:()=>G,YB:()=>xe,kz:()=>q,lB:()=>U,rv:()=>P,sY:()=>X});var ue=O(1396);function xe(ie,re){for(let I=0;I<ie.length;++I)if(ie[ie.length-I-1]!==re-1-I)return!1;return!0}function G(ie,re,I){const se=ie.length+re.length,Ae=[];let ge=0,Fe=0;for(let ut=0;ut<se;ut++)-1===I.indexOf(ut)?Ae.push(ie[ge++]):Ae.push(re[Fe++]);return Ae}function q(ie,re){const I=[],se=ie.length;for(let ge=0;ge<se;ge++)-1===re.indexOf(ge)&&I.push(ie[ge]);return[I,re.map(ge=>ie[ge])]}function P(ie,re){return G(ie,re.map(se=>1),re)}function U(ie,re,I){ue.hu(xe(re,I),()=>`${ie} supports only inner-most axes for now. Got axes ${re} and rank-${I} input.`)}function pe(ie,re){if(xe(ie,re))return null;const I=[];for(let se=0;se<re;++se)-1===ie.indexOf(se)&&I.push(se);return ie.forEach(se=>I.push(se)),I}function ce(ie){return ie.map((re,I)=>[I,re]).sort((re,I)=>re[1]-I[1]).map(re=>re[0])}function X(ie,re){const I=[];for(let se=re-ie;se<re;++se)I.push(se);return I}},258:(mt,Le,O)=>{"use strict";function ue(q,P){const U=q.length,pe=[];for(let ce=0;ce<U;ce++){const X=U-1-ce;(P[P.length-1-ce]||1)>1&&1===(q[X]||1)&&pe.unshift(X)}return pe}function xe(q,P){const U=[];for(let pe=0;pe<P.length;pe++){const ce=q[q.length-pe-1],X=P.length-pe-1;(null==ce||1===ce&&P[X]>1)&&U.unshift(X)}return U}function G(q,P){const U=Math.max(q.length,P.length),pe=new Array(U);for(let ce=0;ce<U;ce++){let X=q[q.length-ce-1];null==X&&(X=1);let ie=P[P.length-ce-1];if(null==ie&&(ie=1),1===X)pe[U-ce-1]=ie;else if(1===ie)pe[U-ce-1]=X;else{if(X!==ie)throw Error(`Operands could not be broadcast together with shapes ${q} and ${P}.`);pe[U-ce-1]=X}}return pe}O.r(Le),O.d(Le,{assertAndGetBroadcastShape:()=>G,getBroadcastDims:()=>ue,getReductionAxes:()=>xe})},8621:(mt,Le,O)=>{"use strict";O.d(Le,{f:()=>G});var ue=O(708),xe=O(1396);function G(q,P="float32",U){return P=P||"float32",xe.Mu(q),new ue.YD(q,P,U)}},9734:(mt,Le,O)=>{"use strict";O.d(Le,{p:()=>pe});var ue=O(3738),xe=O(1070),G=O(9608),q=O(1396);const pe=(0,O(6721).op)({cast_:function U(ce,X){const ie=(0,G._1)(ce,"x","cast");if(!q.LP(X))throw new Error(`Failed to cast to unknown dtype ${X}`);if("string"===X&&"string"!==ie.dtype||"string"!==X&&"string"===ie.dtype)throw new Error("Only strings can be casted to strings");return ue.BV.runKernel(xe.RFZ,{x:ie},{dtype:X})}})},4249:(mt,Le,O)=>{"use strict";O.d(Le,{d:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({clone_:function P(pe){const X={x:(0,G._1)(pe,"x","clone","string_or_numeric")};return ue.BV.runKernel(xe.iJz,X)}})},9907:(mt,Le,O)=>{"use strict";O.d(Le,{P:()=>pe});var ue=O(3738),xe=O(1070),G=O(9608),q=O(1396);const pe=(0,O(6721).op)({complex_:function U(ce,X){const ie=(0,G._1)(ce,"real","complex"),re=(0,G._1)(X,"imag","complex");return q.k5(ie.shape,re.shape,`real and imag shapes, ${ie.shape} and ${re.shape}, must match in call to tf.complex().`),ue.BV.runKernel(xe.Zz9,{real:ie,imag:re})}})},744:(mt,Le,O)=>{"use strict";O.d(Le,{I0:()=>Fe,Ix:()=>P,Rf:()=>xe,U3:()=>ot,Xw:()=>G,aO:()=>X,jT:()=>ut,jw:()=>U,m:()=>ct,pl:()=>q,sl:()=>Mt});var ue=O(1396);function xe(de,nt,Be,Q,ae="NHWC",F){return P(de,[...nt,de[3]],Be,F,Q,null,null,Mt(ae))}function G(de,nt,Be,Q,ae,F,ee="channelsLast"){const[he,Re]=ie(nt);let S;if("channelsLast"===ee)S=[he,Re,de[3],de[3]];else{if("channelsFirst"!==ee)throw new Error(`Unknown dataFormat ${ee}`);S=[he,Re,de[1],de[1]]}return P(de,S,Be,Q,ae,F,!1,ee)}function q(de,nt,Be,Q,ae,F,ee="NDHWC"){const[he,Re,S]=re(nt);let ze,ye;if("NDHWC"===ee)ye="channelsLast",ze=[he,Re,S,de[4],de[4]];else{if("NCDHW"!==ee)throw new Error(`Unknown dataFormat ${ee}`);ye="channelsFirst",ze=[he,Re,S,de[1],de[1]]}return U(de,ze,Be,Q,ae,!1,ye,F)}function P(de,nt,Be,Q,ae,F,ee=!1,he="channelsLast"){let[Re,S,ze,ye]=[-1,-1,-1,-1];if("channelsLast"===he)[Re,S,ze,ye]=de;else{if("channelsFirst"!==he)throw new Error(`Unknown dataFormat ${he}`);[Re,ye,S,ze]=de}const[ve,Me,,ke]=nt,[we,_t]=ie(Be),[At,et]=ie(Q),Kt=I(ve,At),dn=I(Me,et),{padInfo:nn,outHeight:Vt,outWidth:rn}=function se(de,nt,Be,Q,ae,F,ee,he,Re){let S,ze,ye;if("number"==typeof de){S={top:de,bottom:de,left:de,right:de,type:0===de?"VALID":"NUMBER"};const Me=function pe(de,nt,Be,Q,ae){null==Q&&(Q=X(de,nt,Be));const ee=de[1];return[ge((de[0]-nt+2*Q)/Be+1,ae),ge((ee-nt+2*Q)/Be+1,ae)]}([nt,Be],F,Q,de,he);ze=Me[0],ye=Me[1]}else if("same"===de){ze=Math.ceil(nt/Q),ye=Math.ceil(Be/ae);const ve=Math.max(0,(ze-1)*Q+F-nt),Me=Math.max(0,(ye-1)*ae+ee-Be),ke=Math.floor(ve/2),we=ve-ke,_t=Math.floor(Me/2);S={top:ke,bottom:we,left:_t,right:Me-_t,type:"SAME"}}else if("valid"===de)S={top:0,bottom:0,left:0,right:0,type:"VALID"},ze=Math.ceil((nt-F+1)/Q),ye=Math.ceil((Be-ee+1)/ae);else{if("object"!=typeof de)throw Error(`Unknown padding parameter: ${de}`);{const ve="channelsLast"===Re?de[1][0]:de[2][0],Me="channelsLast"===Re?de[1][1]:de[2][1],ke="channelsLast"===Re?de[2][0]:de[3][0],we="channelsLast"===Re?de[2][1]:de[3][1];S={top:ve,bottom:Me,left:ke,right:we,type:0===ve&&0===Me&&0===ke&&0===we?"VALID":"EXPLICIT"},ze=ge((nt-F+ve+Me)/Q+1,he),ye=ge((Be-ee+ke+we)/ae+1,he)}}return{padInfo:S,outHeight:ze,outWidth:ye}}(ae,S,ze,we,_t,Kt,dn,F,he),gt=ee?ke*ye:ke;let cn;return"channelsFirst"===he?cn=[Re,gt,Vt,rn]:"channelsLast"===he&&(cn=[Re,Vt,rn,gt]),{batchSize:Re,dataFormat:he,inHeight:S,inWidth:ze,inChannels:ye,outHeight:Vt,outWidth:rn,outChannels:gt,padInfo:nn,strideHeight:we,strideWidth:_t,filterHeight:ve,filterWidth:Me,effectiveFilterHeight:Kt,effectiveFilterWidth:dn,dilationHeight:At,dilationWidth:et,inShape:de,outShape:cn,filterShape:nt}}function U(de,nt,Be,Q,ae,F=!1,ee="channelsLast",he){let[Re,S,ze,ye,ve]=[-1,-1,-1,-1,-1];if("channelsLast"===ee)[Re,S,ze,ye,ve]=de;else{if("channelsFirst"!==ee)throw new Error(`Unknown dataFormat ${ee}`);[Re,ve,S,ze,ye]=de}const[Me,ke,we,,_t]=nt,[At,et,Kt]=re(Be),[dn,nn,Vt]=re(Q),rn=I(Me,dn),gt=I(ke,nn),cn=I(we,Vt),{padInfo:wi,outDepth:Rn,outHeight:Se,outWidth:Ge}=function Ae(de,nt,Be,Q,ae,F,ee,he,Re,S,ze){let ye,ve,Me,ke;if("valid"===de&&(de=0),"number"==typeof de){ye={top:de,bottom:de,left:de,right:de,front:de,back:de,type:0===de?"VALID":"NUMBER"};const _t=function ce(de,nt,Be,Q,ae,F){null==ae&&(ae=X(de,nt[0],Q[0]));const ee=[0,0,0,Be];for(let he=0;he<3;he++)de[he]+2*ae>=nt[he]&&(ee[he]=ge((de[he]-nt[he]+2*ae)/Q[he]+1,F));return ee}([nt,Be,Q,1],[he,Re,S],1,[ae,F,ee],de,ze);ve=_t[0],Me=_t[1],ke=_t[2]}else{if("same"!==de)throw Error(`Unknown padding parameter: ${de}`);{ve=Math.ceil(nt/ae),Me=Math.ceil(Be/F),ke=Math.ceil(Q/ee);const we=(ve-1)*ae+he-nt,_t=(Me-1)*F+Re-Be,At=(ke-1)*ee+S-Q,et=Math.floor(we/2),Kt=we-et,dn=Math.floor(_t/2),nn=_t-dn,Vt=Math.floor(At/2);ye={top:dn,bottom:nn,left:Vt,right:At-Vt,front:et,back:Kt,type:"SAME"}}}return{padInfo:ye,outDepth:ve,outHeight:Me,outWidth:ke}}(ae,S,ze,ye,At,et,Kt,rn,gt,cn,he),rt=F?_t*ve:_t;let Rt;return"channelsFirst"===ee?Rt=[Re,rt,Rn,Se,Ge]:"channelsLast"===ee&&(Rt=[Re,Rn,Se,Ge,rt]),{batchSize:Re,dataFormat:ee,inDepth:S,inHeight:ze,inWidth:ye,inChannels:ve,outDepth:Rn,outHeight:Se,outWidth:Ge,outChannels:rt,padInfo:wi,strideDepth:At,strideHeight:et,strideWidth:Kt,filterDepth:Me,filterHeight:ke,filterWidth:we,effectiveFilterDepth:rn,effectiveFilterHeight:gt,effectiveFilterWidth:cn,dilationDepth:dn,dilationHeight:nn,dilationWidth:Vt,inShape:de,outShape:Rt,filterShape:nt}}function X(de,nt,Be,Q=1){const ae=I(nt,Q);return Math.floor((de[0]*(Be-1)-Be+ae)/2)}function ie(de){return"number"==typeof de?[de,de,de]:2===de.length?[de[0],de[1],1]:de}function re(de){return"number"==typeof de?[de,de,de]:de}function I(de,nt){return nt<=1?de:de+(de-1)*(nt-1)}function ge(de,nt){if(!nt)return Math.trunc(de);switch(nt){case"round":return Math.round(de);case"ceil":return Math.ceil(de);case"floor":return Math.floor(de);default:throw new Error(`Unknown roundingMode ${nt}`)}}function Fe(de){const[nt,Be,Q]=ie(de);return 1===nt&&1===Be&&1===Q}function ut(de,nt){return Fe(de)||Fe(nt)}function ot(de){return ie(de).every(nt=>nt>0)}function Mt(de){if("NHWC"===de)return"channelsLast";if("NCHW"===de)return"channelsFirst";throw new Error(`Unknown dataFormat ${de}`)}function ct(de,nt,Be){if(null!=Be){if("string"==typeof nt)throw Error(`Error in ${de}: pad must be an integer when using dimRoundingMode ${Be} but got pad ${nt}.`);if("number"==typeof nt)ue.hu(ue.GN(nt),()=>`Error in ${de}: pad must be an integer when using dimRoundingMode ${Be} but got pad ${nt}.`);else{if("object"!=typeof nt)throw Error(`Error in ${de}: Unknown padding parameter: ${nt}`);nt.forEach(Q=>{Q.forEach(ae=>{ue.hu(ue.GN(ae),()=>`Error in ${de}: pad must be an integer when using dimRoundingMode ${Be} but got pad ${ae}.`)})})}}}},6635:(mt,Le,O)=>{"use strict";O.d(Le,{h:()=>ce});var ue=O(3738),xe=O(1070),G=O(7904),q=O(9608),P=O(3273);const ce=(0,O(6721).op)({div_:function pe(X,ie){let re=(0,q._1)(X,"a","div"),I=(0,q._1)(ie,"b","div");return[re,I]=(0,G.makeTypesMatch)(re,I),"int32"===re.dtype&&"int32"===I.dtype?(0,P.q)(re,I):ue.BV.runKernel(xe.oHH,{a:re,b:I},{})}})},4609:(mt,Le,O)=>{"use strict";O.d(Le,{p:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({elu_:function P(pe){const X={x:(0,G._1)(pe,"x","elu","float32")};return ue.BV.runKernel(xe.SX0,X)}})},8509:(mt,Le,O)=>{"use strict";O.d(Le,{h:()=>q});var ue=O(3738),xe=O(1070),G=O(1396);function q(P,U,pe){return(0,G.Mu)(P),pe=pe||(0,G.D2)(U),ue.BV.runKernel(xe.deh,{},{shape:P,value:U,dtype:pe})}},3273:(mt,Le,O)=>{"use strict";O.d(Le,{q:()=>pe});var ue=O(3738),xe=O(1070),G=O(7904),q=O(9608);const pe=(0,O(6721).op)({floorDiv_:function U(ce,X){let ie=(0,q._1)(ce,"a","floorDiv"),re=(0,q._1)(X,"b","floorDiv");return[ie,re]=(0,G.makeTypesMatch)(ie,re),ue.BV.runKernel(xe.jeX,{a:ie,b:re})}})},8868:(mt,Le,O)=>{"use strict";O.d(Le,{Fr:()=>I,QH:()=>Ae,pf:()=>se,uy:()=>ge});var ue=O(258),xe=O(4609),G=O(6151),q=O(8788),P=O(1426),U=O(4563),pe=O(5049),ce=O(9416),X=O(6713),ie=O(6166),re=O(5214);function I(Fe,ut,ot){if(null==ot||"linear"===ot)return Fe;if("relu"===ot)return(0,q.d)(Fe,(0,ie.N)(ut));throw new Error(`Cannot compute gradient for fused activation ${ot}.`)}function se(Fe,ut){let ot=ut;const Mt=ue.getReductionAxes(Fe.shape,ut.shape);return Mt.length>0&&(ot=(0,re.S)(ot,Mt)),(0,ce.X)(ot,Fe.shape)}function Ae(Fe,ut,ot,Mt){if("linear"===ut)return Fe;if("relu"===ut)return(0,U.U)(Fe);if("elu"===ut)return(0,xe.p)(Fe);if("relu6"===ut)return(0,pe.b)(Fe);if("prelu"===ut)return(0,P.A)(Fe,ot);if("leakyrelu"===ut)return(0,G.h)(Fe,Mt);if("sigmoid"===ut)return(0,X.X)(Fe);throw new Error(`Unknown fused activation ${ut}.`)}const ge=(Fe,ut)=>!(Fe>0)||"linear"===ut},5294:(mt,Le,O)=>{"use strict";O.d(Le,{a:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({imag_:function P(pe){const X={input:(0,G._1)(pe,"input","imag")};return ue.BV.runKernel(xe.J_u,X)}})},6151:(mt,Le,O)=>{"use strict";O.d(Le,{h:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({leakyRelu_:function P(pe,ce=.2){const ie={x:(0,G._1)(pe,"x","leakyRelu")};return ue.BV.runKernel(xe.J$2,ie,{alpha:ce})}})},4761:(mt,Le,O)=>{"use strict";O.d(Le,{I:()=>ue});var ue=(()=>((ue=ue||{})[ue.NONE=0]="NONE",ue[ue.MEAN=1]="MEAN",ue[ue.SUM=2]="SUM",ue[ue.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",ue))()},341:(mt,Le,O)=>{"use strict";O.d(Le,{O:()=>pe});var ue=O(3738),xe=O(1070),G=O(7904),q=O(9608);const pe=(0,O(6721).op)({matMul_:function U(ce,X,ie=!1,re=!1){let I=(0,q._1)(ce,"a","matMul"),se=(0,q._1)(X,"b","matMul");return[I,se]=(0,G.makeTypesMatch)(I,se),ue.BV.runKernel(xe.XLW,{a:I,b:se},{transposeA:ie,transposeB:re})}})},6825:(mt,Le,O)=>{"use strict";O.d(Le,{g:()=>X});var ue=O(3738),xe=O(1070),G=O(7904),q=O(9608),P=O(258),U=O(9734);const X=(0,O(6721).op)({maximum_:function ce(ie,re){let I=(0,q._1)(ie,"a","maximum"),se=(0,q._1)(re,"b","maximum");return[I,se]=(0,G.makeTypesMatch)(I,se),"bool"===I.dtype&&(I=(0,U.p)(I,"int32"),se=(0,U.p)(se,"int32")),(0,P.assertAndGetBroadcastShape)(I.shape,se.shape),ue.BV.runKernel(xe.BMI,{a:I,b:se})}})},8788:(mt,Le,O)=>{"use strict";O.d(Le,{d:()=>pe});var ue=O(3738),xe=O(1070),G=O(7904),q=O(9608);const pe=(0,O(6721).op)({mul_:function U(ce,X){let ie=(0,q._1)(ce,"a","mul"),re=(0,q._1)(X,"b","mul");return[ie,re]=(0,G.makeTypesMatch)(ie,re),ue.BV.runKernel(xe.wYn,{a:ie,b:re})}})},3304:(mt,Le,O)=>{"use strict";O.d(Le,{W:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({neg_:function P(pe){const X={x:(0,G._1)(pe,"x","neg")};return ue.BV.runKernel(xe.kuV,X)}})},2738:(mt,Le,O)=>{"use strict";O.d(Le,{l:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({oneHot_:function P(pe,ce,X=1,ie=0,re="int32"){if(ce<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${ce}`);const se={indices:(0,G._1)(pe,"indices","oneHot","int32")};return ue.BV.runKernel(xe.we_,se,{dtype:re,depth:ce,onValue:X,offValue:ie})}})},6721:(mt,Le,O)=>{"use strict";O.d(Le,{op:()=>q,z:()=>G});var ue=O(3738),xe=O(1396);const G="__op";function q(P){const U=Object.keys(P);if(1!==U.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${U.length} keys.`);let pe=U[0];const ce=P[pe];pe.endsWith("_")&&(pe=pe.substring(0,pe.length-1)),pe+=G;const X=(...ie)=>{ue.BV.startScope(pe);try{const re=ce(...ie);return(0,xe.tI)(re)&&console.error("Cannot return a Promise inside of tidy."),ue.BV.endScope(re),re}catch(re){throw ue.BV.endScope(null),re}};return Object.defineProperty(X,"name",{value:pe,configurable:!0}),X}},3809:(mt,Le,O)=>{"use strict";O.d(Le,{zvA:()=>U.z,WnP:()=>xe.W,Khb:()=>ce,__u:()=>ie,IHx:()=>re.I,QBD:()=>Ae,$6P:()=>Fe,YjB:()=>ot,NqF:()=>ct,vHJ:()=>nt,ZRM:()=>Q,VfV:()=>F,z4N:()=>he,fvJ:()=>ze,C80:()=>ve,wS1:()=>At,uR5:()=>Kt,zEQ:()=>Rt,tgs:()=>Mr,Dxk:()=>_o,JY5:()=>Si,p3b:()=>Da,E4h:()=>Nn,yE8:()=>Ys,ycw:()=>Ki,anm:()=>Jb,XsQ:()=>Xi,UFq:()=>Yo,f3b:()=>Qs.f,pju:()=>Me.p,mDi:()=>ul,iUl:()=>Zi,d9v:()=>dn.d,PYB:()=>vo.P,zoF:()=>Vt,gME:()=>_r,Izb:()=>Js,MNy:()=>Ei,ZaL:()=>Di,PAt:()=>Yi,Tek:()=>Po,bc:()=>Zl,pdZ:()=>ei,$QV:()=>Yl,mCk:()=>Lo,f9Y:()=>Aa,mew:()=>_s,$Gn:()=>fl,zbp:()=>Ln,ppE:()=>Tn,nTT:()=>xo,B10:()=>Bs,Ka3:()=>pr,WmZ:()=>Qi,hiC:()=>qn.h,NTj:()=>ka,AKD:()=>Ma,rvX:()=>Ow,WYO:()=>qe,pyx:()=>oi.p,GRh:()=>sp,EDe:()=>Bn,DgJ:()=>Jn,qNN:()=>Jl,d2q:()=>gl,Qqt:()=>En,dt4:()=>f,t$B:()=>b,iyy:()=>J,kp_:()=>fc,hlL:()=>Ce.h,GWj:()=>ht,qPi:()=>dt.q,imm:()=>ue,Iqj:()=>Tt,dbB:()=>np,pjt:()=>ln,brS:()=>$t,Sxn:()=>Qh,asL:()=>pn.a,BHj:()=>xu,V3u:()=>gc,wx0:()=>Ub,xVT:()=>Us,UWc:()=>be,i2d:()=>Oa,hi7:()=>Co.h,d9m:()=>yl,zN1:()=>tu,$r2:()=>w_,SX3:()=>$h,G9k:()=>nc,cM7:()=>na,Krr:()=>nu,e_t:()=>_l,CmS:()=>rd,l_t:()=>ro,HvI:()=>zs,hJK:()=>Pa,K5V:()=>rc,egP:()=>ui,MB5:()=>Ho,eab:()=>iu,OI3:()=>rn.O,Fp7:()=>xr,_sB:()=>lu,YQQ:()=>oc,Ip$:()=>Bh,gWQ:()=>id.g,J69:()=>ic,ry_:()=>Vh,VV$:()=>Vs,LTh:()=>ac,VdP:()=>vl,wQq:()=>Uh,Gi7:()=>ys,p_:()=>Wn,dC7:()=>gt.d,rq4:()=>Mi,SJ_:()=>Zn,W76:()=>no.W,KOy:()=>ta,Quu:()=>La,lfX:()=>It.l,iUs:()=>ki,JpU:()=>jn,op:()=>U.op,N2O:()=>Ns,vku:()=>Gr,pNR:()=>cd,koy:()=>jh,t1L:()=>Pr,lGY:()=>vn,d_R:()=>Cr,sQ3:()=>Ra.s,AL3:()=>oa.A,S0v:()=>ia.S,WVs:()=>xl,$gW:()=>Va,VT$:()=>Cl,N89:()=>oo,TN_:()=>du,wzB:()=>El,nGf:()=>Kh,ruB:()=>ks,LGj:()=>di,pe5:()=>Do,w6H:()=>aa,kwC:()=>pc.k,M25:()=>Xh,UYe:()=>pu.U,btT:()=>hd.b,XLQ:()=>we.X,GYS:()=>la,SDf:()=>x,diP:()=>L,sx7:()=>oe,mG2:()=>Te,QEs:()=>ao,NMM:()=>Ze,bp0:()=>Qe,iD$:()=>gn.i,snQ:()=>vm,zcT:()=>sc,U8D:()=>Nt,U_I:()=>Jt,ODp:()=>Zt,XD2:()=>cn.X,Xxe:()=>as,tdS:()=>C_,O$l:()=>pd,R_K:()=>To,tPi:()=>Rn,jZU:()=>ca,SmN:()=>qh,CnO:()=>md,p0P:()=>Mw,XAC:()=>Yh,Wvh:()=>bl,fBT:()=>so,rVs:()=>Cu,ers:()=>bu,uN7:()=>Xr,Vl2:()=>mu,_b3:()=>ai._,h62:()=>ea.h,$i:()=>om,L9e:()=>gd,knu:()=>gu,Nbs:()=>Jh.N,NXj:()=>Oi,Z_8:()=>jm,luU:()=>Un.l,Smz:()=>Kn.S,ORZ:()=>lm,AEp:()=>Ge,XeE:()=>or.X,RRF:()=>lo,odF:()=>ls,wOQ:()=>jb.w,yXz:()=>cm,Bfx:()=>mc,xZs:()=>co,Pg0:()=>Gb,Gg6:()=>B,hg7:()=>dm,p4s:()=>tp.p,Xu6:()=>hm,Two:()=>fm,pUJ:()=>fn,HHK:()=>gm,GaM:()=>qb,VD$:()=>Zb,arb:()=>jr,itS:()=>bm,lls:()=>ns,P84:()=>Fn.P});var ue={};O.r(ue),O.d(ue,{conv2d:()=>r_,depthwiseConv2d:()=>wm,matMul:()=>Sm});var xe=O(2519),G=O(3738),q=O(1070),P=O(9608),U=O(6721);const ce=(0,U.op)({acos_:function pe(T){const v={x:(0,P._1)(T,"x","acos")};return G.BV.runKernel(q.VGw,v)}}),ie=(0,U.op)({acosh_:function X(T){const v={x:(0,P._1)(T,"x","acosh")};return G.BV.runKernel(q.SpW,v)}});var re=O(6849),I=O(1396);const Ae=(0,U.op)({addN_:function se(T){I.hu(Array.isArray(T),()=>"The argument passed to tf.addN() must be a list of tensors"),I.hu(T.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${T.length}`);const w=T.map(($,V)=>(0,P._1)($,`tensors${V}`,"addN")),v=w[0];return w.forEach($=>{if($.dtype!==v.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),w.forEach($=>{if(!I.cO($.shape,v.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),G.BV.runKernel(q.Xze,w)}}),Fe=(0,U.op)({all_:function ge(T,w=null,v=!1){const $={x:(0,P._1)(T,"x","all","bool")};return G.BV.runKernel(q.oT6,$,{axis:w,keepDims:v})}}),ot=(0,U.op)({any_:function ut(T,w=null,v=!1){const $={x:(0,P._1)(T,"x","any","bool")};return G.BV.runKernel(q.IKK,$,{axis:w,keepDims:v})}}),ct=(0,U.op)({argMax_:function Mt(T,w=0){const k={x:(0,P._1)(T,"x","argMax")};return G.BV.runKernel(q.sJF,k,{axis:w})}}),nt=(0,U.op)({argMin_:function de(T,w=0){const k={x:(0,P._1)(T,"x","argMin")};return G.BV.runKernel(q.aJk,k,{axis:w})}}),Q=(0,U.op)({asin_:function Be(T){const v={x:(0,P._1)(T,"x","asin")};return G.BV.runKernel(q.M2y,v)}}),F=(0,U.op)({asinh_:function ae(T){const v={x:(0,P._1)(T,"x","asinh")};return G.BV.runKernel(q.qw7,v)}}),he=(0,U.op)({atan_:function ee(T){const v={x:(0,P._1)(T,"x","atan")};return G.BV.runKernel(q.jMg,v)}});var Re=O(7904);const ze=(0,U.op)({atan2_:function S(T,w){let v=(0,P._1)(T,"a","atan2"),k=(0,P._1)(w,"b","atan2");return[v,k]=(0,Re.makeTypesMatch)(v,k),G.BV.runKernel(q.QCc,{a:v,b:k})}}),ve=(0,U.op)({atanh_:function ye(T){const v={x:(0,P._1)(T,"x","atanh")};return G.BV.runKernel(q.Oyi,v)}});var Me=O(9734),ke=O(744),we=O(9416);const At=(0,U.op)({avgPool_:function _t(T,w,v,k,$){const V=(0,P._1)(T,"x","avgPool","float32");I.hu(ke.jT(v,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${v} and dilations '1'`);let Y=V,le=!1;3===V.rank&&(le=!0,Y=(0,we.X)(V,[1,V.shape[0],V.shape[1],V.shape[2]])),I.hu(4===Y.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${Y.rank}.`),ke.m("avgPool",k,$);let $e=G.BV.runKernel(q.JhU,{x:Y},{filterSize:w,strides:v,pad:k,dimRoundingMode:$});return $e=(0,Me.p)($e,V.dtype),le?(0,we.X)($e,[$e.shape[1],$e.shape[2],$e.shape[3]]):$e}}),Kt=(0,U.op)({avgPool3d_:function et(T,w,v,k,$,V="NDHWC"){const K=(0,P._1)(T,"x","avgPool3d","float32");let Y=K,le=!1;4===K.rank&&(le=!0,Y=(0,we.X)(K,[1,K.shape[0],K.shape[1],K.shape[2],K.shape[3]])),I.hu(5===Y.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${Y.rank}.`),I.hu("NDHWC"===V,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${V}`),I.hu("number"==typeof v&&v>0||Array.isArray(v)&&v[0]>0&&v[1]>0&&v[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${v}'`),(0,ke.m)("avgPool3d",k,$);let $e=G.BV.runKernel(q._k9,{x:Y},{filterSize:w,strides:v,pad:k,dimRoundingMode:$,dataFormat:V});return $e=(0,Me.p)($e,Y.dtype),le?(0,we.X)($e,[$e.shape[1],$e.shape[2],$e.shape[3],$e.shape[4]]):$e}});var dn=O(4249);const Vt=(0,U.op)({concat_:function nn(T,w=0){(0,I.hu)(T.length>=1,()=>"Pass at least one tensor to concat");const v=(0,P.sI)(T,"tensors","concat","string_or_numeric");return"complex64"===v[0].dtype&&v.forEach(V=>{if("complex64"!==V.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${V.dtype}. `)}),1===v.length?(0,dn.d)(v[0]):G.BV.runKernel(q.Eh3,v,{axis:w})}});var rn=O(341),gt=O(8788),cn=O(6713);const Rn=(0,U.op)({slice_:function wi(T,w,v){const k=(0,P._1)(T,"x","slice","string_or_numeric");if(0===k.rank)throw new Error("Slicing scalar is not possible");return G.BV.runKernel(q.p2w,{x:k},{begin:w,size:v})}}),Ge=(0,U.op)({tanh_:function Se(T){const v={x:(0,P._1)(T,"x","tanh","float32")};return G.BV.runKernel(q.MIZ,v)}}),Rt=(0,U.op)({basicLSTMCell_:function rt(T,w,v,k,$,V){const K=(0,P._1)(T,"forgetBias","basicLSTMCell"),Y=(0,P._1)(w,"lstmKernel","basicLSTMCell"),le=(0,P._1)(v,"lstmBias","basicLSTMCell"),fe=(0,P._1)(k,"data","basicLSTMCell"),Oe=(0,P._1)($,"c","basicLSTMCell"),$e=(0,P._1)(V,"h","basicLSTMCell"),bt=Vt([fe,$e],1),Lt=(0,rn.O)(bt,Y),Ht=(0,re.I)(Lt,le),en=Ht.shape[1]/4,On=[Ht.shape[0],en],$r=Rn(Ht,[0,0],On),qr=Rn(Ht,[0,en],On),er=Rn(Ht,[0,2*en],On),Ur=Rn(Ht,[0,3*en],On),In=(0,re.I)((0,gt.d)((0,cn.X)($r),Ge(qr)),(0,gt.d)(Oe,(0,cn.X)((0,re.I)(K,er))));return[In,(0,gt.d)(Ge(In),(0,cn.X)(Ur))]}}),Nn=(0,U.op)({batchToSpaceND_:function _n(T,w,v){const k=(0,P._1)(T,"x","batchToSpaceND"),$=w.reduce((Y,le)=>Y*le);return I.hu(k.rank>=1+w.length,()=>`input rank is ${k.rank} but should be > than blockShape.length ${w.length}`),I.hu(v.length===w.length,()=>`crops.length is ${v.length} but should be equal to blockShape.length  ${w.length}`),I.hu(k.shape[0]%$==0,()=>`input tensor batch is ${k.shape[0]} but is not divisible by the product of the elements of blockShape ${w.join(" * ")} === ${$}`),G.BV.runKernel(q.zws,{x:k},{blockShape:w,crops:v})}});function Er(T){let w;return w=0===T.rank||1===T.rank?(0,we.X)(T,[1,1,1,T.size]):2===T.rank?(0,we.X)(T,[1,1,T.shape[0],T.shape[1]]):3===T.rank?(0,we.X)(T,[1,T.shape[0],T.shape[1],T.shape[2]]):T,w}const Mr=(0,U.op)({batchNorm_:function Yn(T,w,v,k,$,V){null==V&&(V=.001);const K=(0,P._1)(T,"x","batchNorm"),Y=(0,P._1)(w,"mean","batchNorm"),le=(0,P._1)(v,"variance","batchNorm");let fe,Oe;null!=$&&(fe=(0,P._1)($,"scale","batchNorm")),null!=k&&(Oe=(0,P._1)(k,"offset","batchNorm")),I.hu(Y.rank===le.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I.hu(null==Oe||Y.rank===Oe.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I.hu(null==fe||Y.rank===fe.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const bt={x:Er(K),scale:fe,offset:Oe,mean:Y,variance:le},Ht=G.BV.runKernel(q.sHE,bt,{varianceEpsilon:V});return(0,we.X)(Ht,K.shape)}}),_o=(0,U.op)({batchNorm2d_:function Zo(T,w,v,k,$,V){const K=(0,P._1)(T,"x","batchNorm"),Y=(0,P._1)(w,"mean","batchNorm"),le=(0,P._1)(v,"variance","batchNorm");let fe,Oe;return null!=$&&(fe=(0,P._1)($,"scale","batchNorm")),null!=k&&(Oe=(0,P._1)(k,"offset","batchNorm")),I.hu(2===K.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${K.rank}.`),I.hu(2===Y.rank||1===Y.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${Y.rank}.`),I.hu(2===le.rank||1===le.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${le.rank}.`),null!=fe&&I.hu(2===fe.rank||1===fe.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${fe.rank}.`),null!=Oe&&I.hu(2===Oe.rank||1===Oe.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${Oe.rank}.`),Mr(K,Y,le,Oe,fe,V)}}),Si=(0,U.op)({batchNorm3d_:function Ea(T,w,v,k,$,V){const K=(0,P._1)(T,"x","batchNorm"),Y=(0,P._1)(w,"mean","batchNorm"),le=(0,P._1)(v,"variance","batchNorm");let fe,Oe;return null!=$&&(fe=(0,P._1)($,"scale","batchNorm")),null!=k&&(Oe=(0,P._1)(k,"offset","batchNorm")),I.hu(3===K.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${K.rank}.`),I.hu(3===Y.rank||1===Y.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${Y.rank}.`),I.hu(3===le.rank||1===le.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${le.rank}.`),null!=fe&&I.hu(3===fe.rank||1===fe.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${fe.rank}.`),null!=Oe&&I.hu(3===Oe.rank||1===Oe.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${Oe.rank}.`),Mr(K,Y,le,Oe,fe,V)}}),Da=(0,U.op)({batchNorm4d_:function Gi(T,w,v,k,$,V){const K=(0,P._1)(T,"x","batchNorm"),Y=(0,P._1)(w,"mean","batchNorm"),le=(0,P._1)(v,"variance","batchNorm");let fe,Oe;return null!=$&&(fe=(0,P._1)($,"scale","batchNorm")),null!=k&&(Oe=(0,P._1)(k,"offset","batchNorm")),I.hu(4===K.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${K.rank}.`),I.hu(4===Y.rank||1===Y.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${Y.rank}.`),I.hu(4===le.rank||1===le.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${le.rank}.`),null!=fe&&I.hu(4===fe.rank||1===fe.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${fe.rank}.`),null!=Oe&&I.hu(4===Oe.rank||1===Oe.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${Oe.rank}.`),Mr(K,Y,le,Oe,fe,V)}}),Ys=(0,U.op)({bincount_:function ps(T,w,v){const k=(0,P._1)(T,"x","bincount"),$=(0,P._1)(w,"weights","bincount");return I.hu("int32"===k.dtype,()=>`Error in bincount: input dtype must be int32, but got ${k.dtype}`),I.hu(v>=0,()=>`size must be non-negative, but got ${v}.`),I.hu($.size===k.size||0===$.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${k.shape}, weights shape: ${$.shape}.`),G.BV.runKernel(q.zvY,{x:k,weights:$},{size:v})}}),Ki=(0,U.op)({bitwiseAnd_:function Ds(T,w){const v=(0,P._1)(T,"x","bitwiseAnd"),k=(0,P._1)(w,"y","bitwiseAnd");if(!(0,I.cO)(v.shape,k.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${v.shape}, y: ${k.shape}`);if("int32"!==v.dtype||"int32"!==k.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${v.dtype} and type of y: ${k.dtype}`);return G.BV.runKernel(q.hCO,{a:v,b:k})}}),Xi=(0,U.op)({broadcastArgs_:function cl(T,w){const v=(0,P._1)(T,"s0","broadcastArgs","int32"),k=(0,P._1)(w,"s1","broadcastArgs","int32");if(1!==v.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${v.rank}`);if(1!==k.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${k.rank}`);return G.BV.runKernel(q.eEB,{s0:v,s1:k})}}),Yo=(0,U.op)({broadcastTo_:function Ta(T,w){let v=(0,P._1)(T,"broadcastTo","x");const k=v.shape;if((0,I.Mu)(w),w.length<v.rank)throw new Error(`broadcastTo(): shape.length=${w.length} < input.rank=${v.rank}.`);if(w.length>v.rank){const fe=v.shape.slice();for(;fe.length<w.length;)fe.unshift(1);v=(0,we.X)(v,fe)}const $=v.shape,V=Array.from(w);for(let fe=w.length-1;fe>=0;fe--)if($[fe]===w[fe])V[fe]=1;else if(1!==v.shape[fe])throw new Error(`broadcastTo(): [${k}] cannot be broadcast to [${w}].`);return 0===V.map((fe,Oe)=>fe>1?Oe:-1).filter(fe=>fe>=0).length?(0,dn.d)(v):G.BV.runKernel(q.n9L,{x:v},{reps:V})}});var Qs=O(8621);const ul=(0,U.op)({ceil_:function qi(T){const v={x:(0,P._1)(T,"x","ceil","float32")};return G.BV.runKernel(q.gJX,v)}});var Ce=O(8509);const Zi=(0,U.op)({clipByValue_:function Qo(T,w,v){const k=(0,P._1)(T,"x","clipByValue");return I.hu(w<=v,()=>`Error in clip: min (${w}) must be less than or equal to max (${v}).`),w===v?(0,Ce.h)(k.shape,w,k.dtype):G.BV.runKernel(q.xnO,{x:k},{clipValueMin:w,clipValueMax:v})}});var vo=O(9907);const _r=(0,U.op)({concat1d_:function dl(T){return Vt(T,0)}}),Js=(0,U.op)({concat2d_:function vr(T,w){return Vt(T,w)}}),Ei=(0,U.op)({concat3d_:function Jo(T,w){return Vt(T,w)}}),Di=(0,U.op)({concat4d_:function eo(T,w){return Vt(T,w)}}),Po=(0,U.op)({conv2d_:function Dr(T,w,v,k,$="NHWC",V=[1,1],K){const Y=(0,P._1)(T,"x","conv2d","float32"),le=(0,P._1)(w,"filter","conv2d","float32");let fe=Y,Oe=!1;3===Y.rank&&(Oe=!0,fe=(0,we.X)(Y,[1,Y.shape[0],Y.shape[1],Y.shape[2]])),I.hu(4===fe.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${fe.rank}.`),I.hu(4===le.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${le.rank}.`),ke.m("conv2d",k,K);const $e="NHWC"===$?fe.shape[3]:fe.shape[1];I.hu($e===le.shape[2],()=>`Error in conv2d: depth of input (${$e}) must match input depth for filter ${le.shape[2]}.`),I.hu(ke.jT(v,V),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${v} and dilations '${V}'`),I.hu(ke.U3(V),()=>"Error in conv2D: Dilated rates should be larger than 0."),I.hu(ke.U3(v),()=>"Error in conv2D: Strides should be larger than 0.");const Ht=G.BV.runKernel(q.mhS,{x:fe,filter:le},{strides:v,pad:k,dataFormat:$,dilations:V,dimRoundingMode:K});return Oe?(0,we.X)(Ht,[Ht.shape[1],Ht.shape[2],Ht.shape[3]]):Ht}}),Yi=(0,U.op)({conv1d_:function hl(T,w,v,k,$="NWC",V=1,K){const Y=(0,P._1)(T,"x","conv1d"),le=(0,P._1)(w,"filter","conv1d");let fe=Y,Oe=!1;2===Y.rank&&(Oe=!0,fe=(0,we.X)(Y,[1,Y.shape[0],Y.shape[1]])),I.hu(3===fe.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${fe.rank}.`),I.hu(3===le.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${le.rank}.`),ke.m("conv1d",k,K),I.hu(fe.shape[2]===le.shape[1],()=>`Error in conv1d: depth of input (${fe.shape[2]}) must match input depth for filter ${le.shape[1]}.`),I.hu(ke.jT(v,V),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${v} and dilation '${V}'`),I.hu(ke.U3(V),()=>"Error in conv1D: Dilated rates should be larger than 0."),I.hu(ke.U3(v),()=>"Error in conv1D: Stride should be larger than 0."),I.hu("NWC"===$,()=>`Error in conv1d: got dataFormat of ${$} but only NWC is currently supported.`);const $e=(0,we.X)(le,[1,le.shape[0],le.shape[1],le.shape[2]]),bt=(0,we.X)(fe,[fe.shape[0],1,fe.shape[1],fe.shape[2]]),en=Po(bt,$e,[1,v],k,"NHWC",[1,V],K);return(0,we.X)(en,Oe?[en.shape[2],en.shape[3]]:[en.shape[0],en.shape[2],en.shape[3]])}}),$o=(0,U.op)({conv2DBackpropInput_:function ql(T,w,v,k,$,V="NHWC",K){I.hu(T.length===w.rank,()=>`Length of inShape (${T.length}) and rank of dy (${w.rank}) must match`);let Y=T,le=w,fe=!1;3===w.rank&&(fe=!0,le=(0,we.X)(w,[1,w.shape[0],w.shape[1],w.shape[2]]),Y=[1,T[0],T[1],T[2]]),I.hu(4===Y.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${Y.length}.`),I.hu(4===le.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${le.rank}`),I.hu(4===v.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${v.rank}`);const Oe="NHWC"===V?Y[3]:Y[1],$e="NHWC"===V?le.shape[3]:le.shape[1];I.hu(Oe===v.shape[2],()=>`Error in conv2dDerInput: depth of input (${Oe}) must match input depth for filter ${v.shape[2]}.`),I.hu($e===v.shape[3],()=>`Error in conv2dDerInput: depth of output (${$e}) must match output depth for filter ${v.shape[3]}.`),ke.m("conv2dDerInput",$,K);const Ht=G.BV.runKernel(q.wm,{dy:le,filter:v},{strides:k,pad:$,dataFormat:V,dimRoundingMode:K,inputShape:Y});return fe?(0,we.X)(Ht,[Ht.shape[1],Ht.shape[2],Ht.shape[3]]):Ht}}),Zl=(0,U.op)({conv2dTranspose_:function pl(T,w,v,k,$,V){const K=(0,P._1)(T,"x","conv2dTranspose"),Y=(0,P._1)(w,"filter","conv2dTranspose");return $o(v,K,Y,k,$,"NHWC",V)}}),ei=(0,U.op)({conv3d_:function Ps(T,w,v,k,$="NDHWC",V=[1,1,1]){const K=(0,P._1)(T,"x","conv3d"),Y=(0,P._1)(w,"filter","conv3d");let le=K,fe=!1;4===K.rank&&(fe=!0,le=(0,we.X)(K,[1,K.shape[0],K.shape[1],K.shape[2],K.shape[3]])),I.hu(5===le.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${le.rank}.`),I.hu(5===Y.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${Y.rank}.`),I.hu(le.shape[4]===Y.shape[3],()=>`Error in conv3d: depth of input (${le.shape[4]}) must match input depth for filter ${Y.shape[3]}.`),I.hu((0,ke.jT)(v,V),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${v} and dilations '${V}'`),I.hu("NDHWC"===$,()=>`Error in conv3d: got dataFormat of ${$} but only NDHWC is currently supported.`),I.hu((0,ke.U3)(V),()=>"Error in conv3D: Dilated rates should be larger than 0."),I.hu((0,ke.U3)(v),()=>"Error in conv3D: Strides should be larger than 0.");const bt=G.BV.runKernel(q.x12,{x:le,filter:Y},{strides:v,pad:k,dataFormat:$,dilations:V});return fe?(0,we.X)(bt,[bt.shape[1],bt.shape[2],bt.shape[3],bt.shape[4]]):bt}}),ti=(0,U.op)({conv3DBackpropInput_:function hr(T,w,v,k,$){I.hu(T.length===w.rank,()=>`Length of inShape (${T.length}) and rank of dy (${w.rank}) must match`);let V=T,K=w,Y=!1;4===w.rank&&(Y=!0,K=(0,we.X)(w,[1,w.shape[0],w.shape[1],w.shape[2],w.shape[3]]),V=[1,T[0],T[1],T[2],T[3]]);const le=V[4],fe=K.shape[4];I.hu(5===V.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${V.length}.`),I.hu(5===K.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${K.rank}`),I.hu(5===v.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${v.rank}`),I.hu(le===v.shape[3],()=>`Error in conv3dDerInput: depth of input (${le}) must match input depth for filter ${v.shape[3]}.`),I.hu(fe===v.shape[4],()=>`Error in conv3dDerInput: depth of output (${fe}) must match output depth for filter ${v.shape[4]}.`);const bt=G.BV.runKernel(q.ik2,{dy:K,filter:v},{pad:$,strides:k,inputShape:V});return Y?(0,we.X)(bt,[bt.shape[1],bt.shape[2],bt.shape[3],bt.shape[4]]):bt}}),Yl=(0,U.op)({conv3dTranspose_:function to(T,w,v,k,$){const V=(0,P._1)(T,"x","conv3dTranspose"),K=(0,P._1)(w,"filter","conv3dTranspose");return ti(v,V,K,k,$)}}),Lo=(0,U.op)({cos_:function Ql(T){const v={x:(0,P._1)(T,"x","cos","float32")};return G.BV.runKernel(q.mc4,v)}}),Aa=(0,U.op)({cosh_:function Ia(T){const v={x:(0,P._1)(T,"x","cosh","float32")};return G.BV.runKernel(q.TR1,v)}}),fl=(0,U.op)({cumprod_:function $s(T,w=0,v=!1,k=!1){const V={x:(0,P._1)(T,"x","cumprod")};return G.BV.runKernel(q.Byc,V,{axis:w,exclusive:v,reverse:k})}}),Ln=(0,U.op)({cumsum_:function Yt(T,w=0,v=!1,k=!1){const V={x:(0,P._1)(T,"x","cumsum")};return G.BV.runKernel(q.iHb,V,{axis:w,exclusive:v,reverse:k})}}),Tn=(0,U.op)({denseBincount_:function Ls(T,w,v,k=!1){const $=(0,P._1)(T,"x","denseBincount"),V=(0,P._1)(w,"weights","denseBincount");return I.hu("int32"===$.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${$.dtype}`),I.hu($.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${$.rank}.`),I.hu(v>=0,()=>`size must be non-negative, but got ${v}.`),I.hu(V.size===$.size||0===V.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${$.shape}, weights shape: ${V.shape}.`),G.BV.runKernel(q.QRR,{x:$,weights:V},{size:v,binaryOutput:k})}}),xo=(0,U.op)({depthToSpace_:function ni(T,w,v="NHWC"){const k=(0,P._1)(T,"x","depthToSpace","float32"),$="NHWC"===v?k.shape[1]:k.shape[2],V="NHWC"===v?k.shape[2]:k.shape[3],K="NHWC"===v?k.shape[3]:k.shape[1];return I.hu(w>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${w}`),I.hu($*w>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${$} and ${w}  for depthToSpace with input shape\n    ${k.shape}`),I.hu(V*w>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${V} and ${w} for depthToSpace with input shape\n        ${k.shape}`),I.hu(K%(w*w)==0,()=>`Dimension size must be evenly divisible by ${w*w} but is ${K} for depthToSpace with input shape ${k.shape}`),G.BV.runKernel(q.T0n,{x:k},{blockSize:w,dataFormat:v})}}),Bs=(0,U.op)({depthwiseConv2d_:function Ts(T,w,v,k,$="NHWC",V=[1,1],K){const Y=(0,P._1)(T,"x","depthwiseConv2d","float32"),le=(0,P._1)(w,"filter","depthwiseConv2d","float32");let fe=Y,Oe=!1;3===Y.rank&&(Oe=!0,fe=(0,we.X)(Y,[1,Y.shape[0],Y.shape[1],Y.shape[2]])),I.hu(4===fe.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${fe.rank}.`),I.hu(4===le.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${le.rank}.`);const $e="NHWC"===$?fe.shape[3]:fe.shape[1];I.hu($e===le.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${$e}) must match the inChannels dimension in filter ${le.shape[2]}.`),ke.m("depthwiseConv2d",k,K);const Ht=G.BV.runKernel(q.cie,{x:fe,filter:le},{strides:v,pad:k,dataFormat:$,dilations:V,dimRoundingMode:K});return Oe?(0,we.X)(Ht,[Ht.shape[1],Ht.shape[2],Ht.shape[3]]):Ht}}),pr=(0,U.op)({diag_:function Bo(T){const v={x:(0,P._1)(T,"x","diag")};return G.BV.runKernel(q.$w,v)}}),Qi=(0,U.op)({dilation2d_:function fs(T,w,v,k,$=[1,1],V="NHWC"){const K=(0,P._1)(T,"x","dilation2d"),Y=(0,P._1)(w,"filter","dilation2d");I.hu(3===K.rank||4===K.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${K.rank}.`),I.hu(3===Y.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${Y.rank}.`),I.hu("NHWC"===V,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${V}`);let le=K,fe=!1;3===K.rank&&(le=(0,we.X)(K,[1,K.shape[0],K.shape[1],K.shape[2]]),fe=!0),I.hu(le.shape[3]===Y.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${le.shape[3]} vs ${Y.shape[2]}`);const bt=G.BV.runKernel(q.p4S,{x:le,filter:Y},{strides:v,pad:k,dilations:$});return fe?(0,we.X)(bt,[bt.shape[1],bt.shape[2],bt.shape[3]]):bt}});var qn=O(6635),on=O(258);const Jn=(0,U.op)({equal_:function Na(T,w){let v=(0,P._1)(T,"a","equal","string_or_numeric"),k=(0,P._1)(w,"b","equal","string_or_numeric");return[v,k]=(0,Re.makeTypesMatch)(v,k),(0,on.assertAndGetBroadcastShape)(v.shape,k.shape),G.BV.runKernel(q.hdR,{a:v,b:k})}}),jr=(0,U.op)({where_:function Ji(T,w,v){const k=(0,P._1)(w,"a","where"),$=(0,P._1)(v,"b","where"),V=(0,P._1)(T,"condition","where","bool"),K=(0,on.assertAndGetBroadcastShape)((0,on.assertAndGetBroadcastShape)(V.shape,k.shape),$.shape),Y=Yo(V,K),le=Yo(k,K),fe=Yo($,K);return G.BV.runKernel(q.PhF,{condition:Y,t:le,e:fe})}});var Fn=O(37);const ka=(0,U.op)({divNoNan_:function an(T,w){let v=(0,P._1)(T,"a","div"),k=(0,P._1)(w,"b","div");[v,k]=(0,Re.makeTypesMatch)(v,k);const $=(0,qn.h)(v,k),V=(0,Fn.P)($),K=Jn(k,V);return jr(K,V,$)}}),Ma=(0,U.op)({dot_:function ri(T,w){const v=(0,P._1)(T,"t1","dot"),k=(0,P._1)(w,"t2","dot");I.hu(!(1!==v.rank&&2!==v.rank||1!==k.rank&&2!==k.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${v.rank} and ${k.rank}.`);const $=1===v.rank?v.size:v.shape[1],V=1===k.rank?k.size:k.shape[0];if(I.hu($===V,()=>`Error in dot: inner dimensions of inputs must match, but got ${$} and ${V}.`),1===v.rank&&1===k.rank){const K=(0,we.X)(v,[1,-1]),Y=(0,we.X)(k,[-1,1]),le=(0,rn.O)(K,Y);return(0,we.X)(le,[])}if(1===v.rank&&2===k.rank){const K=(0,we.X)(v,[1,-1]),Y=(0,we.X)(k,[k.shape[0],k.shape[1]]),le=(0,rn.O)(K,Y);return(0,we.X)(le,[le.size])}if(2===v.rank&&1===k.rank){const K=(0,we.X)(k,[-1,1]),Y=(0,rn.O)(v,K);return(0,we.X)(Y,[Y.size])}{const K=(0,we.X)(k,[k.shape[0],k.shape[1]]);return(0,rn.O)(v,K)}}}),qe=(0,U.op)({einsum_:function si(T,...w){const v=w.map(($,V)=>(0,P._1)($,`tensors${V}`,"einsum"));return G.BV.runKernel(q.$g6,v,{equation:T})}});var oi=O(4609);const Bn=(0,U.op)({ensureShape_:function un(T,w){const v=(0,P._1)(T,"x","ensureShape","string_or_numeric");if(!(0,I.DK)(v.shape,w))throw new Error(`EnsureShape: Shape of tensor ${v.shape} is not compatible with expected shape ${w}`);return T}}),Jl=(0,U.op)({erf_:function Ti(T){let w=(0,P._1)(T,"x","erf");return I.hu("int32"===w.dtype||"float32"===w.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===w.dtype&&(w=(0,Me.p)(w,"float32")),G.BV.runKernel(q.Omj,{x:w})}});var ii=O(7745);const xr=(0,U.op)({max_:function Vo(T,w=null,v=!1){const $={x:(0,P._1)(T,"x","max")};return G.BV.runKernel(q.YoZ,$,{reductionIndices:w,keepDims:v})}}),Vs=(0,U.op)({min_:function ec(T,w=null,v=!1){const $={x:(0,P._1)(T,"x","min")};return G.BV.runKernel(q.c17,$,{axis:w,keepDims:v})}});var Ra=O(9043),gn=O(316),ai=O(5562),ea=O(4164),Kn=O(5214);function Uo(T,w,v=null){if(0===T.rank)return(0,xe.W)(T);if(1!==T.rank&&null===v)return Uo((0,we.X)(T,[-1]),w,v);if(1===T.rank||"number"==typeof v||Array.isArray(v)&&1===v.length){if(1===w)return(0,Kn.S)((0,xe.W)(T),v);if(w===1/0)return xr((0,xe.W)(T),v);if(w===-1/0)return Vs((0,xe.W)(T),v);if("euclidean"===w||2===w)return(0,ai._)((0,Kn.S)((0,Ra.s)((0,xe.W)(T),(0,gn.i)(2,"int32")),v));throw new Error(`Error in norm: invalid ord value: ${w}`)}if(Array.isArray(v)&&2===v.length){if(1===w)return xr((0,Kn.S)((0,xe.W)(T),v[0]),v[1]-1);if(w===1/0)return xr((0,Kn.S)((0,xe.W)(T),v[1]),v[0]);if(w===-1/0)return Vs((0,Kn.S)((0,xe.W)(T),v[1]),v[0]);if("fro"===w||"euclidean"===w)return(0,ai._)((0,Kn.S)((0,ea.h)(T),v));throw new Error(`Error in norm: invalid ord value: ${w}`)}throw new Error(`Error in norm: invalid axis: ${v}`)}const ta=(0,U.op)({norm_:function ml(T,w="euclidean",v=null,k=!1){const $=Uo(T=(0,P._1)(T,"x","norm"),w,v);let V=$.shape;if(k){const K=(0,I.EC)(v,T.shape);V=ii.rv($.shape,K)}return(0,we.X)($,V)}}),gl=(0,U.op)({euclideanNorm_:function li(T,w=null,v=!1){return ta(T,"euclidean",w,v)}}),En=(0,U.op)({exp_:function ts(T){const v={x:(0,P._1)(T,"x","exp")};return G.BV.runKernel(q.NEP,v)}}),f=(0,U.op)({expandDims_:function E(T,w=0){const v=(0,P._1)(T,"x","expandDims","string_or_numeric");return I.hu(w<=v.rank,()=>"Axis must be <= rank of the tensor"),G.BV.runKernel(q.YFo,{input:v},{dim:w})}}),b=(0,U.op)({expm1_:function g(T){const v={x:(0,P._1)(T,"x","expm1")};return G.BV.runKernel(q.Y0y,v)}}),B=(0,U.op)({tile_:function z(T,w){const v=(0,P._1)(T,"x","tile","string_or_numeric");return I.hu(v.rank===w.length,()=>`Error in transpose: rank of input ${v.rank} must match length of reps ${w}.`),G.BV.runKernel(q.n9L,{x:v},{reps:w})}}),J=(0,U.op)({eye_:function ne(T,w,v,k="float32"){null==w&&(w=T);const $=(0,Qs.f)([T,w],k),V=T<=w?T:w;for(let Y=0;Y<V;++Y)$.set(1,Y,Y);const K=(0,we.X)($.toTensor(),[T,w]);if(null==v)return K;if(1===v.length)return B(f(K,0),[v[0],1,1]);if(2===v.length)return B(f(f(K,0),0),[v[0],v[1],1,1]);if(3===v.length)return B(f(f(f(K,0),0),0),[v[0],v[1],v[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${v.length}D.`)}}),ht=(0,U.op)({floor_:function Ie(T){const v={x:(0,P._1)(T,"x","floor","float32")};return G.BV.runKernel(q.OR,v)}});var dt=O(3273);const Tt=(0,U.op)({gather_:function xt(T,w,v=0,k=0){const $=(0,P._1)(T,"x","gather"),V=(0,P._1)(w,"indices","gather","int32");return G.BV.runKernel(q.qi_,{x:$,indices:V},{axis:v,batchDims:k})}}),ln=(0,U.op)({greater_:function Gt(T,w){let v=(0,P._1)(T,"a","greater","string_or_numeric"),k=(0,P._1)(w,"b","greater","string_or_numeric");return[v,k]=(0,Re.makeTypesMatch)(v,k),(0,on.assertAndGetBroadcastShape)(v.shape,k.shape),G.BV.runKernel(q.iZT,{a:v,b:k})}}),$t=(0,U.op)({greaterEqual_:function Dt(T,w){let v=(0,P._1)(T,"a","greaterEqual","string_or_numeric"),k=(0,P._1)(w,"b","greaterEqual","string_or_numeric");return[v,k]=(0,Re.makeTypesMatch)(v,k),(0,on.assertAndGetBroadcastShape)(v.shape,k.shape),G.BV.runKernel(q.Acj,{a:v,b:k})}});var pn=O(5294);const Us=(0,U.op)({isFinite_:function Vn(T){const v={x:(0,P._1)(T,"x","isFinite")};return G.BV.runKernel(q.avt,v)}}),be=(0,U.op)({isInf_:function Is(T){const v={x:(0,P._1)(T,"x","isInf")};return G.BV.runKernel(q.iWB,v)}}),Oa=(0,U.op)({isNaN_:function ms(T){const v={x:(0,P._1)(T,"x","isNaN")};return G.BV.runKernel(q.r7n,v)}});var Co=O(6151);const yl=(0,U.op)({less_:function Ii(T,w){let v=(0,P._1)(T,"a","less","string_or_numeric"),k=(0,P._1)(w,"b","less","string_or_numeric");return[v,k]=(0,Re.makeTypesMatch)(v,k),(0,on.assertAndGetBroadcastShape)(v.shape,k.shape),G.BV.runKernel(q.vtC,{a:v,b:k})}}),tu=(0,U.op)({lessEqual_:function tc(T,w){let v=(0,P._1)(T,"a","lessEqual","string_or_numeric"),k=(0,P._1)(w,"b","lessEqual","string_or_numeric");return[v,k]=(0,Re.makeTypesMatch)(v,k),(0,on.assertAndGetBroadcastShape)(v.shape,k.shape),G.BV.runKernel(q.CAk,{a:v,b:k})}});function $h(T,w,v){if(v<=0)throw new Error("The number of values should be positive.");return G.BV.runKernel(q.e7N,{},{start:T,stop:w,num:v})}const nc=(0,U.op)({localResponseNormalization_:function Lh(T,w=5,v=1,k=1,$=.5){const V=(0,P._1)(T,"x","localResponseNormalization");I.hu(4===V.rank||3===V.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${V.rank}.`),I.hu(I.GN(w),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${w}.`);let K=V,Y=!1;3===V.rank&&(Y=!0,K=(0,we.X)(V,[1,V.shape[0],V.shape[1],V.shape[2]]));const Oe=G.BV.runKernel(q.eZ0,{x:K},{depthRadius:w,bias:v,alpha:k,beta:$});return Y?(0,we.X)(Oe,[Oe.shape[1],Oe.shape[2],Oe.shape[3]]):Oe}}),na=(0,U.op)({log_:function Fa(T){const v={x:(0,P._1)(T,"x","log","float32")};return G.BV.runKernel(q.ZbH,v)}}),nu=(0,U.op)({log1p_:function Ai(T){const v={x:(0,P._1)(T,"x","log1p")};return G.BV.runKernel(q.kU,v)}});var Ke=O(1335),no=O(3304);const bl=(0,U.op)({softplus_:function Ft(T){const v={x:(0,P._1)(T,"x","softplus")};return G.BV.runKernel(q.MRv,v)}}),_l=(0,U.op)({logSigmoid_:function ru(T){const w=(0,P._1)(T,"x","logSigmoid");return(0,Ke.cb)(k=>({value:(0,no.W)(bl((0,no.W)(k))),gradFunc:K=>(0,gt.d)(K,(0,cn.X)((0,no.W)(k)))}))(w)}});var Un=O(8578);const rd=(0,U.op)({logSoftmax_:function nd(T,w=-1){const v=(0,P._1)(T,"logits","logSoftmax");if(-1===w&&(w=v.rank-1),w!==v.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${v.rank} and axis was ${w}`);return(0,Ke.cb)(($,V)=>{const Y=xr($,w,!0),le=(0,Un.l)($,Y),fe=(0,Un.l)((0,Me.p)(le,"float32"),na((0,Kn.S)(En(le),w,!0)));return V([fe]),{value:fe,gradFunc:($e,bt)=>{const[Lt]=bt,xn=En(Lt);return(0,Un.l)($e,(0,gt.d)((0,Kn.S)($e,w,!0),xn))}}})(v)}}),ro=(0,U.op)({logSumExp_:function ci(T,w=null,v=!1){const k=(0,P._1)(T,"x","logSumExp"),$=(0,I.EC)(w,k.shape),V=xr(k,$,!0),K=(0,Un.l)(k,V),Y=En(K),le=(0,Kn.S)(Y,$),fe=na(le),Oe=(0,re.I)((0,we.X)(V,fe.shape),fe);if(v){const $e=(0,ii.rv)(Oe.shape,$);return(0,we.X)(Oe,$e)}return Oe}}),zs=(0,U.op)({logicalAnd_:function gs(T,w){const v=(0,P._1)(T,"a","logicalAnd","bool"),k=(0,P._1)(w,"b","logicalAnd","bool");return(0,on.assertAndGetBroadcastShape)(v.shape,k.shape),G.BV.runKernel(q.PYm,{a:v,b:k})}}),Pa=(0,U.op)({logicalNot_:function zn(T){const v={x:(0,P._1)(T,"x","logicalNot","bool")};return G.BV.runKernel(q.VfG,v)}}),rc=(0,U.op)({logicalOr_:function su(T,w){const v=(0,P._1)(T,"a","logicalOr","bool"),k=(0,P._1)(w,"b","logicalOr","bool");return(0,on.assertAndGetBroadcastShape)(v.shape,k.shape),G.BV.runKernel(q.MZg,{a:v,b:k})}}),ui=(0,U.op)({logicalXor_:function sd(T,w){const v=(0,P._1)(T,"a","logicalXor","bool"),k=(0,P._1)(w,"b","logicalXor","bool");return(0,on.assertAndGetBroadcastShape)(v.shape,k.shape),zs(rc(T,w),Pa(zs(T,w)))}}),Ni=2147483648,sc=(0,U.op)({searchSorted_:function ou(T,w,v="left"){const k=(0,P._1)(T,"sortedSequence","searchSorted"),$=(0,P._1)(w,"values","searchSorted"),K=$.shape[$.shape.length-1],Y=(0,we.X)(k,[-1,k.shape[k.shape.length-1]]),le=(0,we.X)($,[-1,K]);if(Y.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(Y.shape[0]!==le.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,I.NA)(le.shape)>=Ni)throw new Error(`values tensor size must less than ${Ni}`);if(Y.shape[1]>=Ni)throw new Error(`trailing dim_size must less than ${Ni} for int32 output type, was ${Y.shape[1]}`);return G.BV.runKernel(q.nr8,{sortedSequence:Y,values:le},{side:v})}});function iu(T,w){return sc(T,w,"left")}const lu=(0,U.op)({maxPool_:function au(T,w,v,k,$){const V=(0,P._1)(T,"x","maxPool");let Y=V,le=!1;3===V.rank&&(le=!0,Y=(0,we.X)(V,[1,V.shape[0],V.shape[1],V.shape[2]])),I.hu(4===Y.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${Y.rank}.`),I.hu(ke.jT(v,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${v} and dilations '1'`),ke.m("maxPool",k,$);const $e=G.BV.runKernel(q.mTV,{x:Y},{filterSize:w,strides:v,pad:k,dimRoundingMode:$});return le?(0,we.X)($e,[$e.shape[1],$e.shape[2],$e.shape[3]]):$e}}),oc=(0,U.op)({maxPool3d_:function ra(T,w=[1,1,1],v,k,$,V="NDHWC"){const K=(0,P._1)(T,"x","maxPool3d");let Y=K,le=!1;4===K.rank&&(le=!0,Y=(0,we.X)(K,[1,K.shape[0],K.shape[1],K.shape[2],K.shape[3]])),I.hu(5===Y.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${Y.rank}.`),I.hu("NDHWC"===V,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${V}`),(0,ke.m)("maxPool3d",k,$);const $e=G.BV.runKernel(q.OAf,{x:Y},{filterSize:w,strides:v,pad:k,dimRoundingMode:$,dataFormat:V});return le?(0,we.X)($e,[$e.shape[1],$e.shape[2],$e.shape[3],$e.shape[4]]):$e}}),Bh=(0,U.op)({maxPoolWithArgmax_:function od(T,w,v,k,$=!1){const K={x:(0,P._1)(T,"x","maxPoolWithArgmax")},le=G.BV.runKernel(q.vFR,K,{filterSize:w,strides:v,pad:k,includeBatchInIndex:$});return{result:le[0],indexes:le[1]}}});var id=O(6825);const ic=(0,U.op)({mean_:function cu(T,w=null,v=!1){const $={x:(0,P._1)(T,"x","mean")};return G.BV.runKernel(q.q2K,$,{axis:w,keepDims:v})}});function ns(T,w="float32"){if((0,I.Mu)(T),"complex64"===w){const k=ns(T,"float32"),$=ns(T,"float32");return(0,vo.P)(k,$)}const v=(0,I.wT)((0,I.NA)(T),w);return G.BV.makeTensor(v,T,w)}function ki(T,w="float32"){if((0,I.Mu)(T),"complex64"===w){const k=ki(T,"float32"),$=ns(T,"float32");return(0,vo.P)(k,$)}const v=(0,I.p8)((0,I.NA)(T),w);return G.BV.makeTensor(v,T,w)}var $a=O(708);function Vh(T,w,{indexing:v="xy"}={}){if("xy"!==v&&"ij"!==v)throw new TypeError(`${v} is not a valid third argument to meshgrid`);if(void 0===T)return[];let k=(0,P._1)(T,"x","meshgrid",T instanceof $a.es?T.dtype:"float32");if(void 0===w)return[k];let $=(0,P._1)(w,"y","meshgrid",w instanceof $a.es?w.dtype:"float32");const V=(0,I.NA)(k.shape),K=(0,I.NA)($.shape);return"xy"===v?(k=(0,we.X)(k,[1,-1]),$=(0,we.X)($,[-1,1]),[(0,rn.O)(ki([K,1],k.dtype),k),(0,rn.O)($,ki([1,V],$.dtype))]):(k=(0,we.X)(k,[-1,1]),$=(0,we.X)($,[1,-1]),[(0,rn.O)(k,ki([1,K],k.dtype)),(0,rn.O)(ki([V,1],$.dtype),$)])}const ac=(0,U.op)({minimum_:function uu(T,w){let v=(0,P._1)(T,"a","minimum"),k=(0,P._1)(w,"b","minimum");return[v,k]=(0,Re.makeTypesMatch)(v,k),"bool"===v.dtype&&(v=(0,Me.p)(v,"int32"),k=(0,Me.p)(k,"int32")),(0,on.assertAndGetBroadcastShape)(v.shape,k.shape),G.BV.runKernel(q.q8u,{a:v,b:k})}}),vl=(0,U.op)({mirrorPad_:function ad(T,w,v){I.hu("reflect"===v||"symmetric"===v,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${v}.`);const k=(0,P._1)(T,"x","mirrorPad");if(0===k.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");I.hu(w.length===k.rank,()=>`Padding doesn't match input. Must be ${k.rank}. Got ${w.length}.`);const $="reflect"===v?1:0;for(let Y=0;Y<k.rank;Y++)I.hu(2===w[Y].length,()=>"Invalid number of paddings. Must be length of 2 each."),I.hu(w[Y][0]>=0&&w[Y][0]<=k.shape[Y]-$&&w[Y][1]>=0&&w[Y][1]<=k.shape[Y]-$,()=>`Padding in dimension ${Y} cannot be greater than or equal to ${k.shape[Y]-$} or less than 0 for input of shape ${k.shape}`);return G.BV.runKernel(q.jQs,{x:k},{paddings:w,mode:v})}}),Uh=(0,U.op)({mod_:function De(T,w){let v=(0,P._1)(T,"a","mod"),k=(0,P._1)(w,"b","mod");return[v,k]=(0,Re.makeTypesMatch)(v,k),G.BV.runKernel(q.Vbg,{a:v,b:k})}}),ys=(0,U.op)({moments_:function zh(T,w=null,v=!1){T=(0,P._1)(T,"x","moments");const k=(0,I.EC)(w,T.shape),$=ic(T,k,v);let V=$.shape;v||(V=(0,ii.rv)($.shape,k));const K=(0,ea.h)((0,Un.l)((0,Me.p)(T,"float32"),(0,we.X)($,V)));return{mean:$,variance:ic(K,k,v)}}}),Mi=(0,U.op)({multiRNNCell_:function Hh(T,w,v,k){const $=(0,P._1)(w,"data","multiRNNCell"),V=(0,P.sI)(v,"c","multiRNNCell"),K=(0,P.sI)(k,"h","multiRNNCell");let Y=$;const le=[];for(let $e=0;$e<T.length;$e++){const bt=T[$e](Y,V[$e],K[$e]);le.push(bt[0]),le.push(bt[1]),Y=bt[1]}const fe=[],Oe=[];for(let $e=0;$e<le.length;$e+=2)fe.push(le[$e]),Oe.push(le[$e+1]);return[fe,Oe]}}),Zn=(0,U.op)({multinomial_:function Wh(T,w,v,k=!1){const $=(0,P._1)(T,"logits","multinomial"),V=$.size,K=$.rank;if(V<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${V}.`);if(K>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${K}`);v=v||Math.random();const le={logits:1===K?(0,we.X)($,[1,-1]):$},Oe=G.BV.runKernel(q.NZg,le,{numSamples:w,seed:v,normalized:k});return 1===K?(0,we.X)(Oe,[Oe.size]):Oe}}),La=(0,U.op)({notEqual_:function wo(T,w){let v=(0,P._1)(T,"a","notEqual","string_or_numeric"),k=(0,P._1)(w,"b","notEqual","string_or_numeric");return[v,k]=(0,Re.makeTypesMatch)(v,k),(0,on.assertAndGetBroadcastShape)(v.shape,k.shape),G.BV.runKernel(q.yQU,{a:v,b:k})}});var It=O(2738);const jn=(0,U.op)({onesLike_:function As(T){const v={x:(0,P._1)(T,"x","onesLike")};return G.BV.runKernel(q.qWM,v)}}),Ns=(0,U.op)({outerProduct_:function rs(T,w){const v=(0,P._1)(T,"v1","outerProduct"),k=(0,P._1)(w,"v2","outerProduct");I.hu(1===v.rank&&1===k.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${v.rank} and ${k.rank}.`);const $=(0,we.X)(v,[-1,1]),V=(0,we.X)(k,[1,-1]);return(0,rn.O)($,V)}}),Gr=(0,U.op)({pad_:function Ri(T,w,v=0){const k=(0,P._1)(T,"x","pad");if(0===k.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return G.BV.runKernel(q.lyA,{x:k},{paddings:w,constantValue:v})}}),cd=(0,U.op)({pad1d_:function ld(T,w,v=0){return(0,I.hu)(2===w.length,()=>"Invalid number of paddings. Must be length of 2."),Gr(T,[w],v)}}),jh=(0,U.op)({pad2d_:function lc(T,w,v=0){return(0,I.hu)(2===w.length&&2===w[0].length&&2===w[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),Gr(T,w,v)}}),Pr=(0,U.op)({pad3d_:function Gh(T,w,v=0){return(0,I.hu)(3===w.length&&2===w[0].length&&2===w[1].length&&2===w[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),Gr(T,w,v)}}),vn=(0,U.op)({pad4d_:function Bt(T,w,v=0){return(0,I.hu)(4===w.length&&2===w[0].length&&2===w[1].length&&2===w[2].length&&2===w[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),Gr(T,w,v)}}),so=(0,U.op)({spaceToBatchND_:function fr(T,w,v){const k=(0,P._1)(T,"x","spaceToBatchND");return I.hu(k.rank>=1+w.length,()=>`input rank ${k.rank} should be > than [blockShape] ${w.length}`),I.hu(v.length===w.length,()=>`paddings.shape[0] ${v.length} must be equal to [blockShape] ${w.length}`),I.hu(k.shape.reduce((K,Y,le)=>le>0&&le<=w.length?K&&(Y+v[le-1][0]+v[le-1][1])%w[le-1]==0:K,!0),()=>`input spatial dimensions ${k.shape.slice(1)} with paddings ${v.toString()} must be divisible by blockShapes ${w.toString()}`),G.BV.runKernel(q.TQc,{x:k},{blockShape:w,paddings:v})}}),Cr=(0,U.op)({pool_:function sa(T,w,v,k,$,V,K){null==$&&($=[1,1]),null==V&&(V=1),0===k&&(k="valid");const Y=(0,P._1)(T,"x","maxPool");let le=Y,fe=!1;3===Y.rank&&(fe=!0,le=(0,we.X)(Y,[1,Y.shape[0],Y.shape[1],Y.shape[2]])),I.hu(ke.jT(V,$),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${V} and dilations '${$}'`);const Oe=ke.Xw(le.shape,w,V,$,k),$e=[Oe.dilationHeight,Oe.dilationWidth];let bt;bt="same"===k?function Ba(T,w){const k=T.map((K,Y)=>K+(K-1)*(w[Y]-1)).map(K=>K-1),$=k.map(K=>Math.floor(K/2)),V=k.map((K,Y)=>K-$[Y]);return k.map((K,Y)=>[$[Y],V[Y]])}([Oe.filterHeight,Oe.filterWidth],$e):[[0,0],[0,0]];const Lt=1===$e[0]&&1===$e[1],[Ht,xn]=function ss(T,w,v){const k=v.map(Oe=>Oe[0]),$=v.map(Oe=>Oe[1]),V=T.concat(k,$),K=w.map((Oe,$e)=>(Oe-V[$e]%Oe)%Oe),Y=$.map((Oe,$e)=>Oe+K[$e]),le=w.map((Oe,$e)=>[k[$e],Y[$e]]),fe=w.map((Oe,$e)=>[0,K[$e]]);return[le,fe]}([Oe.inHeight,Oe.inWidth],$e,bt),en=Lt?k:"valid",On=Lt?le:so(le,$e,Ht),qr=("avg"===v?()=>At(On,w,V,en,K):()=>lu(On,w,V,en,K))(),er=Lt?qr:Nn(qr,$e,xn);return fe?(0,we.X)(er,[er.shape[1],er.shape[2],er.shape[3]]):er}});var oa=O(1426),ia=O(2174);const xl=(0,U.op)({prod_:function yn(T,w=null,v=!1){let k=(0,P._1)(T,"x","prod");return"bool"===k.dtype&&(k=(0,Me.p)(k,"int32")),G.BV.runKernel(q.DlI,{x:k},{axis:w,keepDims:v})}}),Va=(0,U.op)({raggedGather_:function ud(T,w,v,k){const $=T.map((Oe,$e)=>(0,P._1)(Oe,`tensors${$e}`,"raggedGather","int32")),V=(0,P._1)(w,"paramsDenseValues","raggedGather"),K=(0,P._1)(v,"indices","raggedGather","int32"),fe=G.BV.runKernel(q.dDz,{paramsNestedSplits:$,paramsDenseValues:V,indices:K},{outputRaggedRank:k});return{outputNestedSplits:fe.slice(0,fe.length-1),outputDenseValues:fe[fe.length-1]}}}),Cl=(0,U.op)({raggedRange_:function Rr(T,w,v){const k=(0,P._1)(T,"starts","raggedRange"),$=(0,P._1)(w,"limits","raggedRange",k.dtype),V=(0,P._1)(v,"deltas","raggedRange",k.dtype),Y=G.BV.runKernel(q.CQl,{starts:k,limits:$,deltas:V});return{rtNestedSplits:Y[0],rtDenseValues:Y[1]}}}),oo=(0,U.op)({raggedTensorToTensor_:function Ua(T,w,v,k,$){const V=(0,P._1)(T,"shape","raggedTensorToTensor","int32"),K=(0,P._1)(w,"values","raggedTensorToTensor"),Y=(0,P._1)(v,"defaultValue","raggedTensorToTensor",K.dtype),le=k.map(($e,bt)=>(0,P._1)($e,`tensors${bt}`,"raggedTensorToTensor","int32"));return G.BV.runKernel(q.BiW,{shape:V,values:K,defaultValue:Y,rowPartitionTensors:le},{rowPartitionTypes:$})}}),du=(0,U.op)({rand_:function wl(T,w,v){(0,I.Mu)(T);const k=(0,I.NA)(T);let $=null;if(null==v||"float32"===v)$=new Float32Array(k);else if("int32"===v)$=new Int32Array(k);else{if("bool"!==v)throw new Error(`Unknown data type ${v}`);$=new Uint8Array(k)}for(let V=0;V<k;V++)$[V]=w();return G.BV.makeTensor($,T,v)}});var So=O(340);class Eo{constructor(w,v,k,$,V){this.mean=w,this.stdDev=v,this.dtype=k,this.nextVal=NaN,this.truncated=$,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const K=V||Math.random();this.random=So.alea(K.toString())}nextValue(){if(!isNaN(this.nextVal)){const $=this.nextVal;return this.nextVal=NaN,$}let w,v,k=!1;for(;!k;){let $,V,K;do{$=2*this.random()-1,V=2*this.random()-1,K=$*$+V*V}while(K>=1||0===K);const Y=Math.sqrt(-2*Math.log(K)/K);w=this.mean+this.stdDev*$*Y,v=this.mean+this.stdDev*V*Y,(!this.truncated||this.isValidTruncated(w))&&(k=!0)}return(!this.truncated||this.isValidTruncated(v))&&(this.nextVal=this.convertValue(v)),this.convertValue(w)}convertValue(w){return null==this.dtype||"float32"===this.dtype?w:Math.round(w)}isValidTruncated(w){return w<=this.upper&&w>=this.lower}}class cc{constructor(w,v,k,$){this.alpha=w,this.beta=1/v,this.dtype=k;const V=$||Math.random();this.randu=So.alea(V.toString()),this.randn=new Eo(0,1,k,!1,this.randu()),this.d=w<1?w+2/3:w-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let w,v,k,$,V,K;for(;;){do{$=this.randn.nextValue(),K=1+this.c*$}while(K<=0);if(K*=K*K,w=$*$,v=1-.331*w*w,k=.5*w+this.d*(1-K+Math.log(K)),V=this.randu(),V<v||Math.log(V)<k)break}return K*=1/this.beta*this.d,this.alpha<1&&(K*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(K)}convertValue(w){return"float32"===this.dtype?w:Math.round(w)}}class uc{constructor(w=0,v=1,k,$){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=w,this.range=v-w,this.dtype=k,null==$&&($=Math.random()),"number"==typeof $&&($=$.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${w} - ${v} <= 1 and dtype is not float`);this.random=So.alea($)}convertValue(w){return this.canReturnFloat()?w:Math.round(w)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const El=(0,U.op)({randomGamma_:function za(T,w,v=1,k="float32",$){if((0,I.Mu)(T),null==v&&(v=1),null==k&&(k="float32"),"float32"!==k&&"int32"!==k)throw new Error(`Unsupported data type ${k}`);const V=new cc(w,v,k,$),K=(0,Qs.f)(T,k);for(let Y=0;Y<K.values.length;Y++)K.values[Y]=V.nextValue();return K.toTensor()}}),Kh=(0,U.op)({randomNormal_:function Kr(T,w=0,v=1,k,$){if((0,I.Mu)(T),null!=k&&"bool"===k)throw new Error(`Unsupported data type ${k}`);const V=new Eo(w,v,k,!1,$),K=(0,Qs.f)(T,k);for(let Y=0;Y<K.values.length;Y++)K.values[Y]=V.nextValue();return K.toTensor()}}),ks=(0,U.op)({randomStandardNormal_:function Hs(T,w,v){if(null!=w&&"bool"===w)throw new Error(`Unsupported data type ${w}`);return Kh(T,0,1,w,v)}}),di=(0,U.op)({randomUniform_:function hu(T,w=0,v=1,k="float32",$){(0,I.Mu)(T);const V=(0,Qs.f)(T,k),K=new uc(w,v,null,$);for(let Y=0;Y<V.values.length;Y++)V.values[Y]=K.nextValue();return V.toTensor()}}),Do=(0,U.op)({randomUniformInt_:function hc(T,w,v,k){return di(T,w,v,"int32",k)}});function aa(T,w,v=1,k="float32"){if(0===v)throw new Error("Cannot have a step of zero");return G.BV.runKernel(q.e6w,{},{start:T,stop:w,step:v,dtype:k})}var pc=O(5732);const Xh=(0,U.op)({reciprocal_:function em(T){const v={x:(0,P._1)(T,"x","reciprocal")};return G.BV.runKernel(q.$HU,v)}});var pu=O(4563),hd=O(5049);const la=(0,U.op)({reverse_:function tm(T,w){const k={x:(0,P._1)(T,"x","reverse")};return G.BV.runKernel(q.mKl,k,{dims:w})}}),x=(0,U.op)({reverse1d_:function R(T){const w=(0,P._1)(T,"x","reverse");return I.hu(1===w.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${w.rank}.`),la(w,0)}}),L=(0,U.op)({reverse2d_:function M(T,w){const v=(0,P._1)(T,"x","reverse");return I.hu(2===v.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${v.rank}.`),la(v,w)}}),oe=(0,U.op)({reverse3d_:function H(T,w){const v=(0,P._1)(T,"x","reverse");return I.hu(3===v.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${v.rank}.`),la(v,w)}}),Te=(0,U.op)({reverse4d_:function me(T,w){const v=(0,P._1)(T,"x","reverse");return I.hu(4===v.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${v.rank}.`),la(v,w)}}),Ze=(0,U.op)({round_:function Xe(T){const v={x:(0,P._1)(T,"x","round")};return G.BV.runKernel(q.e07,v)}}),Qe=(0,U.op)({rsqrt_:function St(T){const v={x:(0,P._1)(T,"x","rsqrt","float32")};return G.BV.runKernel(q.bV0,v)}}),Nt=(0,U.op)({selu_:function Je(T){const v={x:(0,P._1)(T,"x","selu")};return G.BV.runKernel(q.oFR,v)}}),Jt=(0,U.op)({separableConv2d_:function zt(T,w,v,k,$,V=[1,1],K="NHWC"){const Y=(0,P._1)(T,"x","separableConv2d"),le=(0,P._1)(w,"depthwiseFilter","separableConv2d"),fe=(0,P._1)(v,"pointwiseFilter","separableConv2d");let Oe=Y,$e=!1;if(3===Y.rank&&($e=!0,Oe=(0,we.X)(Y,[1,Y.shape[0],Y.shape[1],Y.shape[2]])),"NCHW"===K)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");I.hu(4===Oe.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${Oe.rank}.`),I.hu(4===le.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${le.rank}.`),I.hu(4===fe.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${le.rank}.`),I.hu(1===fe.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${fe.shape[0]}.`),I.hu(1===fe.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${fe.shape[1]}.`);const bt=le.shape[2],Lt=le.shape[3];I.hu(fe.shape[2]===bt*Lt,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${bt*Lt}, but got ${fe.shape[2]}.`);const Ht=Bs(Oe,le,k,$,K,V),en=Po(Ht,fe,1,"valid",K);return $e?(0,we.X)(en,[en.shape[1],en.shape[2],en.shape[3]]):en}});var bn=O(5861);function os(){return(os=(0,bn.Z)(function*(T,w){const v=(0,P._1)(T,"x","setdiff1d"),k=(0,P._1)(w,"y","setdiff1d");I.hu(v.dtype===k.dtype,()=>`x and y should have the same dtype, but got x (${v.dtype}) and y (${k.dtype}).`),I.hu(1===v.rank,()=>`x should be 1D tensor, but got x (${v.shape}).`),I.hu(1===k.rank,()=>`y should be 1D tensor, but got y (${k.shape}).`);const $=yield v.data(),V=yield k.data(),K=new Set(V);let Y=0;for(let Oe=0;Oe<$.length;Oe++)K.has($[Oe])||Y++;const le=new $a.YD([Y],v.dtype),fe=new $a.YD([Y],"int32");for(let Oe=0,$e=0;Oe<$.length;Oe++)K.has($[Oe])||(le.values[$e]=$[Oe],fe.values[$e]=Oe,$e++);return[le.toTensor(),fe.toTensor()]})).apply(this,arguments)}const Zt=function Xn(T,w){return os.apply(this,arguments)},as=(0,U.op)({sign_:function is(T){const v={x:(0,P._1)(T,"x","sign")};return G.BV.runKernel(q.i5y,v)}}),pd=(0,U.op)({sin_:function fu(T){const v={x:(0,P._1)(T,"x","sin","float32")};return G.BV.runKernel(q.RQH,v)}}),To=(0,U.op)({sinh_:function io(T){const v={x:(0,P._1)(T,"x","sinh")};return G.BV.runKernel(q.wYB,v)}}),ca=(0,U.op)({slice1d_:function Tr(T,w,v){const k=(0,P._1)(T,"x","slice1d");return I.hu(1===k.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${k.rank} tensor`),Rn(k,[w],[v])}}),qh=(0,U.op)({slice2d_:function fd(T,w,v){const k=(0,P._1)(T,"x","slice2d");return I.hu(2===k.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${k.rank} tensor`),Rn(k,w,v)}}),md=(0,U.op)({slice3d_:function Zh(T,w,v){const k=(0,P._1)(T,"x","slice3d");return I.hu(3===k.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${k.rank} tensor`),Rn(k,w,v)}}),Mw=(0,U.op)({slice4d_:function Lb(T,w,v){const k=(0,P._1)(T,"x","slice4d");return I.hu(4===k.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${k.rank} tensor`),Rn(k,w,v)}}),Yh=(0,U.op)({softmax_:function nm(T,w=-1){const v=(0,P._1)(T,"logits","softmax","float32");if(-1===w&&(w=v.rank-1),w!==v.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${v.rank} and dim was ${w}`);return G.BV.runKernel(q.Gcp,{logits:v},{dim:w})}}),fc=(0,U.op)({fft_:function Bb(T){return(0,I.hu)("complex64"===T.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${T.dtype}.`),G.BV.runKernel(q.vwp,{input:T})}}),Qh=(0,U.op)({ifft_:function Vb(T){return(0,I.hu)("complex64"===T.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${T.dtype}.`),G.BV.runKernel(q.Qg5,{input:T})}}),Ub=(0,U.op)({irfft_:function Rw(T){const w=T.shape[T.shape.length-1],v=T.size/w;let k;if(w<=2){const $=(0,we.X)(T,[v,w]);k=Qh($)}else{const $=[v,2*(w-1)],V=(0,we.X)((0,pc.k)(T),[v,w]),K=(0,we.X)((0,pn.a)(T),[v,w]),Y=la(Rn(V,[0,1],[v,w-2]),1),le=(0,gt.d)(la(Rn(K,[0,1],[v,w-2]),1),(0,gn.i)(-1)),fe=Vt([V,Y],1),Oe=Vt([K,le],1),$e=(0,we.X)((0,vo.P)(fe,Oe),[$[0],$[1]]);k=Qh($e)}if(k=(0,pc.k)(k),3===T.rank&&0!==T.shape[0]){const $=k,V=T.shape[0];k=(0,we.X)(k,[V,k.shape[0]/V,k.shape[1]]),$.dispose()}return k}}),mu=(0,U.op)({split_:function rm(T,w,v=0){const $={x:(0,P._1)(T,"x","split")};return G.BV.runKernel(q.L8s,$,{numOrSizeSplits:w,axis:v})}}),ao=(0,U.op)({rfft_:function zb(T,w){(0,I.hu)("float32"===T.dtype,()=>`The dtype for rfft() must be real value but got ${T.dtype}`);let v=T.shape[T.shape.length-1];const k=T.size/v;let $;if(null!=w&&w<v){const Ht=T.shape.map(en=>0),xn=T.shape.map(en=>en);xn[T.shape.length-1]=w,$=Rn(T,Ht,xn),v=w}else if(null!=w&&w>v){const Ht=T.shape.map(xn=>xn);Ht[T.shape.length-1]=w-v,$=Vt([T,ns(Ht)],T.shape.length-1),v=w}else $=T;const V=(0,Fn.P)($),K=(0,we.X)((0,vo.P)($,V),[k,v]),Y=fc(K),le=Math.floor(v/2)+1,fe=(0,pc.k)(Y),Oe=(0,pn.a)(Y),$e=mu(fe,[le,v-le],fe.shape.length-1),bt=mu(Oe,[le,v-le],Oe.shape.length-1),Lt=$.shape.slice();return Lt[$.shape.length-1]=le,(0,we.X)((0,vo.P)($e[0],bt[0]),Lt)}}),om=(0,U.op)({squaredDifference_:function sm(T,w){let v=(0,P._1)(T,"a","squaredDifference"),k=(0,P._1)(w,"b","squaredDifference");return[v,k]=(0,Re.makeTypesMatch)(v,k),(0,on.assertAndGetBroadcastShape)(v.shape,k.shape),G.BV.runKernel(q._tC,{a:v,b:k},{})}}),gd=(0,U.op)({squeeze_:function Hb(T,w){const v=(0,P._1)(T,"x","squeeze","string_or_numeric");return(0,we.X)(v,(0,I.bp)(v.shape,w).newShape)}}),gu=(0,U.op)({stack_:function im(T,w=0){const v=(0,P.sI)(T,"tensors","stack","string_or_numeric");return I.hu(v.length>=1,()=>"Pass at least one tensor to tf.stack"),v.length>0&&I.hu(w<=v[0].rank,()=>"Axis must be <= rank of the tensor"),G.BV.runKernel(q.QiL,v,{axis:w})}});var Jh=O(6166);const Oi=(0,U.op)({stridedSlice_:function Wb(T,w,v,k,$=0,V=0,K=0,Y=0,le=0){const Oe={x:(0,P._1)(T,"x","stridedSlice","string_or_numeric")};return G.BV.runKernel(q.jQk,Oe,{begin:w,end:v,strides:k,beginMask:$,endMask:V,ellipsisMask:K,newAxisMask:Y,shrinkAxisMask:le})}}),lm=(0,U.op)({tan_:function am(T){const v={x:(0,P._1)(T,"x","tan","float32")};return G.BV.runKernel(q.sEM,v)}});var or=O(1973),yu=O(3906);function lo(T,w){(0,I.Cq)(T);const v=(0,P.C)(T,w);if(1!==v.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,yu.H)(T,null,v,w)}function ls(T,w,v){if((0,I.Cq)(T),null!=w&&2!==w.length)throw new Error("tensor2d() requires shape to have two numbers");const k=(0,P.C)(T,v);if(2!==k.length&&1!==k.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===k.length&&null==w)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,yu.H)(T,w,k,v)}var jb=O(3157);function cm(T,w,v){if((0,I.Cq)(T),null!=w&&4!==w.length)throw new Error("tensor4d() requires shape to have four numbers");const k=(0,P.C)(T,v);if(4!==k.length&&1!==k.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===k.length&&null==w)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,yu.H)(T,w,k,v)}function mc(T,w,v){if((0,I.Cq)(T),null!=w&&5!==w.length)throw new Error("tensor5d() requires shape to have five numbers");const k=(0,P.C)(T,v);if(5!==k.length&&1!==k.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===k.length&&null==w)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,yu.H)(T,w,k,v)}function co(T,w,v){if((0,I.Cq)(T),null!=w&&6!==w.length)throw new Error("tensor6d() requires shape to have six numbers");const k=(0,P.C)(T,v);if(6!==k.length&&1!==k.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===k.length&&null==w)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return(0,yu.H)(T,w=w||k,k,v)}var um=O(2808);const Gb=(0,U.op)({tensorScatterUpdate_:function yd(T,w,v){const k=(0,P._1)(T,"tensor","tensorScatterupdate"),$=(0,P._1)(w,"indices","tensorScatterupdate","int32"),V=(0,P._1)(v,"updates","tensorScatterupdate");if(um.validateInput(V,$,k.shape),k.dtype!==V.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${k.dtype} and ${V.dtype}.`);return G.BV.runKernel(q.SIB,{tensor:k,indices:$,updates:V},{})}}),dm=(0,U.op)({topk_:function Ha(T,w=1,v=!0){const k=(0,P._1)(T,"x","topk");if(0===k.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const $=k.shape[k.shape.length-1];if(w<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${w}`);if(w>$)throw new Error(`'k' passed to topk() must be <= the last dimension (${$}) but got ${w}`);const V={x:k},K={k:w,sorted:v},[Y,le]=G.BV.runKernel(q.cWu,V,K);return{values:Y,indices:le}}}),hm=(0,U.op)({truncatedNormal_:function Kb(T,w=0,v=1,k,$){if((0,I.Mu)(T),null!=k&&"bool"===k)throw new Error("Unsupported data type $ { dtype }");const V=new Eo(w,v,k,!0,$),K=(0,Qs.f)(T,k);for(let Y=0;Y<K.values.length;Y++)K.values[Y]=V.nextValue();return K.toTensor()}}),fm=(0,U.op)({unique_:function pm(T,w=0){const v=(0,P._1)(T,"x","unique","string_or_numeric");(0,I.hu)(v.rank>0,()=>"The input tensor must be at least 1D");const k={x:v},$={axis:w},[V,K]=G.BV.runKernel(q.kpP,k,$);return{values:V,indices:K}}}),fn=(0,U.op)({unsortedSegmentSum_:function Xb(T,w,v){const k=(0,P._1)(T,"x","unsortedSegmentSum"),$=(0,P._1)(w,"segmentIds","unsortedSegmentSum","int32");return(0,I.hu)((0,I.GN)(v),()=>"numSegments must be of dtype int"),G.BV.runKernel(q.Qvg,{x:k,segmentIds:$},{numSegments:v})}}),gm=(0,U.op)({unstack_:function mm(T,w=0){const v=(0,P._1)(T,"x","unstack","string_or_numeric");return I.hu(w>=-v.shape.length&&w<v.shape.length,()=>`Axis = ${w} is not in [-${v.shape.length}, ${v.shape.length})`),G.BV.runKernel(q.ToN,{value:v},{axis:w})}});function qb(T,w){return sc(T,w,"right")}function Zb(T,w=!0,v,k){return G.BV.makeVariable(T,w,v,k)}var Yb=O(2842);function Wa(){return(Wa=(0,bn.Z)(function*(T){const w=(0,P._1)(T,"condition","whereAsync","bool"),v=yield w.data(),k=(0,Yb.Z)(w.shape,v);return T!==w&&w.dispose(),k})).apply(this,arguments)}const bm=function ym(T){return Wa.apply(this,arguments)};function ep(){return(ep=(0,bn.Z)(function*(T,w,v){const k=(0,P._1)(T,"tensor","boolMask"),$=(0,P._1)(w,"mask","boolMask","bool"),V=v??0,K=$.rank,Y=k.shape;I.hu(K>0,()=>"mask cannot be scalar"),I.k5(Y.slice(V,V+K),$.shape,"mask's shape must match the first K dimensions of tensor's shape,");let le=1;for(let xn=V;xn<V+K;xn++)le*=Y[xn];const fe=Y.slice(0,V).concat([le],Y.slice(V+K)),Oe=(0,we.X)(k,fe),$e=(0,we.X)($,[-1]),bt=yield bm($e),Lt=gd(bt,[1]),Ht=Tt(Oe,Lt,V);return T!==k&&k.dispose(),w!==$&&$.dispose(),Lt.dispose(),Oe.dispose(),$e.dispose(),bt.dispose(),Ht})).apply(this,arguments)}const Jb=function Qb(T,w,v){return ep.apply(this,arguments)};var tp=O(9540);const Wn=(0,U.op)({movingAverage_:function ft(T,w,v,k,$=!0){const V=(0,P._1)(T,"v","movingAverage"),K=(0,P._1)(w,"x","movingAverage"),Y=(0,P._1)(v,"decay","movingAverage");(0,Re.assertTypesMatch)(V,K),I.hu(I.cO(V.shape,K.shape),()=>"Shape mismatch in v and x");const le=(0,gn.i)(1),fe=(0,Un.l)(le,Y);let Oe=(0,gt.d)((0,Un.l)(K,V),fe);if($){I.hu(null!=k,()=>"When using zeroDebias: true, step is required.");const $e=(0,P._1)(k,"step","movingAverage");Oe=(0,qn.h)(Oe,(0,Un.l)(le,(0,Ra.s)(Y,$e)))}return(0,re.I)(V,Oe)}}),vm=(0,U.op)({scatterND_:function _m(T,w,v){(0,I.Mu)(v);const k=(0,P._1)(T,"indices","scatterND","int32"),$=(0,P._1)(w,"updates","scatterND");return um.validateInput($,k,v),G.BV.runKernel(q.xQA,{indices:k,updates:$},{shape:v})}}),bu=(0,U.op)({sparseToDense_:function xm(T,w,v,k=0){(0,I.Mu)(v);const $=(0,P._1)(T,"sparseIndices","sparseToDense","int32"),V=(0,P._1)(w,"sparseValues","sparseToDense","string_or_numeric"),K=(0,P._1)(k,"defaultValue","sparseToDense",V.dtype);return function bs(T,w,v,k){if("int32"!==T.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${T.dtype}.`);if(T.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${T.shape}.`);const $=T.rank>0?T.shape[0]:1,V=T.rank>1?T.shape[1]:1;if(v.length!==V)throw new Error(`outputShape has incorrect number of elements:, ${v.length}, should be: ${V}.`);if(0!==w.rank&&(1!==w.rank||w.size!==$))throw new Error(`sparseValues has incorrect shape ${w.shape}, should be [] or [${$}]`);if(w.dtype!==k.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}($,V,v,K),G.BV.runKernel(q.D2d,{sparseIndices:$,sparseValues:V,defaultValue:K},{outputShape:v})}}),np=(0,U.op)({gatherND_:function Fi(T,w){const v=(0,P._1)(w,"indices","gatherND","int32"),$={params:(0,P._1)(T,"x","gatherND","string_or_numeric"),indices:v};return G.BV.runKernel(q.q1x,$)}}),Ow=(0,U.op)({dropout_:function e_(T,w,v,k){const $=(0,P._1)(T,"x","dropout");if(I.hu("float32"===$.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${$.dtype} tensor instead.`),I.hu(w>=0&&w<1,()=>`rate must be a float in the range [0, 1), but got ${w}.`),0===w)return T instanceof $a.es?$.clone():$;const V=function rp(T,w){if(null==w)return T.shape.slice();if(I.cO(T.shape,w))return w;if(T.shape.length===w.length){const v=[];for(let k=0;k<T.shape.length;k++)v.push(null==w[k]&&null!=T.shape[k]?T.shape[k]:w[k]);return v}return w}($,v),K=1-w,Y=(0,qn.h)(ht((0,re.I)(di(V,0,1,"float32",k),K)),K);return(0,gt.d)($,Y)}});function sp(T){return Math.floor(Math.pow(2,Math.ceil(Math.log(T)/Math.log(2))))}function _s(T,w,v){const k=1-T%2,$=new Float32Array(T);for(let V=0;V<T;++V){const K=2*Math.PI*V/(T+k-1);$[V]=w-v*Math.cos(K)}return lo($,"float32")}function bd(){return(bd=(0,bn.Z)(function*(T,w,v=1){const k=(0,P._1)(T,"predictions","inTopK"),$=(0,P._1)(w,"targets","inTopK");(0,I.hu)(k.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${k.rank}`),(0,I.hu)(k.rank-1===$.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${k.rank} and targets rank ${$.rank}`),(0,I.k5)(k.shape.slice(0,k.shape.length-1),$.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const V=k.shape[k.shape.length-1];(0,I.hu)(v>0&&v<=V,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${V}), but got ${v}`);const K=yield k.data(),Y=yield $.data(),[le,fe]=[K.length/V,V],Oe=(0,I.WP)("bool",le);for(let $e=0;$e<le;$e++){const bt=$e*fe,Lt=K.subarray(bt,bt+fe),Ht=[];for(let xn=0;xn<Lt.length;xn++)Ht.push({value:Lt[xn],index:xn});Ht.sort((xn,en)=>en.value-xn.value),Oe[$e]=0;for(let xn=0;xn<v;xn++)if(Ht[xn].index===Y[$e]){Oe[$e]=1;break}}return T!==k&&k.dispose(),w!==$&&$.dispose(),(0,or.X)(Oe,$.shape,"bool")})).apply(this,arguments)}const gc=function ua(T,w){return bd.apply(this,arguments)},t_=(0,U.op)({conv2DBackpropFilter_:function da(T,w,v,k,$,V="NHWC",K){let Y=T;3===T.rank&&(Y=(0,we.X)(T,[1,T.shape[0],T.shape[1],T.shape[2]]));let le=w;3===le.rank&&(le=(0,we.X)(w,[1,w.shape[0],w.shape[1],w.shape[2]])),I.hu(4===Y.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${Y.shape}.`),I.hu(4===le.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${le.shape}.`),I.hu(4===v.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${v}.`);const fe="NHWC"===V?Y.shape[3]:Y.shape[1],Oe="NHWC"===V?le.shape[3]:le.shape[1];return I.hu(fe===v[2],()=>`Error in conv2dDerFilter: depth of input ${fe}) must match input depth in filter (${v[2]}.`),I.hu(Oe===v[3],()=>`Error in conv2dDerFilter: depth of dy (${Oe}) must match output depth for filter (${v[3]}).`),ke.m("conv2dDerFilter",$,K),G.BV.runKernel(q.wUP,{x:Y,dy:le},{strides:k,pad:$,dataFormat:V,dimRoundingMode:K,filterShape:v})}});var Io=O(8868);const r_=(0,U.op)({fusedConv2d_:function n_({x:T,filter:w,strides:v,pad:k,dataFormat:$="NHWC",dilations:V=[1,1],dimRoundingMode:K,bias:Y,activation:le="linear",preluActivationWeights:fe,leakyreluAlpha:Oe}){if(!1===(0,Io.uy)(G.BV.state.gradientDepth,le=le||"linear")){I.hu("NHWC"===$,()=>`Error in fused conv2d: got dataFormat of ${$} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let In=Po(T,w,v,k,$,V,K);return null!=Y&&(In=(0,re.I)(In,Y)),(0,Io.QH)(In,le,fe,Oe)}const $e=(0,P._1)(T,"x","conv2d","float32"),bt=(0,P._1)(w,"filter","conv2d","float32");let Lt=$e,Ht=!1;3===$e.rank&&(Ht=!0,Lt=(0,we.X)($e,[1,$e.shape[0],$e.shape[1],$e.shape[2]])),I.hu(4===Lt.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${Lt.rank}.`),I.hu(4===bt.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${bt.rank}.`),ke.m("fused conv2d",k,K);const xn="NHWC"===$?Lt.shape[3]:Lt.shape[1];I.hu(bt.shape[2]===xn,()=>`Error in conv2d: depth of input (${xn}) must match input depth for filter ${bt.shape[2]}.`),I.hu(ke.jT(v,V),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${v} and dilations '${V}'`);const en=ke.Ix(Lt.shape,bt.shape,v,V,k,K);let On,$r;if(null!=Y&&(On=(0,P._1)(Y,"bias","fused conv2d"),[On]=(0,Re.makeTypesMatch)(On,$e),"NHWC"===$?on.assertAndGetBroadcastShape(en.outShape,On.shape):(I.hu(On.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${On.shape.length}.`),I.hu(0===On.shape.length||On.shape[0]===en.outChannels||1===On.shape[0],()=>`Error in fused conv2d: bias shape (${On.shape}) is not compatible with the number of output channels (${en.outChannels})`))),null!=fe){const In=fe.shape;if(I.hu(In.length<=1||3===In.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${In.length}.`),1===In.length)I.hu(1===In[0]||In[0]===en.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${In}) is not compatible with the number of output channels (${en.outChannels}).`);else if(3===In.length)try{on.assertAndGetBroadcastShape(In,en.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${In}) is not compatible with the output shape of the conv2d (${en.outShape}).`)}$r=(0,P._1)(fe,"prelu weights","fused conv2d")}const qr=(In,Lr)=>{I.hu("NHWC"===$,()=>`Error in gradient of fused conv2D: got dataFormat of ${$} but only NHWC is currently supported.`);const[wr,ir,ar,Ar]=Lr,Wo=(0,Io.Fr)(In,ar,le);I.hu(ke.I0(V),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${V}'`);const uo=[$o(ir.shape,Wo,wr,v,k),t_(ir,Wo,wr.shape,v,k)];if(null!=Ar){const Ec=(0,Io.pf)(Ar,Wo);uo.push(Ec)}return uo},er={x:Lt,filter:bt,bias:On,preluActivationWeights:$r},Ur={strides:v,pad:k,dataFormat:$,dilations:V,dimRoundingMode:K,activation:le,leakyreluAlpha:Oe};return null==Y?(0,Ke.cb)((Lr,wr,ir)=>{let ar=G.BV.runKernel(q._V0,er,Ur);return ir([wr,Lr,ar]),Ht&&(ar=(0,we.X)(ar,[ar.shape[1],ar.shape[2],ar.shape[3]])),{value:ar,gradFunc:qr}})(Lt,bt):(0,Ke.cb)((Lr,wr,ir,ar)=>{let Ar=G.BV.runKernel(q._V0,er,Ur);return ar([wr,Lr,Ar,ir]),Ht&&(Ar=(0,we.X)(Ar,[Ar.shape[1],Ar.shape[2],Ar.shape[3]])),{value:Ar,gradFunc:qr}})(Lt,bt,On)}}),ip=(0,U.op)({depthwiseConv2dNativeBackpropFilter_:function op(T,w,v,k,$,V=[1,1],K){let Y=T;3===T.rank&&(Y=(0,we.X)(T,[1,T.shape[0],T.shape[1],T.shape[2]]));let le=w;return 3===le.rank&&(le=(0,we.X)(w,[1,w.shape[0],w.shape[1],w.shape[2]])),G.BV.runKernel(q.sL$,{x:Y,dy:le},{strides:k,pad:$,dimRoundingMode:K,dilations:V,filterShape:v})}}),ap=(0,U.op)({depthwiseConv2dNativeBackpropInput_:function Cm(T,w,v,k,$,V=[1,1],K){let Y=w,le=!1;3===w.rank&&(le=!0,Y=(0,we.X)(w,[1,w.shape[0],w.shape[1],w.shape[2]]));const $e=G.BV.runKernel(q.y7R,{dy:Y,filter:v},{strides:k,pad:$,dimRoundingMode:K,dilations:V,inputShape:T});return le?(0,we.X)($e,[$e.shape[1],$e.shape[2],$e.shape[3]]):$e}}),wm=(0,U.op)({fusedDepthwiseConv2d_:function s_({x:T,filter:w,strides:v,pad:k,dataFormat:$="NHWC",dilations:V=[1,1],dimRoundingMode:K,bias:Y,activation:le="linear",preluActivationWeights:fe,leakyreluAlpha:Oe}){if(!1===(0,Io.uy)(G.BV.state.gradientDepth,le)){let Ur=Bs(T,w,v,k,$,V,K);return null!=Y&&(Ur=(0,re.I)(Ur,Y)),(0,Io.QH)(Ur,le,fe,Oe)}const $e=(0,P._1)(T,"x","depthwiseConv2d","float32"),bt=(0,P._1)(w,"filter","depthwiseConv2d","float32");let Lt=$e,Ht=!1;3===$e.rank&&(Ht=!0,Lt=(0,we.X)($e,[1,$e.shape[0],$e.shape[1],$e.shape[2]])),I.hu(4===Lt.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${Lt.rank}.`),I.hu(4===bt.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${bt.rank}.`),I.hu(Lt.shape[3]===bt.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${Lt.shape[3]}) must match the inChannels dimension in filter ${bt.shape[2]}.`),null==V&&(V=[1,1]),I.hu(ke.jT(v,V),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${v} and dilations '${V}'`),ke.m("fused depthwiseConv2d",k,K);const xn=ke.Ix(Lt.shape,bt.shape,v,V,k,K,!0);let en,On;null!=Y&&(en=(0,P._1)(Y,"bias","fused conv2d"),[en]=(0,Re.makeTypesMatch)(en,$e),on.assertAndGetBroadcastShape(xn.outShape,en.shape)),null!=fe&&(On=(0,P._1)(fe,"prelu weights","fused depthwiseConv2d"));const $r=(Ur,In)=>{I.hu(ke.I0(V),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${V}'`);const[Lr,wr,ir,ar]=In,Ar=(0,Io.Fr)(Ur,ir,le),Wo=ap(wr.shape,Ar,Lr,v,k,V,K),No=ip(wr,Ar,Lr.shape,v,k,V,K);return null!=ar?[Wo,No,(0,Io.pf)(en,Ar)]:[Wo,No]},qr={x:Lt,filter:bt,bias:en,preluActivationWeights:On},er={strides:v,pad:k,dataFormat:$,dilations:V,dimRoundingMode:K,activation:le,leakyreluAlpha:Oe};return null==Y?(0,Ke.cb)((In,Lr,wr)=>{let ir=G.BV.runKernel(q.luS,qr,er);return wr([Lr,In,ir]),Ht&&(ir=(0,we.X)(ir,[ir.shape[1],ir.shape[2],ir.shape[3]])),{value:ir,gradFunc:$r}})(Lt,bt):(0,Ke.cb)((In,Lr,wr,ir)=>{let ar=G.BV.runKernel(q.luS,qr,er);return ir([Lr,In,ar,wr]),Ht&&(ar=(0,we.X)(ar,[ar.shape[1],ar.shape[2],ar.shape[3]])),{value:ar,gradFunc:$r}})(Lt,bt,en)}}),Sm=(0,U.op)({fusedMatMul_:function lp({a:T,b:w,transposeA:v=!1,transposeB:k=!1,bias:$,activation:V="linear",preluActivationWeights:K,leakyreluAlpha:Y=.2}){if(!1===(0,Io.uy)(G.BV.state.gradientDepth,V)){let Ar=(0,rn.O)(T,w,v,k);return null!=$&&(Ar=(0,re.I)(Ar,$)),(0,Io.QH)(Ar,V,K,Y)}let le=(0,P._1)(T,"a","fused matMul"),fe=(0,P._1)(w,"b","fused matMul");[le,fe]=(0,Re.makeTypesMatch)(le,fe);const Oe=v?le.shape[le.rank-2]:le.shape[le.rank-1],$e=k?fe.shape[fe.rank-1]:fe.shape[fe.rank-2],bt=v?le.shape[le.rank-1]:le.shape[le.rank-2],Lt=k?fe.shape[fe.rank-2]:fe.shape[fe.rank-1],Ht=le.shape.slice(0,-2),xn=fe.shape.slice(0,-2),en=I.NA(Ht),On=I.NA(xn);I.hu(Oe===$e,()=>`Error in fused matMul: inner shapes (${Oe}) and (${$e}) of Tensors with shapes ${le.shape} and ${fe.shape} and transposeA=${v} and transposeB=${k} must match.`);const qr=on.assertAndGetBroadcastShape(le.shape.slice(0,-2),fe.shape.slice(0,-2)).concat([bt,Lt]),er=(0,we.X)(le,v?[en,Oe,bt]:[en,bt,Oe]),Ur=(0,we.X)(fe,k?[On,Lt,$e]:[On,$e,Lt]);let In,Lr;null!=$&&(In=(0,P._1)($,"bias","fused matMul"),[In]=(0,Re.makeTypesMatch)(In,le),on.assertAndGetBroadcastShape(qr,In.shape)),null!=K&&(Lr=(0,P._1)(K,"prelu weights","fused matMul"));const wr=(Ar,Wo)=>{const[No,xs,uo,Ec]=Wo,ja=(0,Io.Fr)((0,we.X)(Ar,uo.shape),uo,V);let Al,Dc;return v||k?!v&&k?(Al=(0,rn.O)(ja,xs,!1,!1),Dc=(0,rn.O)(ja,No,!0,!1)):v&&!k?(Al=(0,rn.O)(xs,ja,!1,!0),Dc=(0,rn.O)(No,ja,!1,!1)):(Al=(0,rn.O)(xs,ja,!0,!0),Dc=(0,rn.O)(ja,No,!0,!0)):(Al=(0,rn.O)(ja,xs,!1,!0),Dc=(0,rn.O)(No,ja,!0,!1)),null!=$?[Al,Dc,(0,Io.pf)(Ec,ja)]:[Al,Dc]},ir={a:er,b:Ur,bias:In,preluActivationWeights:Lr},ar={transposeA:v,transposeB:k,activation:V,leakyreluAlpha:Y};return null==$?(0,Ke.cb)((Wo,No,xs)=>{const uo=G.BV.runKernel(q.usg,ir,ar);return xs([Wo,No,uo]),{value:(0,we.X)(uo,qr),gradFunc:wr}})(er,Ur):(0,Ke.cb)((Wo,No,xs,uo)=>{const Ec=G.BV.runKernel(q.usg,ir,ar);return uo([Wo,No,Ec,xs]),{value:(0,we.X)(Ec,qr),gradFunc:wr}})(er,Ur,In)}}),Dm=(0,U.op)({hammingWindow_:function Em(T){return _s(T,.54,.46)}}),_d=(0,U.op)({hannWindow_:function Tm(T){return _s(T,.5,.5)}}),Im=(0,U.op)({frame_:function o_(T,w,v,k=!1,$=0){let V=0;const K=[];for(;V+w<=T.size;)K.push(Rn(T,V,w)),V+=v;if(k)for(;V<T.size;){const Y=V+w-T.size,le=Vt([Rn(T,V,w-Y),(0,Ce.h)([Y],$)]);K.push(le),V+=v}return 0===K.length?ls([],[0,w]):(0,we.X)(Vt(K),[K.length,w])}}),Dl=(0,U.op)({stft_:function Ws(T,w,v,k,$=_d){null==k&&(k=sp(w));const V=Im(T,w,v),K=(0,gt.d)(V,$(w));return ao(K,k)}}),i_=(0,U.op)({cropAndResize_:function Ir(T,w,v,k,$="bilinear",V=0){const K=(0,P._1)(T,"image","cropAndResize"),Y=(0,P._1)(w,"boxes","cropAndResize","float32"),le=(0,P._1)(v,"boxInd","cropAndResize","int32"),fe=Y.shape[0];return I.hu(4===K.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${K.rank}.`),I.hu(2===Y.rank&&4===Y.shape[1],()=>`Error in cropAndResize: boxes must be have size [${fe},4] but had shape ${Y.shape}.`),I.hu(1===le.rank&&le.shape[0]===fe,()=>`Error in cropAndResize: boxInd must be have size [${fe}] but had shape ${Y.shape}.`),I.hu(2===k.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${k.length}.`),I.hu(k[0]>=1&&k[1]>=1,()=>`cropSize must be atleast [1,1], but was ${k}`),I.hu("bilinear"===$||"nearest"===$,()=>`method must be bilinear or nearest, but was ${$}`),G.BV.runKernel(q.VcC,{image:K,boxes:Y,boxInd:le},{method:$,extrapolationValue:V,cropSize:k})}}),l_=(0,U.op)({flipLeftRight_:function a_(T){const w=(0,P._1)(T,"image","flipLeftRight","float32");return I.hu(4===w.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${w.rank}.`),G.BV.runKernel(q.Uyb,{image:w},{})}}),Am=(0,U.op)({grayscaleToRGB_:function c_(T){const w=(0,P._1)(T,"image","grayscaleToRGB"),v=w.rank-1,k=w.shape[v];I.hu(w.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${w.rank}.`),I.hu(1===k,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${k}.`);const $=new Array(w.rank);return $.fill(1,0,v),$[v]=3,B(w,$)}}),vd=(0,U.op)({rotateWithOffset_:function Nm(T,w,v=0,k=.5){const $=(0,P._1)(T,"image","rotateWithOffset","float32");return I.hu(4===$.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${$.rank}.`),G.BV.runKernel(q.b9H,{image:$},{radians:w,fillValue:v,center:k})}});function Ao(T,w,v,k,$,V){null==k&&(k=.5),null==$&&($=Number.NEGATIVE_INFINITY),null==V&&(V=0);const K=T.shape[0];return v=Math.min(v,K),I.hu(0<=k&&k<=1,()=>`iouThreshold must be in [0, 1], but was '${k}'`),I.hu(2===T.rank,()=>`boxes must be a 2D tensor, but was of rank '${T.rank}'`),I.hu(4===T.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${T.shape[1]}`),I.hu(1===w.rank,()=>"scores must be a 1D tensor"),I.hu(w.shape[0]===K,()=>`scores has incompatible shape with boxes. Expected ${K}, but was ${w.shape[0]}`),I.hu(0<=V&&V<=1,()=>`softNmsSigma must be in [0, 1], but was '${V}'`),{maxOutputSize:v,iouThreshold:k,scoreThreshold:$,softNmsSigma:V}}const xd=(0,U.op)({nonMaxSuppression_:function u_(T,w,v,k=.5,$=Number.NEGATIVE_INFINITY){const V=(0,P._1)(T,"boxes","nonMaxSuppression","float32"),K=(0,P._1)(w,"scores","nonMaxSuppression","float32"),Y=Ao(V,K,v,k,$);return G.BV.runKernel(q.uv1,{boxes:V,scores:K},{maxOutputSize:v=Y.maxOutputSize,iouThreshold:k=Y.iouThreshold,scoreThreshold:$=Y.scoreThreshold})}});var yc=O(152);function _u(){return(_u=(0,bn.Z)(function*(T,w,v,k=.5,$=Number.NEGATIVE_INFINITY){const V=(0,P._1)(T,"boxes","nonMaxSuppressionAsync"),K=(0,P._1)(w,"scores","nonMaxSuppressionAsync"),Y=Ao(V,K,v,k,$);v=Y.maxOutputSize,k=Y.iouThreshold,$=Y.scoreThreshold;const le=yield Promise.all([V.data(),K.data()]),fe=le[0],Oe=le[1],{selectedIndices:$e}=(0,yc.GP)(fe,Oe,v,k,$);return V!==T&&V.dispose(),K!==w&&K.dispose(),lo($e,"int32")})).apply(this,arguments)}const d_=(0,U.op)({nonMaxSuppressionWithScore_:function Mm(T,w,v,k=.5,$=Number.NEGATIVE_INFINITY,V=0){const K=(0,P._1)(T,"boxes","nonMaxSuppression"),Y=(0,P._1)(w,"scores","nonMaxSuppression"),le=Ao(K,Y,v,k,$,V),$e=G.BV.runKernel(q.W0H,{boxes:K,scores:Y},{maxOutputSize:v=le.maxOutputSize,iouThreshold:k=le.iouThreshold,scoreThreshold:$=le.scoreThreshold,softNmsSigma:V=le.softNmsSigma});return{selectedIndices:$e[0],selectedScores:$e[1]}}});function Tl(){return(Tl=(0,bn.Z)(function*(T,w,v,k=.5,$=Number.NEGATIVE_INFINITY,V=0){const K=(0,P._1)(T,"boxes","nonMaxSuppressionAsync"),Y=(0,P._1)(w,"scores","nonMaxSuppressionAsync"),le=Ao(K,Y,v,k,$,V);v=le.maxOutputSize,k=le.iouThreshold,$=le.scoreThreshold,V=le.softNmsSigma;const fe=yield Promise.all([K.data(),Y.data()]),Oe=fe[0],$e=fe[1],{selectedIndices:bt,selectedScores:Lt}=(0,yc.pA)(Oe,$e,v,k,$,V);return K!==T&&K.dispose(),Y!==w&&Y.dispose(),{selectedIndices:lo(bt,"int32"),selectedScores:lo(Lt)}})).apply(this,arguments)}const cp=(0,U.op)({nonMaxSuppressionPadded_:function Fw(T,w,v,k=.5,$=Number.NEGATIVE_INFINITY,V=!1){const K=(0,P._1)(T,"boxes","nonMaxSuppression"),Y=(0,P._1)(w,"scores","nonMaxSuppression"),le=Ao(K,Y,v,k,$,null),Ht=G.BV.runKernel(q.cye,{boxes:K,scores:Y},{maxOutputSize:le.maxOutputSize,iouThreshold:le.iouThreshold,scoreThreshold:le.scoreThreshold,padToMaxOutputSize:V});return{selectedIndices:Ht[0],validOutputs:Ht[1]}}});function up(){return(up=(0,bn.Z)(function*(T,w,v,k=.5,$=Number.NEGATIVE_INFINITY,V=!1){const K=(0,P._1)(T,"boxes","nonMaxSuppressionAsync"),Y=(0,P._1)(w,"scores","nonMaxSuppressionAsync"),le=Ao(K,Y,v,k,$,null),fe=le.maxOutputSize,Oe=le.iouThreshold,$e=le.scoreThreshold,[bt,Lt]=yield Promise.all([K.data(),Y.data()]),{selectedIndices:Ht,validOutputs:xn}=(0,yc.qP)(bt,Lt,fe,Oe,$e,V);return K!==T&&K.dispose(),Y!==w&&Y.dispose(),{selectedIndices:lo(Ht,"int32"),validOutputs:(0,gn.i)(xn,"int32")}})).apply(this,arguments)}const Lw=(0,U.op)({resizeBilinear_:function $w(T,w,v=!1,k=!1){const $=(0,P._1)(T,"images","resizeBilinear");I.hu(3===$.rank||4===$.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${$.rank}.`),I.hu(2===w.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${w}.`),I.hu(!1===k||!1===v,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let V=$,K=!1;3===$.rank&&(K=!0,V=(0,we.X)($,[1,$.shape[0],$.shape[1],$.shape[2]]));const[]=w,fe=G.BV.runKernel(q._Yw,{images:V},{alignCorners:v,halfPixelCenters:k,size:w});return K?(0,we.X)(fe,[fe.shape[1],fe.shape[2],fe.shape[3]]):fe}}),wd=(0,U.op)({resizeNearestNeighbor_:function Rm(T,w,v=!1,k=!1){const $=(0,P._1)(T,"images","resizeNearestNeighbor");I.hu(3===$.rank||4===$.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${$.rank}.`),I.hu(2===w.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${w}.`),I.hu("float32"===$.dtype||"int32"===$.dtype,()=>"`images` must have `int32` or `float32` as dtype"),I.hu(!1===k||!1===v,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let V=$,K=!1;3===$.rank&&(K=!0,V=(0,we.X)($,[1,$.shape[0],$.shape[1],$.shape[2]]));const[]=w,fe=G.BV.runKernel(q.dpD,{images:V},{alignCorners:v,halfPixelCenters:k,size:w});return K?(0,we.X)(fe,[fe.shape[1],fe.shape[2],fe.shape[3]]):fe}}),dp=(0,U.op)({threshold_:function f_(T,w="binary",v=!1,k=.5){const $=(0,P._1)(T,"image","threshold"),le=$.shape[0]*$.shape[1];let Oe,$e,bt,Lt,fe=(0,gt.d)(lo([k]),255);if(I.hu(3===$.rank,()=>`Error in threshold: image must be rank 3,but got rank ${$.rank}.`),I.hu(3===$.shape[2]||1===$.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${$.shape[2]}.`),I.hu("int32"===$.dtype||"float32"===$.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${$.dtype}.`),I.hu("otsu"===w||"binary"===w,()=>`Method must be binary or otsu, but was ${w}`),3===$.shape[2]){[Oe,$e,bt]=mu($,[1,1,1],-1);const en=(0,gt.d)(Oe,.2989),On=(0,gt.d)($e,.587),$r=(0,gt.d)(bt,.114);Lt=(0,re.I)((0,re.I)(en,On),$r)}else Lt=T;"otsu"===w&&(fe=function Sd(T,w){let V,K,Y,le,fe,Oe,v=lo([-1]),k=lo([0]),$=lo([0]);for(let $e=0;$e<T.size-1;$e++){V=Rn(T,0,$e+1),K=Rn(T,$e+1),fe=(0,qn.h)((0,Kn.S)(V),w),Oe=(0,qn.h)((0,Kn.S)(K),w);const bt=(0,Kn.S)((0,gt.d)(V,aa(0,V.size)));Y=(0,qn.h)(bt,(0,Kn.S)(V));const Lt=(0,Ce.h)(K.shape,V.size),Ht=(0,re.I)(aa(0,K.size),Lt),xn=(0,gt.d)(K,Ht);le=(0,qn.h)((0,Kn.S)(xn),(0,Kn.S)(K));const en=(0,Un.l)(Y,le),On=(0,Un.l)(Y,le),$r=(0,gt.d)(fe,Oe);$=(0,gt.d)((0,gt.d)($r,en),On);const qr=ln($,k);k=jr(qr,$,k),v=jr(qr,lo([$e]),v)}return v}(Ys((0,Me.p)(Ze(Lt),"int32"),(0,or.X)([]),256),le));const Ht=v?tu(Lt,fe):ln(Lt,fe);return(0,Me.p)((0,gt.d)(Ht,255),"int32")}}),Bw=(0,U.op)({transform_:function Ed(T,w,v="nearest",k="constant",$=0,V){const K=(0,P._1)(T,"image","transform","float32"),Y=(0,P._1)(w,"transforms","transform","float32");return I.hu(4===K.rank,()=>`Error in transform: image must be rank 4,but got rank ${K.rank}.`),I.hu(2===Y.rank&&(Y.shape[0]===K.shape[0]||1===Y.shape[0])&&8===Y.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),I.hu(null==V||2===V.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${V}.`),G.BV.runKernel(q.wx7,{image:K,transforms:Y},{interpolation:v,fillMode:k,fillValue:$,outputShape:V})}}),Fm=(0,U.op)({bandPart_:function Om(T,w,v){const k=(0,P._1)(T,"a","bandPart");(0,I.hu)(k.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${k.rank}.`);const $=k.shape,[V,K]=k.shape.slice(-2);let Y,le;"number"==typeof w?((0,I.hu)(w%1==0,()=>`bandPart(): numLower must be an integer, got ${w}.`),(0,I.hu)(w<=V,()=>`bandPart(): numLower (${w}) must not be greater than the number of rows (${V}).`),Y=(0,P._1)(w<0?V:w,"numLower","bandPart")):((0,I.hu)("int32"===w.dtype,()=>"bandPart(): numLower's dtype must be an int32."),Y=jr(yl(w,0),V,ac(w,V))),"number"==typeof v?((0,I.hu)(v%1==0,()=>`bandPart(): numUpper must be an integer, got ${v}.`),(0,I.hu)(v<=K,()=>`bandPart(): numUpper (${v}) must not be greater than the number of columns (${K}).`),le=(0,P._1)(v<0?K:v,"numUpper","bandPart")):((0,I.hu)("int32"===v.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),le=jr(yl(v,0),K,ac(v,K)));const fe=(0,we.X)(aa(0,V,1,"int32"),[-1,1]),Oe=aa(0,K,1,"int32"),$e=(0,Un.l)(fe,Oe),bt=zs(tu($e,Y),$t($e,(0,no.W)(le))),Lt=ns([V,K],k.dtype);return(0,we.X)(gu(gm((0,we.X)(k,[-1,V,K])).map(Ht=>jr(bt,Ht,Lt))),$)}}),Pi=(0,U.op)({gramSchmidt_:function m_(T){let w;if(Array.isArray(T)){w=!1,(0,I.hu)(null!=T&&T.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const $=T[0].shape[0];for(let V=1;V<T.length;++V)(0,I.hu)(T[V].shape[0]===$,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${T[V].shape[0]} vs. ${$})`)}else w=!0,T=mu(T,T.shape[0],0).map($=>gd($,[0]));(0,I.hu)(T.length<=T[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${T.length}) exceeds number of dimensions (${T[0].shape[0]}).`);const v=[],k=T;for(let $=0;$<T.length;++$)v.push(G.BV.tidy(()=>{let V=k[$];if($>0)for(let K=0;K<$;++K){const Y=(0,gt.d)((0,Kn.S)((0,gt.d)(v[K],V)),v[K]);V=(0,Un.l)(V,Y)}return(0,qn.h)(V,ta(V,"euclidean"))}));return w?gu(v,0):v}});var g_=O(9370);function Td(T,w=!1){return G.BV.tidy(()=>{(0,I.hu)(2===T.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${T.shape.length}D Tensor.`);const v=T.shape[0],k=T.shape[1];let $=J(v),V=(0,dn.d)(T);const K=ls([[1]],[1,1]);let Y=(0,dn.d)(K);const le=v>=k?k:v;for(let fe=0;fe<le;++fe){const Oe=V,$e=Y,bt=$;[Y,V,$]=G.BV.tidy(()=>{const Lt=Rn(V,[fe,fe],[v-fe,1]),Ht=ta(Lt),xn=Rn(V,[fe,fe],[1,1]),en=jr(ln(xn,0),ls([[-1]]),ls([[1]])),On=(0,Un.l)(xn,(0,gt.d)(en,Ht)),$r=(0,qn.h)(Lt,On);Y=1===$r.shape[0]?(0,dn.d)(K):Vt([K,Rn($r,[1,0],[$r.shape[0]-1,$r.shape[1]])],0);const qr=(0,no.W)((0,qn.h)((0,rn.O)(en,On),Ht)),er=Rn(V,[fe,0],[v-fe,k]),Ur=(0,gt.d)(qr,Y),In=(0,tp.p)(Y);if(0===fe)V=(0,Un.l)(er,(0,rn.O)(Ur,(0,rn.O)(In,er)));else{const ir=(0,Un.l)(er,(0,rn.O)(Ur,(0,rn.O)(In,er)));V=Vt([Rn(V,[0,0],[fe,k]),ir],0)}const Lr=(0,tp.p)(Ur),wr=Rn($,[0,fe],[v,$.shape[1]-fe]);if(0===fe)$=(0,Un.l)(wr,(0,rn.O)((0,rn.O)(wr,Y),Lr));else{const ir=(0,Un.l)(wr,(0,rn.O)((0,rn.O)(wr,Y),Lr));$=Vt([Rn($,[0,0],[v,fe]),ir],1)}return[Y,V,$]}),(0,g_.B9)([Oe,$e,bt])}return!w&&v>k&&($=Rn($,[0,0],[v,k]),V=Rn(V,[0,0],[k,k])),[$,V]})}const Pm=(0,U.op)({qr_:function Dd(T,w=!1){if((0,I.hu)(T.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${T.rank}`),2===T.rank)return Td(T,w);{const v=T.shape.slice(0,T.shape.length-2).reduce((le,fe)=>le*fe),k=gm((0,we.X)(T,[v,T.shape[T.shape.length-2],T.shape[T.shape.length-1]]),0),$=[],V=[];return k.forEach(le=>{const[fe,Oe]=Td(le,w);$.push(fe),V.push(Oe)}),[(0,we.X)(gu($,0),T.shape),(0,we.X)(gu(V,0),T.shape)]}}});var js=O(4761);const ha=(0,U.op)({computeWeightedLoss_:function hp(T,w,v=js.I.SUM_BY_NONZERO_WEIGHTS){const k=(0,P._1)(T,"losses","computeWeightedLoss");let $=null;null!=w&&($=(0,P._1)(w,"weights","computeWeightedLoss"));const V=null==$?k:(0,gt.d)(k,$);if(v===js.I.NONE)return V;if(v===js.I.SUM)return(0,Kn.S)(V);if(v===js.I.MEAN){if(null==$)return ic(V);{const K=k.size/$.size,Y=(0,qn.h)((0,Kn.S)(V),(0,Kn.S)($));return K>1?(0,qn.h)(Y,(0,gn.i)(K)):Y}}if(v===js.I.SUM_BY_NONZERO_WEIGHTS){if(null==$)return(0,qn.h)((0,Kn.S)(V),(0,gn.i)(k.size));{const K=(0,gt.d)($,ki(k.shape)),Y=(0,Me.p)((0,Kn.S)(La(K,(0,gn.i)(0))),"float32");return(0,qn.h)((0,Kn.S)(V),Y)}}throw Error(`Unknown reduction: ${v}`)}}),Lm=(0,U.op)({absoluteDifference_:function $m(T,w,v,k=js.I.SUM_BY_NONZERO_WEIGHTS){const $=(0,P._1)(T,"labels","absoluteDifference"),V=(0,P._1)(w,"predictions","absoluteDifference");let K=null;null!=v&&(K=(0,P._1)(v,"weights","absoluteDifference")),(0,I.k5)($.shape,V.shape,"Error in absoluteDifference: ");const Y=(0,xe.W)((0,Un.l)($,V));return ha(Y,K,k)}}),Vm=(0,U.op)({cosineDistance_:function Bm(T,w,v,k,$=js.I.SUM_BY_NONZERO_WEIGHTS){const V=(0,P._1)(T,"labels","cosineDistance"),K=(0,P._1)(w,"predictions","cosineDistance");let Y=null;null!=k&&(Y=(0,P._1)(k,"weights","cosineDistance")),(0,I.k5)(V.shape,K.shape,"Error in cosineDistance: ");const le=(0,gn.i)(1),fe=(0,Un.l)(le,(0,Kn.S)((0,gt.d)(V,K),v,!0));return ha(fe,Y,$)}}),Id=(0,U.op)({hingeLoss_:function y_(T,w,v,k=js.I.SUM_BY_NONZERO_WEIGHTS){let $=(0,P._1)(T,"labels","hingeLoss");const V=(0,P._1)(w,"predictions","hingeLoss");let K=null;null!=v&&(K=(0,P._1)(v,"weights","hingeLoss")),(0,I.k5)($.shape,V.shape,"Error in hingeLoss: ");const Y=(0,gn.i)(1);$=(0,Un.l)((0,gt.d)((0,gn.i)(2),$),Y);const le=(0,pu.U)((0,Un.l)(Y,(0,gt.d)($,V)));return ha(le,K,k)}}),b_=(0,U.op)({huberLoss_:function Il(T,w,v,k=1,$=js.I.SUM_BY_NONZERO_WEIGHTS){const V=(0,P._1)(T,"labels","huberLoss"),K=(0,P._1)(w,"predictions","huberLoss");let Y=null;null!=v&&(Y=(0,P._1)(v,"weights","huberLoss")),(0,I.k5)(V.shape,K.shape,"Error in huberLoss: ");const le=(0,gn.i)(k),fe=(0,xe.W)((0,Un.l)(K,V)),Oe=ac(fe,le),$e=(0,Un.l)(fe,Oe),bt=(0,re.I)((0,gt.d)((0,gn.i)(.5),(0,ea.h)(Oe)),(0,gt.d)(le,$e));return ha(bt,Y,$)}}),zm=(0,U.op)({logLoss_:function Um(T,w,v,k=1e-7,$=js.I.SUM_BY_NONZERO_WEIGHTS){const V=(0,P._1)(T,"labels","logLoss"),K=(0,P._1)(w,"predictions","logLoss");let Y=null;null!=v&&(Y=(0,P._1)(v,"weights","logLoss")),(0,I.k5)(V.shape,K.shape,"Error in logLoss: ");const le=(0,gn.i)(1),fe=(0,gn.i)(k),Oe=(0,no.W)((0,gt.d)(V,na((0,re.I)(K,fe)))),$e=(0,gt.d)((0,Un.l)(le,V),na((0,re.I)((0,Un.l)(le,K),fe))),bt=(0,Un.l)(Oe,$e);return ha(bt,Y,$)}}),__=(0,U.op)({meanSquaredError_:function _c(T,w,v,k=js.I.SUM_BY_NONZERO_WEIGHTS){const $=(0,P._1)(T,"labels","meanSquaredError"),V=(0,P._1)(w,"predictions","meanSquaredError");let K=null;null!=v&&(K=(0,P._1)(v,"weights","meanSquaredError")),(0,I.k5)($.shape,V.shape,"Error in meanSquaredError: ");const Y=om($,V);return ha(Y,K,k)}}),v_=(0,U.op)({sigmoidCrossEntropy_:function pp(T,w,v,k=0,$=js.I.SUM_BY_NONZERO_WEIGHTS){let V=(0,P._1)(T,"multiClassLabels","sigmoidCrossEntropy");const K=(0,P._1)(w,"logits","sigmoidCrossEntropy");let Y=null;if(null!=v&&(Y=(0,P._1)(v,"weights","sigmoidCrossEntropy")),(0,I.k5)(V.shape,K.shape,"Error in sigmoidCrossEntropy: "),k>0){const fe=(0,gn.i)(k),Oe=(0,gn.i)(1),$e=(0,gn.i)(.5);V=(0,re.I)((0,gt.d)(V,(0,Un.l)(Oe,fe)),(0,gt.d)($e,fe))}const le=function vs(T,w){const v=(0,P._1)(T,"labels","sigmoidCrossEntropyWithLogits"),k=(0,P._1)(w,"logits","sigmoidCrossEntropyWithLogits");(0,I.k5)(v.shape,k.shape,"Error in sigmoidCrossEntropyWithLogits: ");const $=(0,pu.U)(k),V=(0,gt.d)(k,v),K=nu(En((0,no.W)((0,xe.W)(k))));return(0,re.I)((0,Un.l)($,V),K)}(V,K);return ha(le,Y,$)}}),xc=(0,U.op)({softmaxCrossEntropy_:function vc(T,w,v,k=0,$=js.I.SUM_BY_NONZERO_WEIGHTS){let V=(0,P._1)(T,"onehotLabels","softmaxCrossEntropy");const K=(0,P._1)(w,"logits","softmaxCrossEntropy");let Y=null;if(null!=v&&(Y=(0,P._1)(v,"weights","softmaxCrossEntropy")),(0,I.k5)(V.shape,K.shape,"Error in softmaxCrossEntropy: "),k>0){const fe=(0,gn.i)(k),Oe=(0,gn.i)(1),$e=(0,gn.i)(V.shape[1]);V=(0,re.I)((0,gt.d)(V,(0,Un.l)(Oe,fe)),(0,qn.h)(fe,$e))}const le=function Hm(T,w,v=-1){if(-1===v&&(v=w.rank-1),v!==w.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${w.rank} and dim was ${v}`);return(0,Ke.cb)(($,V,K)=>{const le=ro(V,[v],!0),fe=(0,Un.l)((0,Me.p)(V,"float32"),le);K([$,fe]);const Oe=(0,no.W)((0,gt.d)(fe,$));return{value:(0,Kn.S)(Oe,[v]),gradFunc:(Lt,Ht)=>{const[xn,en]=Ht,On=(0,ii.rv)(Lt.shape,[v]);return[(0,gt.d)((0,we.X)(Lt,On),(0,Un.l)((0,Me.p)(xn,"float32"),En(en))),(0,gt.d)((0,we.X)(Lt,On),(0,Un.l)(En(en),(0,Me.p)(xn,"float32")))]}}})(T,w)}(V,K);return ha(le,Y,$)}}),Xr={fft:fc,ifft:Qh,rfft:ao,irfft:Ub},C_={hammingWindow:Dm,hannWindow:_d,frame:Im,stft:Dl},xu={flipLeftRight:l_,grayscaleToRGB:Am,resizeNearestNeighbor:wd,resizeBilinear:Lw,rotateWithOffset:vd,cropAndResize:i_,nonMaxSuppression:xd,nonMaxSuppressionAsync:function Cd(T,w,v){return _u.apply(this,arguments)},nonMaxSuppressionWithScore:d_,nonMaxSuppressionWithScoreAsync:function bc(T,w,v){return Tl.apply(this,arguments)},nonMaxSuppressionPadded:cp,nonMaxSuppressionPaddedAsync:function Pw(T,w,v){return up.apply(this,arguments)},threshold:dp,transform:Bw},w_={bandPart:Fm,gramSchmidt:Pi,qr:Pm},Ho={absoluteDifference:Lm,computeWeightedLoss:ha,cosineDistance:Vm,hingeLoss:Id,huberLoss:b_,logLoss:zm,meanSquaredError:__,sigmoidCrossEntropy:v_,softmaxCrossEntropy:xc},Cu={sparseFillEmptyRows:(0,U.op)({sparseFillEmptyRows_:function Cc(T,w,v,k){const $=(0,P._1)(T,"indices","sparseFillEmptyRows","int32"),V=(0,P._1)(w,"values","sparseFillEmptyRows"),K=(0,P._1)(v,"denseShape","sparseFillEmptyRows","int32"),Y=(0,P._1)(k,"defaultValue","sparseFillEmptyRows",V.dtype);if(2!==$.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${$.shape}`);if(1!==V.rank)throw new Error(`Values should be Tensor1D but received shape ${V.shape}`);if(1!==K.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${K.shape}`);if(0!==Y.rank)throw new Error(`Default value should be a scalar but received shape ${Y.shape}`);const fe=G.BV.runKernel(q.O3z,{indices:$,values:V,denseShape:K,defaultValue:Y});return{outputIndices:fe[0],outputValues:fe[1],emptyRowIndicator:fe[2],reverseIndexMap:fe[3]}}}),sparseReshape:(0,U.op)({sparseReshape_:function Wm(T,w,v){const k=(0,P._1)(T,"inputIndices","sparseReshape","int32"),$=(0,P._1)(w,"inputShape","sparseReshape","int32"),V=(0,P._1)(v,"newShape","sparseReshape","int32");if(2!==k.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${k.shape}`);if(1!==$.rank)throw new Error(`Input shape should be Tensor1D but received shape ${$.shape}`);if(1!==V.rank)throw new Error(`New shape should be Tensor1D but received shape ${V.shape}`);const Y=G.BV.runKernel(q.nhH,{inputIndices:k,inputShape:$,newShape:V});return{outputIndices:Y[0],outputShape:Y[1]}}}),sparseSegmentMean:(0,U.op)({sparseSegmentMean_:function Sc(T,w,v){const k=(0,P._1)(T,"data","sparseSegmentMean"),$=(0,P._1)(w,"indices","sparseSegmentMean","int32"),V=(0,P._1)(v,"segmentIds","sparseSegmentMean","int32");if(k.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==$.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${$.shape}`);if(1!==V.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${V.shape}`);return G.BV.runKernel(q.w3H,{data:k,indices:$,segmentIds:V})}}),sparseSegmentSum:(0,U.op)({sparseSegmentSum_:function x_(T,w,v){const k=(0,P._1)(T,"data","sparseSegmentSum"),$=(0,P._1)(w,"indices","sparseSegmentSum","int32"),V=(0,P._1)(v,"segmentIds","sparseSegmentSum","int32");if(k.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==$.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${$.shape}`);if(1!==V.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${V.shape}`);return G.BV.runKernel(q.ZjV,{data:k,indices:$,segmentIds:V})}})},jm={stringNGrams:(0,U.op)({stringNGrams_:function zw(T,w,v,k,$,V,K,Y){const le=(0,P._1)(T,"data","stringNGrams","string");if("string"!==le.dtype)throw new Error("Data must be of datatype string");if(1!==le.shape.length)throw new Error(`Data must be a vector, saw: ${le.shape}`);const fe=(0,P._1)(w,"dataSplits","stringNGrams");if("int32"!==fe.dtype)throw new Error("Data splits must be of datatype int32");const bt=G.BV.runKernel(q._JP,{data:le,dataSplits:fe},{separator:v,nGramWidths:k,leftPad:$,rightPad:V,padWidth:K,preserveShortSequences:Y});return{nGrams:bt[0],nGramsSplits:bt[1]}}}),stringSplit:(0,U.op)({stringSplit_:function Ww(T,w,v=!0){const k=(0,P._1)(T,"input","stringSplit","string"),$=(0,P._1)(w,"delimiter","stringSplit","string");if(1!==k.rank)throw new Error(`Input should be Tensor1D but received shape ${k.shape}`);if(0!==$.rank)throw new Error(`Delimiter should be a scalar but received shape ${$.shape}`);const Y=G.BV.runKernel(q.s1s,{input:k,delimiter:$},{skipEmpty:v});return{indices:Y[0],values:Y[1],shape:Y[2]}}}),stringToHashBucketFast:(0,U.op)({stringToHashBucketFast_:function Gw(T,w){const v=(0,P._1)(T,"input","stringToHashBucketFast","string"),k={numBuckets:w};if(w<=0)throw new Error("Number of buckets must be at least 1");return G.BV.runKernel(q.XkS,{input:v},k)}}),staticRegexReplace:(0,U.op)({staticRegexReplace_:function Kw(T,w,v,k=!0){const $=(0,P._1)(T,"input","staticRegexReplace","string");return G.BV.runKernel(q.e0R,{x:$},{pattern:w,rewrite:v,replaceGlobal:k})}})}},9043:(mt,Le,O)=>{"use strict";O.d(Le,{s:()=>pe});var ue=O(3738),xe=O(1070),G=O(7904),q=O(9608);const pe=(0,O(6721).op)({pow_:function U(ce,X){let ie=(0,q._1)(ce,"base","pow"),re=(0,q._1)(X,"exp","pow");return[ie,re]=(0,G.makeTypesMatch)(ie,re),ue.BV.runKernel(xe.pe_,{a:ie,b:re})}})},1426:(mt,Le,O)=>{"use strict";O.d(Le,{A:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({prelu_:function P(pe,ce){const X=(0,G._1)(pe,"x","prelu"),ie=(0,G._1)(ce,"alpha","prelu");return ue.BV.runKernel(xe.o0g,{x:X,alpha:ie})}})},2174:(mt,Le,O)=>{"use strict";function ue(xe,G=!1){console.log(xe.toString(G))}O.d(Le,{S:()=>ue})},5732:(mt,Le,O)=>{"use strict";O.d(Le,{k:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({real_:function P(pe){const X={input:(0,G._1)(pe,"input","real")};return ue.BV.runKernel(xe.xJR,X)}})},4563:(mt,Le,O)=>{"use strict";O.d(Le,{U:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({relu_:function P(pe){const X={x:(0,G._1)(pe,"x","relu")};return ue.BV.runKernel(xe.qkr,X)}})},5049:(mt,Le,O)=>{"use strict";O.d(Le,{b:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({relu6_:function P(pe){const X={x:(0,G._1)(pe,"x","relu6")};return ue.BV.runKernel(xe.SbG,X)}})},9416:(mt,Le,O)=>{"use strict";O.d(Le,{X:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({reshape_:function P(pe,ce){const ie={x:(0,G._1)(pe,"x","reshape","string_or_numeric")};return ue.BV.runKernel(xe.HZH,ie,{shape:ce})}})},316:(mt,Le,O)=>{"use strict";O.d(Le,{i:()=>G});var ue=O(8813),xe=O(3906);function G(q,P){if(((0,ue.isTypedArray)(q)&&"string"!==P||Array.isArray(q))&&"complex64"!==P)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===P&&(0,ue.isTypedArray)(q)&&!(q instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,xe.H)(q,[],[],P)}},2808:(mt,Le,O)=>{"use strict";O.r(Le),O.d(Le,{calculateShapes:()=>q,validateInput:()=>G,validateUpdateShape:()=>xe});var ue=O(1396);function xe(P,U,pe){const ce=U.rank>1?U.shape[U.rank-1]:1,X=U.rank>1?U.rank-1:1,ie=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${pe.shape}, indices.shape: ${U.shape}, shape: ${P}, sliceDim: ${ce}, and batchDim: ${X}.`;if(pe.rank<X)throw new Error(ie+` update.rank < ${X}. `);if(P.length<ce+(pe.rank-X))throw new Error(ie+` Output shape length < ${ce+(pe.rank-X)}`);if(pe.rank!==X+P.length-ce)throw new Error(ie+" update.rank != "+(X+P.length-ce));for(let re=0;re<X;++re)if(pe.shape[re]!==U.shape[re])throw new Error(ie+` updates.shape[${re}] (${pe.shape[re]}) != indices.shape[${re}] (${U.shape[re]}).`);for(let re=0;re<pe.rank-X;++re)if(pe.shape[re+X]!==P[re+ce])throw new Error(ie+` updates.shape[${re+X}] (${pe.shape[re+X]}) != shape[${re+X}] (${P[re+X]})`)}function G(P,U,pe){if(U.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${U.rank}.`);if(P.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${P.rank}.`);if("int32"!==U.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${U.dtype}`);if(pe.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${pe}`);if(0===pe.length){if(0===U.size)throw new Error(`Indices specified for empty output. indices shape: ${U.shape}`);if(0===P.size)throw new Error(`Updates specified for empty output. updates shape: ${P.shape}`)}xe(pe,U,P)}function q(P,U,pe){const ce=U.shape.length,X=ce>1?U.shape[ce-1]:1,ie=pe.length;let re=1;for(let Fe=X;Fe<ie;++Fe)re*=pe[Fe];const I=X<1?1:X;return{sliceRank:X,numUpdates:(0,ue.NA)(U.shape)/I,sliceSize:re,strides:[...(0,ue.e3)(pe.slice(0,X)),1],outputSize:(0,ue.NA)(pe)}}},6713:(mt,Le,O)=>{"use strict";O.d(Le,{X:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({sigmoid_:function P(pe){const X={x:(0,G._1)(pe,"x","sigmoid","float32")};return ue.BV.runKernel(xe.a5O,X)}})},5562:(mt,Le,O)=>{"use strict";O.d(Le,{_:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({sqrt_:function P(pe){const X={x:(0,G._1)(pe,"x","sqrt","float32")};return ue.BV.runKernel(xe.FKq,X)}})},4164:(mt,Le,O)=>{"use strict";O.d(Le,{h:()=>P});var ue=O(3738),xe=O(9608);const P=(0,O(6721).op)({square_:function q(U){const pe=(0,xe._1)(U,"x","square");return ue.BV.runKernel("Square",{x:pe},{})}})},6166:(mt,Le,O)=>{"use strict";O.d(Le,{N:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({step_:function P(pe,ce=0){const ie={x:(0,G._1)(pe,"x","step")};return ue.BV.runKernel(xe.h8e,ie,{alpha:ce})}})},8578:(mt,Le,O)=>{"use strict";O.d(Le,{l:()=>pe});var ue=O(3738),xe=O(1070),G=O(7904),q=O(9608);const pe=(0,O(6721).op)({sub_:function U(ce,X){let ie=(0,q._1)(ce,"a","sub"),re=(0,q._1)(X,"b","sub");return[ie,re]=(0,G.makeTypesMatch)(ie,re),ue.BV.runKernel(xe.Tr8,{a:ie,b:re})}})},5214:(mt,Le,O)=>{"use strict";O.d(Le,{S:()=>pe});var ue=O(3738),xe=O(1070),G=O(9608),q=O(9734);const pe=(0,O(6721).op)({sum_:function U(ce,X=null,ie=!1){let re=(0,G._1)(ce,"x","sum");return"bool"===re.dtype&&(re=(0,q.p)(re,"int32")),ue.BV.runKernel(xe.GBy,{x:re},{axis:X,keepDims:ie})}})},1973:(mt,Le,O)=>{"use strict";O.d(Le,{X:()=>G});var ue=O(9608),xe=O(3906);function G(q,P,U){const pe=(0,ue.C)(q,U);return(0,xe.H)(q,P,pe,U)}},3157:(mt,Le,O)=>{"use strict";O.d(Le,{w:()=>q});var ue=O(9608),xe=O(1396),G=O(3906);function q(P,U,pe){if((0,xe.Cq)(P),null!=U&&3!==U.length)throw new Error("tensor3d() requires shape to have three numbers");const ce=(0,ue.C)(P,pe);if(3!==ce.length&&1!==ce.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===ce.length&&null==U)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,G.H)(P,U,ce,pe)}},3906:(mt,Le,O)=>{"use strict";O.d(Le,{H:()=>P});var ue=O(3738),xe=O(7770),G=O(1396),q=O(8813);function P(U,pe,ce,X){if(null==X)X=(0,G.D2)(U);else if("complex64"===X)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if((0,xe.$F)(U)||(0,xe.Oq)(U)){if("float32"!==X&&"int32"!==X)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${X}.`);return ue.BV.backend.createTensorFromGPUData(U,pe||ce,X)}if(!(0,q.isTypedArray)(U)&&!Array.isArray(U)&&"number"!=typeof U&&"boolean"!=typeof U&&"string"!=typeof U)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=pe){(0,G.Mu)(pe);const ie=(0,G.NA)(pe),re=(0,G.NA)(ce);(0,G.hu)(ie===re,()=>`Based on the provided shape, [${pe}], the tensor should have ${ie} values but has ${re}`);for(let I=0;I<ce.length;++I){const Ae=I!==ce.length-1||ce[I]!==(0,G.NA)(pe.slice(I));(0,G.hu)(ce[I]===pe[I]||!Ae,()=>`Error creating a new Tensor. Inferred shape (${ce}) does not match the provided shape (${pe}). `)}}return!(0,q.isTypedArray)(U)&&!Array.isArray(U)&&(U=[U]),pe=pe||ce,U="string"!==X?(0,q.toTypedArray)(U,X):(0,q.flatten)(U,[],!0),ue.BV.makeTensor(U,pe,X)}},9540:(mt,Le,O)=>{"use strict";O.d(Le,{p:()=>I});var ue=O(3738),xe=O(9370),G=O(1070),q=O(9608),P=O(1396),U=O(9907),pe=O(5294),ce=O(3304),X=O(6721),ie=O(5732);const I=(0,X.op)({transpose_:function re(se,Ae,ge){const Fe=(0,q._1)(se,"x","transpose");if(null==Ae&&(Ae=Fe.shape.map((Mt,ct)=>ct).reverse()),P.hu(Fe.rank===Ae.length,()=>`Error in transpose: rank of input ${Fe.rank} must match length of perm ${Ae}.`),Ae.forEach(Mt=>{P.hu(Mt>=0&&Mt<Fe.rank,()=>`All entries in 'perm' must be between 0 and ${Fe.rank-1} but got ${Ae}`)}),Fe.rank<=1)return Fe.clone();const ut={x:Fe},ot={perm:Ae};return"complex64"===Fe.dtype?(0,xe.lu)(()=>{let Mt=(0,ie.k)(Fe),ct=(0,pe.a)(Fe);return Mt=ue.BV.runKernel(G.G3Y,{x:Mt},ot),ct=ue.BV.runKernel(G.G3Y,{x:ct},ot),ge&&(ct=(0,ce.W)(ct)),(0,U.P)(Mt,ct)}):ue.BV.runKernel(G.G3Y,ut,ot)}})},37:(mt,Le,O)=>{"use strict";O.d(Le,{P:()=>U});var ue=O(3738),xe=O(1070),G=O(9608);const U=(0,O(6721).op)({zerosLike_:function P(pe){const X={x:(0,G._1)(pe,"x","zerosLike")};return ue.BV.runKernel(xe.RuY,X)}})},1946:(mt,Le,O)=>{"use strict";function ue(xe){return xe instanceof Float32Array||xe instanceof Int32Array||xe instanceof Uint8Array||xe instanceof Uint8ClampedArray}O.d(Le,{j:()=>ue})},708:(mt,Le,O)=>{"use strict";O.d(Le,{es:()=>de,YD:()=>Ae,_w:()=>Be,FZ:()=>ct,Vp:()=>Mt,Vi:()=>ot});var ue=O(5861),xe=O(6422),G=O(1396);const q=20,P=3,U=7;function pe(Q,ae,F,ee){const he=(0,G.e3)(ae),Re=function ce(Q,ae,F,ee){const he=(0,G.NA)(ae),Re=ee[ee.length-1],S=new Array(Re).fill(0),ze=ae.length,ye="complex64"===F?I(Q):Q;if(ze>1)for(let ve=0;ve<he/Re;ve++){const Me=ve*Re;for(let ke=0;ke<Re;ke++)S[ke]=Math.max(S[ke],X(ye[Me+ke],0,F).length)}return S}(Q,ae,F,he),S=ae.length,ze=re(Q,ae,F,he,Re),ye=["Tensor"];return ee&&(ye.push(`  dtype: ${F}`),ye.push(`  rank: ${S}`),ye.push(`  shape: [${ae}]`),ye.push("  values:")),ye.push(ze.map(ve=>"    "+ve).join("\n")),ye.join("\n")}function X(Q,ae,F){let ee;return ee=Array.isArray(Q)?`${parseFloat(Q[0].toFixed(U))} + ${parseFloat(Q[1].toFixed(U))}j`:(0,G.HD)(Q)?`'${Q}'`:"bool"===F?ie(Q):parseFloat(Q.toFixed(U)).toString(),(0,G.oj)(ee,ae)}function ie(Q){return 0===Q?"false":"true"}function re(Q,ae,F,ee,he,Re=!0){const S="complex64"===F?2:1,ze=ae[0],ye=ae.length;if(0===ye)return"complex64"===F?[X(I(Q)[0],0,F)]:"bool"===F?[ie(Q[0])]:[Q[0].toString()];if(1===ye){if(ze>q){let dn=Array.from(Q.slice(0,P*S)),nn=Array.from(Q.slice((ze-P)*S,ze*S));return"complex64"===F&&(dn=I(dn),nn=I(nn)),["["+dn.map((Vt,rn)=>X(Vt,he[rn],F)).join(", ")+", ..., "+nn.map((Vt,rn)=>X(Vt,he[ze-P+rn],F)).join(", ")+"]"]}return["["+("complex64"===F?I(Q):Array.from(Q)).map((Kt,dn)=>X(Kt,he[dn],F)).join(", ")+"]"]}const ve=ae.slice(1),Me=ee.slice(1),ke=ee[0]*S,we=[];if(ze>q){for(let et=0;et<P;et++){const Kt=et*ke;we.push(...re(Q.slice(Kt,Kt+ke),ve,F,Me,he,!1))}we.push("...");for(let et=ze-P;et<ze;et++){const Kt=et*ke;we.push(...re(Q.slice(Kt,Kt+ke),ve,F,Me,he,et===ze-1))}}else for(let et=0;et<ze;et++){const Kt=et*ke;we.push(...re(Q.slice(Kt,Kt+ke),ve,F,Me,he,et===ze-1))}const _t=2===ye?",":"";we[0]="["+(ze>0?we[0]+_t:"");for(let et=1;et<we.length-1;et++)we[et]=" "+we[et]+_t;let At=",\n";for(let et=2;et<ye;et++)At+="\n";return we[we.length-1]=" "+we[we.length-1]+"]"+(Re?"":At),we}function I(Q){const ae=[];for(let F=0;F<Q.length;F+=2)ae.push([Q[F],Q[F+1]]);return ae}var se=O(8813);class Ae{constructor(ae,F,ee){if(this.dtype=F,this.shape=ae.slice(),this.size=G.NA(ae),null!=ee){const he=ee.length;G.hu(he===this.size,()=>`Length of values '${he}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===F)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=ee||G.rQ(F,this.size),this.strides=(0,G.e3)(ae)}set(ae,...F){0===F.length&&(F=[0]),G.hu(F.length===this.rank,()=>`The number of provided coordinates (${F.length}) must match the rank (${this.rank})`);const ee=this.locToIndex(F);this.values[ee]=ae}get(...ae){0===ae.length&&(ae=[0]);let F=0;for(const he of ae){if(he<0||he>=this.shape[F])throw new Error(`Requested out of range element at ${ae}.   Buffer shape=${this.shape}`);F++}let ee=ae[ae.length-1];for(let he=0;he<ae.length-1;++he)ee+=this.strides[he]*ae[he];return this.values[ee]}locToIndex(ae){if(0===this.rank)return 0;if(1===this.rank)return ae[0];let F=ae[ae.length-1];for(let ee=0;ee<ae.length-1;++ee)F+=this.strides[ee]*ae[ee];return F}indexToLoc(ae){if(0===this.rank)return[];if(1===this.rank)return[ae];const F=new Array(this.shape.length);for(let ee=0;ee<F.length-1;++ee)F[ee]=Math.floor(ae/this.strides[ee]),ae-=F[ee]*this.strides[ee];return F[F.length-1]=ae,F}get rank(){return this.shape.length}toTensor(){return ge().makeTensor(this.values,this.shape,this.dtype)}}let ge=null,Fe=null,ut=null;function ot(Q){ge=Q}function Mt(Q){Fe=Q}function ct(Q){ut=Q}class de{constructor(ae,F,ee,he){this.kept=!1,this.isDisposedInternal=!1,this.shape=ae.slice(),this.dtype=F||"float32",this.size=G.NA(ae),this.strides=(0,G.e3)(ae),this.dataId=ee,this.id=he,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var ae=this;return(0,ue.Z)(function*(){const F=yield ae.data();return Fe.buffer(ae.shape,ae.dtype,F)})()}bufferSync(){return Fe.buffer(this.shape,this.dtype,this.dataSync())}array(){var ae=this;return(0,ue.Z)(function*(){const F=yield ae.data();return(0,G.GX)(ae.shape,F,"complex64"===ae.dtype)})()}arraySync(){return(0,G.GX)(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var ae=this;return(0,ue.Z)(function*(){ae.throwIfDisposed();const F=ge().read(ae.dataId);if("string"===ae.dtype){const ee=yield F;try{return ee.map(he=>se.decodeString(he))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return F})()}dataToGPU(ae){return this.throwIfDisposed(),ge().readToGPU(this.dataId,ae)}dataSync(){this.throwIfDisposed();const ae=ge().readSync(this.dataId);if("string"===this.dtype)try{return ae.map(F=>se.decodeString(F))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return ae}bytes(){var ae=this;return(0,ue.Z)(function*(){ae.throwIfDisposed();const F=yield ge().read(ae.dataId);return"string"===ae.dtype?F:new Uint8Array(F.buffer)})()}dispose(){this.isDisposed||(ge().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(ae=!1){return Fe.print(this,ae)}clone(){return this.throwIfDisposed(),Fe.clone(this)}toString(ae=!1){return pe(this.dataSync(),this.shape,this.dtype,ae)}cast(ae){return this.throwIfDisposed(),Fe.cast(this,ae)}variable(ae=!0,F,ee){return this.throwIfDisposed(),ge().makeVariable(this,ae,F,ee)}}Object.defineProperty(de,Symbol.hasInstance,{value:Q=>!!Q&&null!=Q.data&&null!=Q.dataSync&&null!=Q.throwIfDisposed}),function nt(){(0,xe.R)("Tensor",()=>de)}();class Be extends de{constructor(ae,F,ee,he){super(ae.shape,ae.dtype,ae.dataId,he),this.trainable=F,this.name=ee}assign(ae){if(ae.dtype!==this.dtype)throw new Error(`dtype of the new value (${ae.dtype}) and previous value (${this.dtype}) must match`);if(!G.cO(ae.shape,this.shape))throw new Error(`shape of the new value (${ae.shape}) and previous value (${this.shape}) must match`);ge().disposeTensor(this),this.dataId=ae.dataId,ge().incRef(this,null)}dispose(){ge().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Be,Symbol.hasInstance,{value:Q=>Q instanceof de&&null!=Q.assign&&Q.assign instanceof Function})},7904:(mt,Le,O)=>{"use strict";O.r(Le),O.d(Le,{assertTypesMatch:()=>P,getTensorsInContainer:()=>pe,isTensorInList:()=>U,makeTypesMatch:()=>q});var ue=O(708),xe=O(7770),G=O(1396);function q(ie,re){if(ie.dtype===re.dtype)return[ie,re];const I=(0,xe.x8)(ie.dtype,re.dtype);return[ie.cast(I),re.cast(I)]}function P(ie,re){(0,G.hu)(ie.dtype===re.dtype,()=>`The dtypes of the first(${ie.dtype}) and second(${re.dtype}) input must match`)}function U(ie,re){return re.some(I=>I.id===ie.id)}function pe(ie){const re=[];return ce(ie,re,new Set),re}function ce(ie,re,I){if(null==ie)return;if(ie instanceof ue.es)return void re.push(ie);if(!function X(ie){return Array.isArray(ie)||"object"==typeof ie}(ie))return;const se=ie;for(const Ae in se){const ge=se[Ae];I.has(ge)||(I.add(ge),ce(ge,re,I))}}},9608:(mt,Le,O)=>{"use strict";O.d(Le,{C:()=>pe,_1:()=>ie,sI:()=>re});var ue=O(3738),xe=O(1777),G=O(708),q=O(7770),P=O(8813),U=O(1396);function pe(I,se){let Ae=I;if((0,P.isTypedArray)(I))return"string"===se?[]:[I.length];if((0,q.Oq)(I))return[I.height,I.width*(I.channels||"RGBA").length];if((0,q.$F)(I))return[I.buffer.size/(null==se?4:(0,U.bT)(se))];if(!Array.isArray(I))return[];const ge=[];for(;Array.isArray(Ae)||(0,P.isTypedArray)(Ae)&&"string"!==se;)ge.push(Ae.length),Ae=Ae[0];return Array.isArray(I)&&(0,xe.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ce(I,ge,[]),ge}function ce(I,se,Ae){if(Ae=Ae||[],!Array.isArray(I)&&!(0,P.isTypedArray)(I))return void(0,U.hu)(0===se.length,()=>`Element arr[${Ae.join("][")}] is a primitive, but should be an array/TypedArray of ${se[0]} elements`);(0,U.hu)(se.length>0,()=>`Element arr[${Ae.join("][")}] should be a primitive, but is an array of ${I.length} elements`),(0,U.hu)(I.length===se[0],()=>`Element arr[${Ae.join("][")}] should have ${se[0]} elements, but has ${I.length} elements`);const ge=se.slice(1);for(let Fe=0;Fe<I.length;++Fe)ce(I[Fe],ge,Ae.concat(Fe))}function X(I,se,Ae,ge){if("string_or_numeric"!==I){if(null==I)throw new Error("Expected dtype cannot be null.");if("numeric"!==I&&I!==se||"numeric"===I&&"string"===se)throw new Error(`Argument '${Ae}' passed to '${ge}' must be ${I} tensor, but got ${se} tensor`)}}function ie(I,se,Ae,ge="numeric"){if(I instanceof G.es)return X(ge,I.dtype,se,Ae),I;let Fe=(0,U.D2)(I);if("string"!==Fe&&["bool","int32","float32"].indexOf(ge)>=0&&(Fe=ge),X(ge,Fe,se,Ae),null==I||!(0,P.isTypedArray)(I)&&!Array.isArray(I)&&"number"!=typeof I&&"boolean"!=typeof I&&"string"!=typeof I)throw new Error(`Argument '${se}' passed to '${Ae}' must be a Tensor or TensorLike, but got '${null==I?"null":I.constructor.name}'`);const ut=pe(I,Fe);!(0,P.isTypedArray)(I)&&!Array.isArray(I)&&(I=[I]);const Mt="string"!==Fe?(0,P.toTypedArray)(I,Fe):(0,P.flatten)(I,[],!0);return ue.BV.makeTensor(Mt,ut,Fe)}function re(I,se,Ae,ge="numeric"){if(!Array.isArray(I))throw new Error(`Argument ${se} passed to ${Ae} must be a \`Tensor[]\` or \`TensorLike[]\``);return I.map((ut,ot)=>ie(ut,`${se}[${ot}]`,Ae,ge))}},7770:(mt,Le,O)=>{"use strict";O.d(Le,{$F:()=>ie,Oq:()=>X,x8:()=>pe,yw:()=>ue,z4:()=>ce});var ue=(()=>((ue=ue||{}).R0="R0",ue.R1="R1",ue.R2="R2",ue.R3="R3",ue.R4="R4",ue.R5="R5",ue.R6="R6",ue))(),xe=(()=>((xe=xe||{}).float32="float32",xe.int32="int32",xe.bool="int32",xe.complex64="complex64",xe))(),G=(()=>((G=G||{}).float32="float32",G.int32="int32",G.bool="bool",G.complex64="complex64",G))(),q=(()=>((q=q||{}).float32="float32",q.int32="float32",q.bool="float32",q.complex64="complex64",q))(),P=(()=>((P=P||{}).float32="complex64",P.int32="complex64",P.bool="complex64",P.complex64="complex64",P))();const U={float32:q,int32:xe,bool:G,complex64:P};function pe(re,I){if("string"===re||"string"===I){if("string"===re&&"string"===I)return"string";throw new Error(`Can not upcast ${re} with ${I}`)}return U[re][I]}function ce(re){return pe(re,"int32")}function X(re){return null!=re&&"object"==typeof re&&"texture"in re&&re.texture instanceof WebGLTexture}function ie(re){return typeof GPUBuffer<"u"&&null!=re&&"object"==typeof re&&"buffer"in re&&re.buffer instanceof GPUBuffer}},8813:(mt,Le,O)=>{"use strict";O.r(Le),O.d(Le,{arraysEqual:()=>G.cO,arraysEqualWithNull:()=>G.DK,assert:()=>G.hu,assertNonNegativeIntegerDimensions:()=>G.Mu,assertNonNull:()=>G.Cq,assertShapesMatch:()=>G.k5,bytesFromStringArray:()=>G.Ub,bytesPerElement:()=>G.bT,checkConversionForErrors:()=>G.D5,clamp:()=>G.uZ,computeStrides:()=>G.e3,convertBackendValuesAndArrayBuffer:()=>G.KS,createScalarValue:()=>Be,createShuffledIndices:()=>G.U$,decodeString:()=>Re,distSquared:()=>G.E7,encodeString:()=>he,fetch:()=>ee,fingerPrint64:()=>nt,flatten:()=>ze,getArrayFromDType:()=>G.rQ,getTypedArrayFromDType:()=>G.WP,hasEncodingLoss:()=>G.QB,hexToLong:()=>pe,indexToLoc:()=>G.NE,inferDtype:()=>G.D2,inferFromImplicitShape:()=>G.JZ,isBoolean:()=>G.jn,isFunction:()=>G.mf,isInt:()=>G.GN,isNumber:()=>G.hj,isPromise:()=>G.tI,isScalarShape:()=>G.xH,isString:()=>G.HD,isTypedArray:()=>S,isValidDtype:()=>G.LP,locToIndex:()=>G.qy,makeOnesTypedArray:()=>G.p8,makeZerosNestedTypedArray:()=>G.l6,makeZerosTypedArray:()=>G.wT,nearestDivisor:()=>G.jP,nearestLargerEven:()=>G.nY,now:()=>F,parseAxisParam:()=>G.EC,randUniform:()=>G.bj,repeatedTry:()=>G.WD,rightPad:()=>G.oj,shuffle:()=>G.TV,shuffleCombo:()=>G.d7,sizeFromShape:()=>G.NA,sizeToSquarishShape:()=>G.YP,squeezeShape:()=>G.bp,sum:()=>G.Sm,swap:()=>G.LF,tanh:()=>G.AE,toNestedArray:()=>G.GX,toTypedArray:()=>ae});var ue=O(1777),xe=O(1946),G=O(1396),q=O(7658);const U=O.n(q)()||q;function pe(ye){return U.fromString(ye,!0,16)}const ce=pe("c3a5c85c97cb3127"),X=pe("b492b66fbe98f273"),ie=pe("9ae16a3b2f90404f");function re(ye){return ye.xor(ye.shru(47))}function I(ye,ve,Me){const ke=ye.slice(ve,ve+Me);return U.fromBytes(Array.from(ke),!0,!0)}function se(ye,ve){return I(ye,ve,8)}function Ae(ye,ve){return I(ye,ve,4)}function ge(ye,ve){return 0===ve?ye:ye.shru(ve).or(ye.shl(64-ve))}function Fe(ye,ve,Me=pe("9ddfea08eb382d69")){let ke=ye.xor(ve).mul(Me);ke=ke.xor(ke.shru(47));let we=ve.xor(ke).mul(Me);return we=we.xor(we.shru(47)),we=we.mul(Me),we}function ot(ye,ve,Me,ke){return function ut(ye,ve,Me,ke,we,_t){we=we.add(ye),_t=ge(_t.add(we).add(ke),21);const At=we;return we=(we=we.add(ve)).add(Me),_t=_t.add(ge(we,44)),[we.add(ke),_t.add(At)]}(se(ye,ve),se(ye,ve+8),se(ye,ve+16),se(ye,ve+24),Me,ke)}function nt(ye,ve=ye.length){const Me=U.fromNumber(81,!0);if(ve<=32)return ve<=16?function Mt(ye,ve=ye.length){if(ve>=8){const Me=ie.add(2*ve),ke=se(ye,0).add(ie),we=se(ye,ve-8);return Fe(ge(we,37).mul(Me).add(ke),ge(ke,25).add(we).mul(Me),Me)}if(ve>=4){const Me=ie.add(2*ve);return Fe(Ae(ye,0).shl(3).add(ve),Ae(ye,ve-4),Me)}if(ve>0){const At=ve+(ye[ve-1]<<2);return re(ie.mul(ye[0]+(ye[ve>>1]<<8)).xor(ce.mul(At))).mul(ie)}return ie}(ye,ve):function ct(ye,ve=ye.length){const Me=ie.add(2*ve),ke=se(ye,0).mul(X),we=se(ye,8),_t=se(ye,ve-8).mul(Me),At=se(ye,ve-16).mul(ie);return Fe(ge(ke.add(we),43).add(ge(_t,30)).add(At),ke.add(ge(we.add(ie),18)).add(_t),Me)}(ye,ve);if(ve<=64)return function de(ye,ve=ye.length){const Me=ie.add(2*ve),ke=se(ye,0).mul(ie),we=se(ye,8),_t=se(ye,ve-8).mul(Me),At=se(ye,ve-16).mul(ie),et=ge(ke.add(we),43).add(ge(_t,30)).add(At),Kt=Fe(et,ke.add(ge(we.add(ie),18)).add(_t),Me),dn=se(ye,16).mul(Me),nn=se(ye,24),Vt=et.add(se(ye,ve-32)).mul(Me),rn=Kt.add(se(ye,ve-24)).mul(Me);return Fe(ge(dn.add(nn),43).add(ge(Vt,30)).add(rn),dn.add(ge(nn.add(ke),18)).add(Vt),Me)}(ye,ve);let ke=Me,we=Me.mul(X).add(113),_t=re(we.mul(ie).add(113)).mul(ie),At=[U.UZERO,U.UZERO],et=[U.UZERO,U.UZERO];ke=ke.mul(ie).add(se(ye,0));let Kt=0;const dn=64*(ve-1>>6),nn=dn+(ve-1&63)-63;do{ke=ge(ke.add(we).add(At[0]).add(se(ye,Kt+8)),37).mul(X),we=ge(we.add(At[1]).add(se(ye,Kt+48)),42).mul(X),ke=ke.xor(et[1]),we=we.add(At[0]).add(se(ye,Kt+40)),_t=ge(_t.add(et[0]),33).mul(X),At=ot(ye,Kt,At[1].mul(X),ke.add(et[0])),et=ot(ye,Kt+32,_t.add(et[1]),we.add(se(ye,Kt+16))),[_t,ke]=[ke,_t],Kt+=64}while(Kt!==dn);const Vt=X.add(_t.and(255).shl(1));return Kt=nn,et[0]=et[0].add(ve-1&63),At[0]=At[0].add(et[0]),et[0]=et[0].add(At[0]),ke=ge(ke.add(we).add(At[0]).add(se(ye,Kt+8)),37).mul(Vt),we=ge(we.add(At[1]).add(se(ye,Kt+48)),42).mul(Vt),ke=ke.xor(et[1].mul(9)),we=we.add(At[0].mul(9).add(se(ye,Kt+40))),_t=ge(_t.add(et[0]),33).mul(Vt),At=ot(ye,Kt,At[1].mul(Vt),ke.add(et[0])),et=ot(ye,Kt+32,_t.add(et[1]),we.add(se(ye,Kt+16))),[_t,ke]=[ke,_t],Fe(Fe(At[0],et[0],Vt).add(re(we).mul(ce)).add(_t),Fe(At[1],et[1],Vt).add(ke),Vt)}function Be(ye,ve){return"string"===ve?he(ye):ae([ye],ve)}function ae(ye,ve){if("string"===ve)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(ye)&&(ye=ze(ye)),(0,ue.OB)().getBool("DEBUG")&&G.D5(ye,ve),function Q(ye,ve){return ye instanceof Float32Array&&"float32"===ve||ye instanceof Int32Array&&"int32"===ve||ye instanceof Uint8Array&&"bool"===ve}(ye,ve))return ye;if(null==ve||"float32"===ve||"complex64"===ve)return new Float32Array(ye);if("int32"===ve)return new Int32Array(ye);if("bool"===ve){const Me=new Uint8Array(ye.length);for(let ke=0;ke<Me.length;++ke)0!==Math.round(ye[ke])&&(Me[ke]=1);return Me}throw new Error(`Unknown data type ${ve}`)}function F(){return(0,ue.OB)().platform.now()}function ee(ye,ve){return(0,ue.OB)().platform.fetch(ye,ve)}function he(ye,ve="utf-8"){return ve=ve||"utf-8",(0,ue.OB)().platform.encode(ye,ve)}function Re(ye,ve="utf-8"){return ve=ve||"utf-8",(0,ue.OB)().platform.decode(ye,ve)}function S(ye){return null!=(0,ue.OB)().platform.isTypedArray?(0,ue.OB)().platform.isTypedArray(ye):(0,xe.j)(ye)}function ze(ye,ve=[],Me=!1){if(null==ve&&(ve=[]),"boolean"==typeof ye||"number"==typeof ye||"string"==typeof ye||G.tI(ye)||null==ye||S(ye)&&Me)ve.push(ye);else if(Array.isArray(ye)||S(ye))for(let ke=0;ke<ye.length;++ke)ze(ye[ke],ve,Me);else{let ke=-1;for(const we of Object.keys(ye))/^([1-9]+[0-9]*|0)$/.test(we)&&(ke=Math.max(ke,Number(we)));for(let we=0;we<=ke;we++)ze(ye[we],ve,Me)}return ve}},1396:(mt,Le,O)=>{"use strict";function ue(Se){let Ge=Se.length,rt=0;for(;Ge>0;)rt=Math.random()*Ge|0,Ge--,P(Se,Ge,rt)}function xe(Se,Ge){if(Se.length!==Ge.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${Se.length}Second array length was ${Ge.length}`);let rt=Se.length,Rt=0;for(;rt>0;)Rt=Math.random()*rt|0,rt--,P(Se,rt,Rt),P(Ge,rt,Rt)}function G(Se,Ge,rt){return Math.max(Se,Math.min(Ge,rt))}function q(Se){return Se%2==0?Se:Se+1}function P(Se,Ge,rt){const Rt=Se[Ge];Se[Ge]=Se[rt],Se[rt]=Rt}function U(Se){let Ge=0;for(let rt=0;rt<Se.length;rt++)Ge+=Se[rt];return Ge}function pe(Se,Ge){const rt=Math.random();return Ge*rt+(1-rt)*Se}function ce(Se,Ge){let rt=0;for(let Rt=0;Rt<Se.length;Rt++){const _n=Number(Se[Rt])-Number(Ge[Rt]);rt+=_n*_n}return rt}function X(Se,Ge){if(!Se)throw new Error("string"==typeof Ge?Ge:Ge())}function ie(Se,Ge,rt=""){X(ge(Se,Ge),()=>rt+` Shapes ${Se} and ${Ge} must match`)}function re(Se){X(null!=Se,()=>"The input to the tensor constructor must be a non-null value.")}function I(Se){if(0===Se.length)return 1;let Ge=Se[0];for(let rt=1;rt<Se.length;rt++)Ge*=Se[rt];return Ge}function se(Se){return 0===Se.length}function Ae(Se,Ge){if(Se===Ge)return!0;if(null==Se||null==Ge||Se.length!==Ge.length)return!1;for(let rt=0;rt<Se.length;rt++)if(null!==Se[rt]&&null!==Ge[rt]&&Se[rt]!==Ge[rt])return!1;return!0}function ge(Se,Ge){if(Se===Ge)return!0;if(null==Se||null==Ge||Se.length!==Ge.length)return!1;for(let rt=0;rt<Se.length;rt++)if(Se[rt]!==Ge[rt])return!1;return!0}function Fe(Se){return Se%1==0}function ut(Se){if(null!=Math.tanh)return Math.tanh(Se);if(Se===1/0)return 1;if(Se===-1/0)return-1;{const Ge=Math.exp(2*Se);return(Ge-1)/(Ge+1)}}function ot(Se){const Ge=Math.ceil(Math.sqrt(Se));return[Ge,Math.ceil(Se/Ge)]}function Mt(Se){const Ge=new Uint32Array(Se);for(let rt=0;rt<Se;++rt)Ge[rt]=rt;return ue(Ge),Ge}function ct(Se,Ge){return Ge<=Se.length?Se:Se+" ".repeat(Ge-Se.length)}function de(Se,Ge=(_n=>0),rt,Rt){return new Promise((_n,Nn)=>{let Er=0;const Yn=()=>{if(Se())return void _n();Er++;const Mr=Ge(Er);null!=rt&&Er>=rt?Nn():null!=Rt?Rt(Yn,Mr):setTimeout(Yn,Mr)};Yn()})}function nt(Se,Ge){let rt=1,Rt=-1;for(let Nn=0;Nn<Se.length;++Nn)if(Se[Nn]>=0)rt*=Se[Nn];else if(-1===Se[Nn]){if(-1!==Rt)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${Rt} and dim ${Nn}`);Rt=Nn}else if(Se[Nn]<0)throw Error(`Shapes can not be < 0. Found ${Se[Nn]} at dim ${Nn}`);if(-1===Rt){if(Ge>0&&Ge!==rt)throw Error(`Size(${Ge}) must match the product of shape ${Se}`);return Se}if(0===rt)throw Error(`Cannot infer the missing size in [${Se}] when there are 0 elements`);if(Ge%rt!=0)throw Error(`The implicit shape can't be a fractional number. Got ${Ge} / ${rt}`);const _n=Se.slice();return _n[Rt]=Ge/rt,_n}function Be(Se,Ge){const rt=Ge.length;return X((Se=null==Se?Ge.map((Rt,_n)=>_n):[].concat(Se)).every(Rt=>Rt>=-rt&&Rt<rt),()=>`All values in axis param must be in range [-${rt}, ${rt}) but got axis ${Se}`),X(Se.every(Rt=>Fe(Rt)),()=>`All values in axis param must be integers but got axis ${Se}`),Se.map(Rt=>Rt<0?rt+Rt:Rt)}function Q(Se,Ge){const rt=[],Rt=[],_n=null!=Ge&&Array.isArray(Ge)&&0===Ge.length,Nn=null==Ge||_n?null:Be(Ge,Se).sort();let Er=0;for(let Yn=0;Yn<Se.length;++Yn){if(null!=Nn){if(Nn[Er]===Yn&&1!==Se[Yn])throw new Error(`Can't squeeze axis ${Yn} since its dim '${Se[Yn]}' is not 1`);(null==Nn[Er]||Nn[Er]>Yn)&&1===Se[Yn]&&(rt.push(Se[Yn]),Rt.push(Yn)),Nn[Er]<=Yn&&Er++}1!==Se[Yn]&&(rt.push(Se[Yn]),Rt.push(Yn))}return{newShape:rt,keptDims:Rt}}function ae(Se,Ge){return F(Se,Ge)}function F(Se,Ge){let rt=null;if(null==Se||"float32"===Se)rt=new Float32Array(Ge);else if("int32"===Se)rt=new Int32Array(Ge);else if("bool"===Se)rt=new Uint8Array(Ge);else{if("string"!==Se)throw new Error(`Unknown data type ${Se}`);rt=new Array(Ge)}return rt}function ee(Se,Ge){for(let rt=0;rt<Se.length;rt++){const Rt=Se[rt];if(isNaN(Rt)||!isFinite(Rt))throw Error(`A tensor of type ${Ge} being uploaded contains ${Rt}.`)}}function he(Se){return"bool"===Se||"complex64"===Se||"float32"===Se||"int32"===Se||"string"===Se}function Re(Se,Ge){return!("complex64"===Ge||"float32"===Ge&&"complex64"!==Se||"int32"===Ge&&"float32"!==Se&&"complex64"!==Se||"bool"===Ge&&"bool"===Se)}function S(Se){if("float32"===Se||"int32"===Se)return 4;if("complex64"===Se)return 8;if("bool"===Se)return 1;throw new Error(`Unknown dtype ${Se}`)}function ze(Se){if(null==Se)return 0;let Ge=0;return Se.forEach(rt=>Ge+=rt.length),Ge}function ye(Se){return"string"==typeof Se||Se instanceof String}function ve(Se){return"boolean"==typeof Se}function Me(Se){return"number"==typeof Se}function ke(Se){return Array.isArray(Se)?ke(Se[0]):Se instanceof Float32Array?"float32":Se instanceof Int32Array||Se instanceof Uint8Array||Se instanceof Uint8ClampedArray?"int32":Me(Se)?"float32":ye(Se)?"string":ve(Se)?"bool":"float32"}function we(Se){return!!(Se&&Se.constructor&&Se.call&&Se.apply)}function _t(Se,Ge){for(let rt=Ge;rt<Se;++rt)if(Se%rt==0)return rt;return Se}function At(Se){const Ge=Se.length;if(Ge<2)return[];const rt=new Array(Ge-1);rt[Ge-2]=Se[Ge-1];for(let Rt=Ge-3;Rt>=0;--Rt)rt[Rt]=rt[Rt+1]*Se[Rt+1];return rt}function et(Se,Ge,rt,Rt=!1){const _n=new Array;if(1===Ge.length){const Nn=Ge[0]*(Rt?2:1);for(let Er=0;Er<Nn;Er++)_n[Er]=rt[Se+Er]}else{const Nn=Ge[0],Er=Ge.slice(1),Yn=Er.reduce((Mr,Zo)=>Mr*Zo)*(Rt?2:1);for(let Mr=0;Mr<Nn;Mr++)_n[Mr]=et(Se+Mr*Yn,Er,rt,Rt)}return _n}function Kt(Se,Ge,rt=!1){if(0===Se.length)return Ge[0];const Rt=Se.reduce((_n,Nn)=>_n*Nn)*(rt?2:1);if(0===Rt)return[];if(Rt!==Ge.length)throw new Error(`[${Se}] does not match the input size ${Ge.length}${rt?" for a complex tensor":""}.`);return et(0,Se,Ge,rt)}function dn(Se,Ge){if(Array.isArray(Se))return Se;if("float32"===Ge)return Se instanceof Float32Array?Se:new Float32Array(Se);if("int32"===Ge)return Se instanceof Int32Array?Se:new Int32Array(Se);if("bool"===Ge||"string"===Ge)return Uint8Array.from(new Int32Array(Se));throw new Error(`Unknown dtype ${Ge}`)}function nn(Se,Ge){const rt=Vt(Se,Ge);for(let Rt=0;Rt<rt.length;Rt++)rt[Rt]=1;return rt}function Vt(Se,Ge){if(null==Ge||"float32"===Ge||"complex64"===Ge)return new Float32Array(Se);if("int32"===Ge)return new Int32Array(Se);if("bool"===Ge)return new Uint8Array(Se);throw new Error(`Unknown data type ${Ge}`)}function rn(Se,Ge){const rt=Se.reduce((Rt,_n)=>Rt*_n,1);if(null==Ge||"float32"===Ge)return Kt(Se,new Float32Array(rt));if("int32"===Ge)return Kt(Se,new Int32Array(rt));if("bool"===Ge)return Kt(Se,new Uint8Array(rt));throw new Error(`Unknown data type ${Ge}`)}function gt(Se){Se.forEach(Ge=>{X(Number.isInteger(Ge)&&Ge>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${Se}].`)})}function cn(Se,Ge,rt){if(0===Ge)return 0;if(1===Ge)return Se[0];let Rt=Se[Se.length-1];for(let _n=0;_n<Se.length-1;++_n)Rt+=rt[_n]*Se[_n];return Rt}function wi(Se,Ge,rt){if(0===Ge)return[];if(1===Ge)return[Se];const Rt=new Array(Ge);for(let _n=0;_n<Rt.length-1;++_n)Rt[_n]=Math.floor(Se/rt[_n]),Se-=Rt[_n]*rt[_n];return Rt[Rt.length-1]=Se,Rt}function Rn(Se){return Se&&Se.then&&"function"==typeof Se.then}O.d(Le,{AE:()=>ut,Cq:()=>re,D2:()=>ke,D5:()=>ee,DK:()=>Ae,E7:()=>ce,EC:()=>Be,GN:()=>Fe,GX:()=>Kt,HD:()=>ye,JZ:()=>nt,KS:()=>dn,LF:()=>P,LP:()=>he,Mu:()=>gt,NA:()=>I,NE:()=>wi,QB:()=>Re,Sm:()=>U,TV:()=>ue,U$:()=>Mt,Ub:()=>ze,WD:()=>de,WP:()=>ae,YP:()=>ot,bT:()=>S,bj:()=>pe,bp:()=>Q,cO:()=>ge,d7:()=>xe,e3:()=>At,hj:()=>Me,hu:()=>X,jP:()=>_t,jn:()=>ve,k5:()=>ie,l6:()=>rn,mf:()=>we,nY:()=>q,oj:()=>ct,p8:()=>nn,qy:()=>cn,rQ:()=>F,tI:()=>Rn,uZ:()=>G,wT:()=>Vt,xH:()=>se})},7658:mt=>{mt.exports=O;var Le=null;try{Le=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function O(ae,F,ee){this.low=0|ae,this.high=0|F,this.unsigned=!!ee}function ue(ae){return!0===(ae&&ae.__isLong__)}Object.defineProperty(O.prototype,"__isLong__",{value:!0}),O.isLong=ue;var xe={},G={};function q(ae,F){var ee,he,Re;return F?(Re=0<=(ae>>>=0)&&ae<256)&&(he=G[ae])?he:(ee=U(ae,(0|ae)<0?-1:0,!0),Re&&(G[ae]=ee),ee):(Re=-128<=(ae|=0)&&ae<128)&&(he=xe[ae])?he:(ee=U(ae,ae<0?-1:0,!1),Re&&(xe[ae]=ee),ee)}function P(ae,F){if(isNaN(ae))return F?ut:Fe;if(F){if(ae<0)return ut;if(ae>=se)return nt}else{if(ae<=-Ae)return Be;if(ae+1>=Ae)return de}return ae<0?P(-ae,F).neg():U(ae%I|0,ae/I|0,F)}function U(ae,F,ee){return new O(ae,F,ee)}O.fromInt=q,O.fromNumber=P,O.fromBits=U;var pe=Math.pow;function ce(ae,F,ee){if(0===ae.length)throw Error("empty string");if("NaN"===ae||"Infinity"===ae||"+Infinity"===ae||"-Infinity"===ae)return Fe;if("number"==typeof F?(ee=F,F=!1):F=!!F,(ee=ee||10)<2||36<ee)throw RangeError("radix");var he;if((he=ae.indexOf("-"))>0)throw Error("interior hyphen");if(0===he)return ce(ae.substring(1),F,ee).neg();for(var Re=P(pe(ee,8)),S=Fe,ze=0;ze<ae.length;ze+=8){var ye=Math.min(8,ae.length-ze),ve=parseInt(ae.substring(ze,ze+ye),ee);if(ye<8){var Me=P(pe(ee,ye));S=S.mul(Me).add(P(ve))}else S=(S=S.mul(Re)).add(P(ve))}return S.unsigned=F,S}function X(ae,F){return"number"==typeof ae?P(ae,F):"string"==typeof ae?ce(ae,F):U(ae.low,ae.high,"boolean"==typeof F?F:ae.unsigned)}O.fromString=ce,O.fromValue=X;var I=4294967296,se=I*I,Ae=se/2,ge=q(1<<24),Fe=q(0);O.ZERO=Fe;var ut=q(0,!0);O.UZERO=ut;var ot=q(1);O.ONE=ot;var Mt=q(1,!0);O.UONE=Mt;var ct=q(-1);O.NEG_ONE=ct;var de=U(-1,2147483647,!1);O.MAX_VALUE=de;var nt=U(-1,-1,!0);O.MAX_UNSIGNED_VALUE=nt;var Be=U(0,-2147483648,!1);O.MIN_VALUE=Be;var Q=O.prototype;Q.toInt=function(){return this.unsigned?this.low>>>0:this.low},Q.toNumber=function(){return this.unsigned?(this.high>>>0)*I+(this.low>>>0):this.high*I+(this.low>>>0)},Q.toString=function(F){if((F=F||10)<2||36<F)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Be)){var ee=P(F),he=this.div(ee),Re=he.mul(ee).sub(this);return he.toString(F)+Re.toInt().toString(F)}return"-"+this.neg().toString(F)}for(var S=P(pe(F,6),this.unsigned),ze=this,ye="";;){var ve=ze.div(S),ke=(ze.sub(ve.mul(S)).toInt()>>>0).toString(F);if((ze=ve).isZero())return ke+ye;for(;ke.length<6;)ke="0"+ke;ye=""+ke+ye}},Q.getHighBits=function(){return this.high},Q.getHighBitsUnsigned=function(){return this.high>>>0},Q.getLowBits=function(){return this.low},Q.getLowBitsUnsigned=function(){return this.low>>>0},Q.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Be)?64:this.neg().getNumBitsAbs();for(var F=0!=this.high?this.high:this.low,ee=31;ee>0&&!(F&1<<ee);ee--);return 0!=this.high?ee+33:ee+1},Q.isZero=function(){return 0===this.high&&0===this.low},Q.eqz=Q.isZero,Q.isNegative=function(){return!this.unsigned&&this.high<0},Q.isPositive=function(){return this.unsigned||this.high>=0},Q.isOdd=function(){return 1==(1&this.low)},Q.isEven=function(){return 0==(1&this.low)},Q.equals=function(F){return ue(F)||(F=X(F)),(this.unsigned===F.unsigned||this.high>>>31!=1||F.high>>>31!=1)&&this.high===F.high&&this.low===F.low},Q.eq=Q.equals,Q.notEquals=function(F){return!this.eq(F)},Q.neq=Q.notEquals,Q.ne=Q.notEquals,Q.lessThan=function(F){return this.comp(F)<0},Q.lt=Q.lessThan,Q.lessThanOrEqual=function(F){return this.comp(F)<=0},Q.lte=Q.lessThanOrEqual,Q.le=Q.lessThanOrEqual,Q.greaterThan=function(F){return this.comp(F)>0},Q.gt=Q.greaterThan,Q.greaterThanOrEqual=function(F){return this.comp(F)>=0},Q.gte=Q.greaterThanOrEqual,Q.ge=Q.greaterThanOrEqual,Q.compare=function(F){if(ue(F)||(F=X(F)),this.eq(F))return 0;var ee=this.isNegative(),he=F.isNegative();return ee&&!he?-1:!ee&&he?1:this.unsigned?F.high>>>0>this.high>>>0||F.high===this.high&&F.low>>>0>this.low>>>0?-1:1:this.sub(F).isNegative()?-1:1},Q.comp=Q.compare,Q.negate=function(){return!this.unsigned&&this.eq(Be)?Be:this.not().add(ot)},Q.neg=Q.negate,Q.add=function(F){ue(F)||(F=X(F));var ke=0,we=0,_t=0,At=0;return _t+=(At+=(65535&this.low)+(65535&F.low))>>>16,we+=(_t+=(this.low>>>16)+(F.low>>>16))>>>16,ke+=(we+=(65535&this.high)+(65535&F.high))>>>16,ke+=(this.high>>>16)+(F.high>>>16),U((_t&=65535)<<16|(At&=65535),(ke&=65535)<<16|(we&=65535),this.unsigned)},Q.subtract=function(F){return ue(F)||(F=X(F)),this.add(F.neg())},Q.sub=Q.subtract,Q.multiply=function(F){if(this.isZero())return Fe;if(ue(F)||(F=X(F)),Le)return U(Le.mul(this.low,this.high,F.low,F.high),Le.get_high(),this.unsigned);if(F.isZero())return Fe;if(this.eq(Be))return F.isOdd()?Be:Fe;if(F.eq(Be))return this.isOdd()?Be:Fe;if(this.isNegative())return F.isNegative()?this.neg().mul(F.neg()):this.neg().mul(F).neg();if(F.isNegative())return this.mul(F.neg()).neg();if(this.lt(ge)&&F.lt(ge))return P(this.toNumber()*F.toNumber(),this.unsigned);var Re=65535&this.high,S=this.low>>>16,ze=65535&this.low,ve=65535&F.high,Me=F.low>>>16,ke=65535&F.low,we=0,_t=0,At=0,et=0;return At+=(et+=ze*ke)>>>16,_t+=(At+=S*ke)>>>16,At&=65535,_t+=(At+=ze*Me)>>>16,we+=(_t+=Re*ke)>>>16,_t&=65535,we+=(_t+=S*Me)>>>16,_t&=65535,we+=(_t+=ze*ve)>>>16,we+=(this.high>>>16)*ke+Re*Me+S*ve+ze*(F.high>>>16),U((At&=65535)<<16|(et&=65535),(we&=65535)<<16|(_t&=65535),this.unsigned)},Q.mul=Q.multiply,Q.divide=function(F){if(ue(F)||(F=X(F)),F.isZero())throw Error("division by zero");var he,Re,S;if(Le)return this.unsigned||-2147483648!==this.high||-1!==F.low||-1!==F.high?U((this.unsigned?Le.div_u:Le.div_s)(this.low,this.high,F.low,F.high),Le.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?ut:Fe;if(this.unsigned){if(F.unsigned||(F=F.toUnsigned()),F.gt(this))return ut;if(F.gt(this.shru(1)))return Mt;S=ut}else{if(this.eq(Be))return F.eq(ot)||F.eq(ct)?Be:F.eq(Be)?ot:(he=this.shr(1).div(F).shl(1)).eq(Fe)?F.isNegative()?ot:ct:(Re=this.sub(F.mul(he)),S=he.add(Re.div(F)));if(F.eq(Be))return this.unsigned?ut:Fe;if(this.isNegative())return F.isNegative()?this.neg().div(F.neg()):this.neg().div(F).neg();if(F.isNegative())return this.div(F.neg()).neg();S=Fe}for(Re=this;Re.gte(F);){he=Math.max(1,Math.floor(Re.toNumber()/F.toNumber()));for(var ye=Math.ceil(Math.log(he)/Math.LN2),ve=ye<=48?1:pe(2,ye-48),Me=P(he),ke=Me.mul(F);ke.isNegative()||ke.gt(Re);)ke=(Me=P(he-=ve,this.unsigned)).mul(F);Me.isZero()&&(Me=ot),S=S.add(Me),Re=Re.sub(ke)}return S},Q.div=Q.divide,Q.modulo=function(F){return ue(F)||(F=X(F)),Le?U((this.unsigned?Le.rem_u:Le.rem_s)(this.low,this.high,F.low,F.high),Le.get_high(),this.unsigned):this.sub(this.div(F).mul(F))},Q.mod=Q.modulo,Q.rem=Q.modulo,Q.not=function(){return U(~this.low,~this.high,this.unsigned)},Q.and=function(F){return ue(F)||(F=X(F)),U(this.low&F.low,this.high&F.high,this.unsigned)},Q.or=function(F){return ue(F)||(F=X(F)),U(this.low|F.low,this.high|F.high,this.unsigned)},Q.xor=function(F){return ue(F)||(F=X(F)),U(this.low^F.low,this.high^F.high,this.unsigned)},Q.shiftLeft=function(F){return ue(F)&&(F=F.toInt()),0==(F&=63)?this:F<32?U(this.low<<F,this.high<<F|this.low>>>32-F,this.unsigned):U(0,this.low<<F-32,this.unsigned)},Q.shl=Q.shiftLeft,Q.shiftRight=function(F){return ue(F)&&(F=F.toInt()),0==(F&=63)?this:F<32?U(this.low>>>F|this.high<<32-F,this.high>>F,this.unsigned):U(this.high>>F-32,this.high>=0?0:-1,this.unsigned)},Q.shr=Q.shiftRight,Q.shiftRightUnsigned=function(F){if(ue(F)&&(F=F.toInt()),0==(F&=63))return this;var ee=this.high;return F<32?U(this.low>>>F|ee<<32-F,ee>>>F,this.unsigned):U(32===F?ee:ee>>>F-32,0,this.unsigned)},Q.shru=Q.shiftRightUnsigned,Q.shr_u=Q.shiftRightUnsigned,Q.toSigned=function(){return this.unsigned?U(this.low,this.high,!1):this},Q.toUnsigned=function(){return this.unsigned?this:U(this.low,this.high,!0)},Q.toBytes=function(F){return F?this.toBytesLE():this.toBytesBE()},Q.toBytesLE=function(){var F=this.high,ee=this.low;return[255&ee,ee>>>8&255,ee>>>16&255,ee>>>24,255&F,F>>>8&255,F>>>16&255,F>>>24]},Q.toBytesBE=function(){var F=this.high,ee=this.low;return[F>>>24,F>>>16&255,F>>>8&255,255&F,ee>>>24,ee>>>16&255,ee>>>8&255,255&ee]},O.fromBytes=function(F,ee,he){return he?O.fromBytesLE(F,ee):O.fromBytesBE(F,ee)},O.fromBytesLE=function(F,ee){return new O(F[0]|F[1]<<8|F[2]<<16|F[3]<<24,F[4]|F[5]<<8|F[6]<<16|F[7]<<24,ee)},O.fromBytesBE=function(F,ee){return new O(F[4]<<24|F[5]<<16|F[6]<<8|F[7],F[0]<<24|F[1]<<16|F[2]<<8|F[3],ee)}},340:(mt,Le,O)=>{var ue=O(9471),xe=O(2992),G=O(7657),q=O(5583),P=O(1929),U=O(8083),pe=O(3818);pe.alea=ue,pe.xor128=xe,pe.xorwow=G,pe.xorshift7=q,pe.xor4096=P,pe.tychei=U,mt.exports=pe},9471:function(mt,Le,O){var ue;!function(xe,G,q){function P(X){var ie=this,re=function ce(){var X=4022871197;return function(re){re=String(re);for(var I=0;I<re.length;I++){var se=.02519603282416938*(X+=re.charCodeAt(I));se-=X=se>>>0,X=(se*=X)>>>0,X+=4294967296*(se-=X)}return 2.3283064365386963e-10*(X>>>0)}}();ie.next=function(){var I=2091639*ie.s0+2.3283064365386963e-10*ie.c;return ie.s0=ie.s1,ie.s1=ie.s2,ie.s2=I-(ie.c=0|I)},ie.c=1,ie.s0=re(" "),ie.s1=re(" "),ie.s2=re(" "),ie.s0-=re(X),ie.s0<0&&(ie.s0+=1),ie.s1-=re(X),ie.s1<0&&(ie.s1+=1),ie.s2-=re(X),ie.s2<0&&(ie.s2+=1),re=null}function U(X,ie){return ie.c=X.c,ie.s0=X.s0,ie.s1=X.s1,ie.s2=X.s2,ie}function pe(X,ie){var re=new P(X),I=ie&&ie.state,se=re.next;return se.int32=function(){return 4294967296*re.next()|0},se.double=function(){return se()+11102230246251565e-32*(2097152*se()|0)},se.quick=se,I&&("object"==typeof I&&U(I,re),se.state=function(){return U(re,{})}),se}G&&G.exports?G.exports=pe:O.amdD&&O.amdO?void 0!==(ue=function(){return pe}.call(Le,O,Le,G))&&(G.exports=ue):this.alea=pe}(0,mt=O.nmd(mt))},8083:function(mt,Le,O){var ue;!function(xe,G,q){function P(ce){var X=this,ie="";X.next=function(){var I=X.b,se=X.c,Ae=X.d,ge=X.a;return I=I<<25^I>>>7^se,se=se-Ae|0,Ae=Ae<<24^Ae>>>8^ge,ge=ge-I|0,X.b=I=I<<20^I>>>12^se,X.c=se=se-Ae|0,X.d=Ae<<16^se>>>16^ge,X.a=ge-I|0},X.a=0,X.b=0,X.c=-1640531527,X.d=1367130551,ce===Math.floor(ce)?(X.a=ce/4294967296|0,X.b=0|ce):ie+=ce;for(var re=0;re<ie.length+20;re++)X.b^=0|ie.charCodeAt(re),X.next()}function U(ce,X){return X.a=ce.a,X.b=ce.b,X.c=ce.c,X.d=ce.d,X}function pe(ce,X){var ie=new P(ce),re=X&&X.state,I=function(){return(ie.next()>>>0)/4294967296};return I.double=function(){do{var ge=((ie.next()>>>11)+(ie.next()>>>0)/4294967296)/(1<<21)}while(0===ge);return ge},I.int32=ie.next,I.quick=I,re&&("object"==typeof re&&U(re,ie),I.state=function(){return U(ie,{})}),I}G&&G.exports?G.exports=pe:O.amdD&&O.amdO?void 0!==(ue=function(){return pe}.call(Le,O,Le,G))&&(G.exports=ue):this.tychei=pe}(0,mt=O.nmd(mt))},2992:function(mt,Le,O){var ue;!function(xe,G,q){function P(ce){var X=this,ie="";X.x=0,X.y=0,X.z=0,X.w=0,X.next=function(){var I=X.x^X.x<<11;return X.x=X.y,X.y=X.z,X.z=X.w,X.w^=X.w>>>19^I^I>>>8},ce===(0|ce)?X.x=ce:ie+=ce;for(var re=0;re<ie.length+64;re++)X.x^=0|ie.charCodeAt(re),X.next()}function U(ce,X){return X.x=ce.x,X.y=ce.y,X.z=ce.z,X.w=ce.w,X}function pe(ce,X){var ie=new P(ce),re=X&&X.state,I=function(){return(ie.next()>>>0)/4294967296};return I.double=function(){do{var ge=((ie.next()>>>11)+(ie.next()>>>0)/4294967296)/(1<<21)}while(0===ge);return ge},I.int32=ie.next,I.quick=I,re&&("object"==typeof re&&U(re,ie),I.state=function(){return U(ie,{})}),I}G&&G.exports?G.exports=pe:O.amdD&&O.amdO?void 0!==(ue=function(){return pe}.call(Le,O,Le,G))&&(G.exports=ue):this.xor128=pe}(0,mt=O.nmd(mt))},1929:function(mt,Le,O){var ue;!function(xe,G,q){function P(ce){var X=this;X.next=function(){var Ae,ge,re=X.w,I=X.X,se=X.i;return X.w=re=re+1640531527|0,ge=I[se+34&127],Ae=I[se=se+1&127],ge^=ge<<13,Ae^=Ae<<17,ge=I[se]=(ge^=ge>>>15)^(Ae^=Ae>>>12),X.i=se,ge+(re^re>>>16)|0},function ie(re,I){var se,Ae,ge,Fe,ut,ot=[],Mt=128;for(I===(0|I)?(Ae=I,I=null):(I+="\0",Ae=0,Mt=Math.max(Mt,I.length)),ge=0,Fe=-32;Fe<Mt;++Fe)I&&(Ae^=I.charCodeAt((Fe+32)%I.length)),0===Fe&&(ut=Ae),Ae^=Ae<<10,Ae^=Ae>>>15,Ae^=Ae<<4,Ae^=Ae>>>13,Fe>=0&&(ge=0==(se=ot[127&Fe]^=Ae+(ut=ut+1640531527|0))?ge+1:0);for(ge>=128&&(ot[127&(I&&I.length||0)]=-1),ge=127,Fe=512;Fe>0;--Fe)Ae=ot[ge+34&127],se=ot[ge=ge+1&127],Ae^=Ae<<13,se^=se<<17,ot[ge]=(Ae^=Ae>>>15)^(se^=se>>>12);re.w=ut,re.X=ot,re.i=ge}(X,ce)}function U(ce,X){return X.i=ce.i,X.w=ce.w,X.X=ce.X.slice(),X}function pe(ce,X){null==ce&&(ce=+new Date);var ie=new P(ce),re=X&&X.state,I=function(){return(ie.next()>>>0)/4294967296};return I.double=function(){do{var ge=((ie.next()>>>11)+(ie.next()>>>0)/4294967296)/(1<<21)}while(0===ge);return ge},I.int32=ie.next,I.quick=I,re&&(re.X&&U(re,ie),I.state=function(){return U(ie,{})}),I}G&&G.exports?G.exports=pe:O.amdD&&O.amdO?void 0!==(ue=function(){return pe}.call(Le,O,Le,G))&&(G.exports=ue):this.xor4096=pe}(0,mt=O.nmd(mt))},5583:function(mt,Le,O){var ue;!function(xe,G,q){function P(ce){var X=this;X.next=function(){var se,Ae,re=X.x,I=X.i;return se=re[I],Ae=(se^=se>>>7)^se<<24,Ae^=(se=re[I+1&7])^se>>>10,Ae^=(se=re[I+3&7])^se>>>3,Ae^=(se=re[I+4&7])^se<<7,se=re[I+7&7],re[I]=Ae^=(se^=se<<13)^se<<9,X.i=I+1&7,Ae},function ie(re,I){var se,ge=[];if(I===(0|I))ge[0]=I;else for(I=""+I,se=0;se<I.length;++se)ge[7&se]=ge[7&se]<<15^I.charCodeAt(se)+ge[se+1&7]<<13;for(;ge.length<8;)ge.push(0);for(se=0;se<8&&0===ge[se];++se);for(8==se&&(ge[7]=-1),re.x=ge,re.i=0,se=256;se>0;--se)re.next()}(X,ce)}function U(ce,X){return X.x=ce.x.slice(),X.i=ce.i,X}function pe(ce,X){null==ce&&(ce=+new Date);var ie=new P(ce),re=X&&X.state,I=function(){return(ie.next()>>>0)/4294967296};return I.double=function(){do{var ge=((ie.next()>>>11)+(ie.next()>>>0)/4294967296)/(1<<21)}while(0===ge);return ge},I.int32=ie.next,I.quick=I,re&&(re.x&&U(re,ie),I.state=function(){return U(ie,{})}),I}G&&G.exports?G.exports=pe:O.amdD&&O.amdO?void 0!==(ue=function(){return pe}.call(Le,O,Le,G))&&(G.exports=ue):this.xorshift7=pe}(0,mt=O.nmd(mt))},7657:function(mt,Le,O){var ue;!function(xe,G,q){function P(ce){var X=this,ie="";X.next=function(){var I=X.x^X.x>>>2;return X.x=X.y,X.y=X.z,X.z=X.w,X.w=X.v,(X.d=X.d+362437|0)+(X.v=X.v^X.v<<4^I^I<<1)|0},X.x=0,X.y=0,X.z=0,X.w=0,X.v=0,ce===(0|ce)?X.x=ce:ie+=ce;for(var re=0;re<ie.length+64;re++)X.x^=0|ie.charCodeAt(re),re==ie.length&&(X.d=X.x<<10^X.x>>>4),X.next()}function U(ce,X){return X.x=ce.x,X.y=ce.y,X.z=ce.z,X.w=ce.w,X.v=ce.v,X.d=ce.d,X}function pe(ce,X){var ie=new P(ce),re=X&&X.state,I=function(){return(ie.next()>>>0)/4294967296};return I.double=function(){do{var ge=((ie.next()>>>11)+(ie.next()>>>0)/4294967296)/(1<<21)}while(0===ge);return ge},I.int32=ie.next,I.quick=I,re&&("object"==typeof re&&U(re,ie),I.state=function(){return U(ie,{})}),I}G&&G.exports?G.exports=pe:O.amdD&&O.amdO?void 0!==(ue=function(){return pe}.call(Le,O,Le,G))&&(G.exports=ue):this.xorwow=pe}(0,mt=O.nmd(mt))},3818:function(mt,Le,O){var ue;!function(xe,G,q){var se,P=256,X=q.pow(P,6),ie=q.pow(2,52),re=2*ie,I=P-1;function Ae(de,nt,Be){var Q=[],ae=ot(ut((nt=1==nt?{entropy:!0}:nt||{}).entropy?[de,ct(G)]:de??function Mt(){try{var de;return se&&(de=se.randomBytes)?de=de(P):(de=new Uint8Array(P),(xe.crypto||xe.msCrypto).getRandomValues(de)),ct(de)}catch{var nt=xe.navigator,Be=nt&&nt.plugins;return[+new Date,xe,Be,xe.screen,ct(G)]}}(),3),Q),F=new ge(Q),ee=function(){for(var he=F.g(6),Re=X,S=0;he<ie;)he=(he+S)*P,Re*=P,S=F.g(1);for(;he>=re;)he/=2,Re/=2,S>>>=1;return(he+S)/Re};return ee.int32=function(){return 0|F.g(4)},ee.quick=function(){return F.g(4)/4294967296},ee.double=ee,ot(ct(F.S),G),(nt.pass||Be||function(he,Re,S,ze){return ze&&(ze.S&&Fe(ze,F),he.state=function(){return Fe(F,{})}),S?(q.random=he,Re):he})(ee,ae,"global"in nt?nt.global:this==q,nt.state)}function ge(de){var nt,Be=de.length,Q=this,ae=0,F=Q.i=Q.j=0,ee=Q.S=[];for(Be||(de=[Be++]);ae<P;)ee[ae]=ae++;for(ae=0;ae<P;ae++)ee[ae]=ee[F=I&F+de[ae%Be]+(nt=ee[ae])],ee[F]=nt;(Q.g=function(he){for(var Re,S=0,ze=Q.i,ye=Q.j,ve=Q.S;he--;)Re=ve[ze=I&ze+1],S=S*P+ve[I&(ve[ze]=ve[ye=I&ye+Re])+(ve[ye]=Re)];return Q.i=ze,Q.j=ye,S})(P)}function Fe(de,nt){return nt.i=de.i,nt.j=de.j,nt.S=de.S.slice(),nt}function ut(de,nt){var ae,Be=[],Q=typeof de;if(nt&&"object"==Q)for(ae in de)try{Be.push(ut(de[ae],nt-1))}catch{}return Be.length?Be:"string"==Q?de:de+"\0"}function ot(de,nt){for(var Q,Be=de+"",ae=0;ae<Be.length;)nt[I&ae]=I&(Q^=19*nt[I&ae])+Be.charCodeAt(ae++);return ct(nt)}function ct(de){return String.fromCharCode.apply(0,de)}if(ot(q.random(),G),mt.exports){mt.exports=Ae;try{se=O(5042)}catch{}}else void 0!==(ue=function(){return Ae}.call(Le,O,Le,mt))&&(mt.exports=ue)}(typeof self<"u"?self:this,[],Math)},5410:()=>{},8628:()=>{},5042:()=>{},7156:mt=>{function Le(ue,xe,G,q,P,U,pe){try{var ce=ue[U](pe),X=ce.value}catch(ie){return void G(ie)}ce.done?xe(X):Promise.resolve(X).then(q,P)}mt.exports=function O(ue){return function(){var xe=this,G=arguments;return new Promise(function(q,P){var U=ue.apply(xe,G);function pe(X){Le(U,q,P,pe,ce,"next",X)}function ce(X){Le(U,q,P,pe,ce,"throw",X)}pe(void 0)})}},mt.exports.__esModule=!0,mt.exports.default=mt.exports},5861:(mt,Le,O)=>{"use strict";function ue(G,q,P,U,pe,ce,X){try{var ie=G[ce](X),re=ie.value}catch(I){return void P(I)}ie.done?q(re):Promise.resolve(re).then(U,pe)}function xe(G){return function(){var q=this,P=arguments;return new Promise(function(U,pe){var ce=G.apply(q,P);function X(re){ue(ce,U,pe,X,ie,"next",re)}function ie(re){ue(ce,U,pe,X,ie,"throw",re)}X(void 0)})}}O.d(Le,{Z:()=>xe})}},mt=>{mt(mt.s=7430)}]);